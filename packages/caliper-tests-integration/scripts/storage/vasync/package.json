{
	"name": "vasync",
	"versions": {
		"1.0.0": {
			"name": "vasync",
			"version": "1.0.0",
			"description": "utilities for observable asynchronous control flow",
			"main": "./lib/vasync.js",
			"repository": {
				"type": "git",
				"url": "git://github.com/davepacheco/node-vasync.git"
			},
			"dependencies": {
				"verror": "1.0.0"
			},
			"engines": [
				"node >=0.6.0"
			],
			"_npmUser": {
				"name": "dap",
				"email": "dap@cs.brown.edu"
			},
			"_id": "vasync@1.0.0",
			"devDependencies": {},
			"optionalDependencies": {},
			"_engineSupported": true,
			"_npmVersion": "1.1.4",
			"_nodeVersion": "v0.6.12",
			"_defaultsLoaded": true,
			"dist": {
				"shasum": "6cce87861e8c8bfdbddf408b578a9177e88bfbfa",
				"tarball": "https://registry.npmjs.org/vasync/-/vasync-1.0.0.tgz"
			},
			"maintainers": [
				{
					"name": "dap",
					"email": "dap@cs.brown.edu"
				}
			],
			"directories": {}
		},
		"1.0.1": {
			"name": "vasync",
			"version": "1.0.1",
			"description": "utilities for observable asynchronous control flow",
			"main": "./lib/vasync.js",
			"repository": {
				"type": "git",
				"url": "git://github.com/davepacheco/node-vasync.git"
			},
			"dependencies": {
				"verror": "1.0.1"
			},
			"engines": [
				"node >=0.6.0"
			],
			"_npmUser": {
				"name": "dap",
				"email": "dap@cs.brown.edu"
			},
			"_id": "vasync@1.0.1",
			"devDependencies": {},
			"_engineSupported": false,
			"_npmVersion": "1.0.94",
			"_nodeVersion": "v0.4.2",
			"_defaultsLoaded": true,
			"dist": {
				"shasum": "96385f81789a9580a96c5e96f94a7d2e69e0a4ad",
				"tarball": "https://registry.npmjs.org/vasync/-/vasync-1.0.1.tgz"
			},
			"maintainers": [
				{
					"name": "dap",
					"email": "dap@cs.brown.edu"
				}
			],
			"directories": {}
		},
		"1.1.0": {
			"name": "vasync",
			"version": "1.1.0",
			"description": "utilities for observable asynchronous control flow",
			"main": "./lib/vasync.js",
			"repository": {
				"type": "git",
				"url": "git://github.com/davepacheco/node-vasync.git"
			},
			"dependencies": {
				"verror": "1.1.0"
			},
			"engines": [
				"node >=0.6.0"
			],
			"_npmUser": {
				"name": "dap",
				"email": "dap@cs.brown.edu"
			},
			"_id": "vasync@1.1.0",
			"devDependencies": {},
			"optionalDependencies": {},
			"_engineSupported": true,
			"_npmVersion": "1.1.4",
			"_nodeVersion": "v0.6.10",
			"_defaultsLoaded": true,
			"dist": {
				"shasum": "d8441bc617256be5cf11c338875c0ce0bfd25b59",
				"tarball": "https://registry.npmjs.org/vasync/-/vasync-1.1.0.tgz"
			},
			"maintainers": [
				{
					"name": "dap",
					"email": "dap@cs.brown.edu"
				}
			],
			"directories": {}
		},
		"1.1.1": {
			"name": "vasync",
			"version": "1.1.1",
			"description": "utilities for observable asynchronous control flow",
			"main": "./lib/vasync.js",
			"repository": {
				"type": "git",
				"url": "git://github.com/davepacheco/node-vasync.git"
			},
			"dependencies": {
				"verror": "1.1.0"
			},
			"engines": [
				"node >=0.6.0"
			],
			"_npmUser": {
				"name": "dap",
				"email": "dap@cs.brown.edu"
			},
			"_id": "vasync@1.1.1",
			"devDependencies": {},
			"optionalDependencies": {},
			"_engineSupported": true,
			"_npmVersion": "1.1.16",
			"_nodeVersion": "v0.6.16-pre",
			"_defaultsLoaded": true,
			"dist": {
				"shasum": "81cf5b09e7686effa9cbc3570bacbd67b93b4f38",
				"tarball": "https://registry.npmjs.org/vasync/-/vasync-1.1.1.tgz"
			},
			"maintainers": [
				{
					"name": "dap",
					"email": "dap@cs.brown.edu"
				}
			],
			"directories": {}
		},
		"1.2.0": {
			"name": "vasync",
			"version": "1.2.0",
			"description": "utilities for observable asynchronous control flow",
			"main": "./lib/vasync.js",
			"repository": {
				"type": "git",
				"url": "git://github.com/davepacheco/node-vasync.git"
			},
			"dependencies": {
				"verror": "1.1.0"
			},
			"engines": [
				"node >=0.6.0"
			],
			"_npmUser": {
				"name": "dap",
				"email": "dap@cs.brown.edu"
			},
			"_id": "vasync@1.2.0",
			"devDependencies": {},
			"optionalDependencies": {},
			"_engineSupported": true,
			"_npmVersion": "1.1.21",
			"_nodeVersion": "v0.6.17",
			"_defaultsLoaded": true,
			"dist": {
				"shasum": "659b6820a1e6a9e8c94c281a41b97def30d5083c",
				"tarball": "https://registry.npmjs.org/vasync/-/vasync-1.2.0.tgz"
			},
			"maintainers": [
				{
					"name": "dap",
					"email": "dap@cs.brown.edu"
				}
			],
			"directories": {}
		},
		"1.3.0": {
			"name": "vasync",
			"version": "1.3.0",
			"description": "utilities for observable asynchronous control flow",
			"main": "./lib/vasync.js",
			"repository": {
				"type": "git",
				"url": "git://github.com/davepacheco/node-vasync.git"
			},
			"dependencies": {
				"verror": "1.1.0"
			},
			"engines": [
				"node >=0.6.0"
			],
			"_npmUser": {
				"name": "dap",
				"email": "dap@cs.brown.edu"
			},
			"_id": "vasync@1.3.0",
			"devDependencies": {},
			"optionalDependencies": {},
			"_engineSupported": true,
			"_npmVersion": "1.1.21",
			"_nodeVersion": "v0.6.17",
			"_defaultsLoaded": true,
			"dist": {
				"shasum": "aa46b6e77c81caf566b567c23c44846f29c1268f",
				"tarball": "https://registry.npmjs.org/vasync/-/vasync-1.3.0.tgz"
			},
			"maintainers": [
				{
					"name": "dap",
					"email": "dap@cs.brown.edu"
				}
			],
			"directories": {}
		},
		"1.3.1": {
			"name": "vasync",
			"version": "1.3.1",
			"description": "utilities for observable asynchronous control flow",
			"main": "./lib/vasync.js",
			"repository": {
				"type": "git",
				"url": "git://github.com/davepacheco/node-vasync.git"
			},
			"dependencies": {
				"verror": "1.1.0"
			},
			"engines": [
				"node >=0.6.0"
			],
			"_npmUser": {
				"name": "dap",
				"email": "dap@cs.brown.edu"
			},
			"_id": "vasync@1.3.1",
			"devDependencies": {},
			"optionalDependencies": {},
			"_engineSupported": true,
			"_npmVersion": "1.1.24",
			"_nodeVersion": "v0.6.19",
			"_defaultsLoaded": true,
			"dist": {
				"shasum": "c094498733effa12456fe6aca603895c44f0f15a",
				"tarball": "https://registry.npmjs.org/vasync/-/vasync-1.3.1.tgz"
			},
			"maintainers": [
				{
					"name": "dap",
					"email": "dap@cs.brown.edu"
				}
			],
			"directories": {}
		},
		"1.3.2": {
			"name": "vasync",
			"version": "1.3.2",
			"description": "utilities for observable asynchronous control flow",
			"main": "./lib/vasync.js",
			"repository": {
				"type": "git",
				"url": "git://github.com/davepacheco/node-vasync.git"
			},
			"dependencies": {
				"verror": "1.1.0"
			},
			"engines": [
				"node >=0.6.0"
			],
			"_id": "vasync@1.3.2",
			"dist": {
				"shasum": "818ff03de2e24fe81d01dde13e7133f8184b6f53",
				"tarball": "https://registry.npmjs.org/vasync/-/vasync-1.3.2.tgz"
			},
			"maintainers": [
				{
					"name": "dap",
					"email": "dap@cs.brown.edu"
				}
			],
			"directories": {}
		},
		"1.3.3": {
			"name": "vasync",
			"version": "1.3.3",
			"description": "utilities for observable asynchronous control flow",
			"main": "./lib/vasync.js",
			"repository": {
				"type": "git",
				"url": "git://github.com/davepacheco/node-vasync.git"
			},
			"dependencies": {
				"jsprim": "0.3.0",
				"verror": "1.1.0"
			},
			"engines": [
				"node >=0.6.0"
			],
			"_id": "vasync@1.3.3",
			"dist": {
				"shasum": "84917680717020b67e043902e63bc143174c8728",
				"tarball": "https://registry.npmjs.org/vasync/-/vasync-1.3.3.tgz"
			},
			"_npmVersion": "1.1.66",
			"_npmUser": {
				"name": "dap",
				"email": "dap@cs.brown.edu"
			},
			"maintainers": [
				{
					"name": "dap",
					"email": "dap@cs.brown.edu"
				}
			],
			"directories": {}
		},
		"1.4.0": {
			"name": "vasync",
			"version": "1.4.0",
			"description": "utilities for observable asynchronous control flow",
			"main": "./lib/vasync.js",
			"repository": {
				"type": "git",
				"url": "git://github.com/davepacheco/node-vasync.git"
			},
			"dependencies": {
				"jsprim": "0.3.0",
				"verror": "1.1.0"
			},
			"engines": [
				"node >=0.6.0"
			],
			"license": "MIT",
			"_id": "vasync@1.4.0",
			"dist": {
				"shasum": "6ea5a63582358868d8743cbdd6ffadc9083b910f",
				"tarball": "https://registry.npmjs.org/vasync/-/vasync-1.4.0.tgz"
			},
			"_from": ".",
			"_npmVersion": "1.2.14",
			"_npmUser": {
				"name": "dap",
				"email": "dap@cs.brown.edu"
			},
			"maintainers": [
				{
					"name": "dap",
					"email": "dap@cs.brown.edu"
				}
			],
			"directories": {}
		},
		"1.4.1": {
			"name": "vasync",
			"version": "1.4.1",
			"description": "utilities for observable asynchronous control flow",
			"main": "./lib/vasync.js",
			"repository": {
				"type": "git",
				"url": "git://github.com/davepacheco/node-vasync.git"
			},
			"dependencies": {
				"jsprim": "0.3.0",
				"verror": "1.1.0"
			},
			"engines": [
				"node >=0.6.0"
			],
			"license": "MIT",
			"bugs": {
				"url": "https://github.com/davepacheco/node-vasync/issues"
			},
			"_id": "vasync@1.4.1",
			"dist": {
				"shasum": "9cb6ff02a67baae1a518173513b0b3a2890d9808",
				"tarball": "https://registry.npmjs.org/vasync/-/vasync-1.4.1.tgz"
			},
			"_from": ".",
			"_npmVersion": "1.2.30",
			"_npmUser": {
				"name": "dap",
				"email": "dap@cs.brown.edu"
			},
			"maintainers": [
				{
					"name": "dap",
					"email": "dap@cs.brown.edu"
				}
			],
			"directories": {}
		},
		"1.4.2": {
			"name": "vasync",
			"version": "1.4.2",
			"description": "utilities for observable asynchronous control flow",
			"main": "./lib/vasync.js",
			"repository": {
				"type": "git",
				"url": "git://github.com/davepacheco/node-vasync.git"
			},
			"scripts": {
				"test": "./node_modules/.bin/tap tests/"
			},
			"devDependencies": {
				"tap": "~0.4.8"
			},
			"dependencies": {
				"jsprim": "0.3.0",
				"verror": "1.1.0"
			},
			"engines": [
				"node >=0.6.0"
			],
			"license": "MIT",
			"bugs": {
				"url": "https://github.com/davepacheco/node-vasync/issues"
			},
			"_id": "vasync@1.4.2",
			"dist": {
				"shasum": "443b82d948e4051e089c55b8cc9f74199bf83e39",
				"tarball": "https://registry.npmjs.org/vasync/-/vasync-1.4.2.tgz"
			},
			"_from": ".",
			"_npmVersion": "1.3.8",
			"_npmUser": {
				"name": "dap",
				"email": "dap@cs.brown.edu"
			},
			"maintainers": [
				{
					"name": "dap",
					"email": "dap@cs.brown.edu"
				}
			],
			"directories": {}
		},
		"1.4.3": {
			"name": "vasync",
			"version": "1.4.3",
			"description": "utilities for observable asynchronous control flow",
			"main": "./lib/vasync.js",
			"repository": {
				"type": "git",
				"url": "git://github.com/davepacheco/node-vasync.git"
			},
			"scripts": {
				"test": "./node_modules/.bin/tap tests/"
			},
			"devDependencies": {
				"tap": "~0.4.8"
			},
			"dependencies": {
				"jsprim": "0.3.0",
				"verror": "1.1.0"
			},
			"engines": [
				"node >=0.6.0"
			],
			"license": "MIT",
			"bugs": {
				"url": "https://github.com/davepacheco/node-vasync/issues"
			},
			"_id": "vasync@1.4.3",
			"dist": {
				"shasum": "c86d52e2b71613d29eedf159f3135dbe749cee37",
				"tarball": "https://registry.npmjs.org/vasync/-/vasync-1.4.3.tgz"
			},
			"_from": ".",
			"_npmVersion": "1.3.8",
			"_npmUser": {
				"name": "dap",
				"email": "dap@cs.brown.edu"
			},
			"maintainers": [
				{
					"name": "dap",
					"email": "dap@cs.brown.edu"
				}
			],
			"directories": {}
		},
		"1.5.0": {
			"name": "vasync",
			"version": "1.5.0",
			"description": "utilities for observable asynchronous control flow",
			"main": "./lib/vasync.js",
			"repository": {
				"type": "git",
				"url": "git://github.com/davepacheco/node-vasync.git"
			},
			"scripts": {
				"test": "tap tests/ && ./node_modules/.bin/nodeunit tests/compat.js"
			},
			"devDependencies": {
				"tap": "~0.4.8",
				"nodeunit": "0.8.7"
			},
			"dependencies": {
				"jsprim": "0.3.0",
				"verror": "1.1.0"
			},
			"engines": [
				"node >=0.6.0"
			],
			"license": "MIT",
			"bugs": {
				"url": "https://github.com/davepacheco/node-vasync/issues"
			},
			"homepage": "https://github.com/davepacheco/node-vasync",
			"_id": "vasync@1.5.0",
			"_shasum": "c7dffa8cadc665cbd9a1d5204d4e3e6f5474c69b",
			"_from": ".",
			"_npmVersion": "1.4.9",
			"_npmUser": {
				"name": "dap",
				"email": "dap@cs.brown.edu"
			},
			"maintainers": [
				{
					"name": "dap",
					"email": "dap@cs.brown.edu"
				}
			],
			"dist": {
				"shasum": "c7dffa8cadc665cbd9a1d5204d4e3e6f5474c69b",
				"tarball": "https://registry.npmjs.org/vasync/-/vasync-1.5.0.tgz"
			},
			"directories": {}
		},
		"1.5.1": {
			"name": "vasync",
			"version": "1.5.1",
			"description": "utilities for observable asynchronous control flow",
			"main": "./lib/vasync.js",
			"repository": {
				"type": "git",
				"url": "git://github.com/davepacheco/node-vasync.git"
			},
			"scripts": {
				"test": "tap tests/ && ./node_modules/.bin/nodeunit tests/compat.js"
			},
			"devDependencies": {
				"tap": "~0.4.8",
				"nodeunit": "0.8.7"
			},
			"dependencies": {
				"jsprim": "0.6.1",
				"verror": "1.1.0"
			},
			"engines": [
				"node >=0.6.0"
			],
			"license": "MIT",
			"bugs": {
				"url": "https://github.com/davepacheco/node-vasync/issues"
			},
			"homepage": "https://github.com/davepacheco/node-vasync",
			"_id": "vasync@1.5.1",
			"_shasum": "1240f13eec4c4ef3385ef5d9e1e1adf7c4ce2cf2",
			"_from": ".",
			"_npmVersion": "1.4.9",
			"_npmUser": {
				"name": "dap",
				"email": "dap@cs.brown.edu"
			},
			"maintainers": [
				{
					"name": "dap",
					"email": "dap@cs.brown.edu"
				}
			],
			"dist": {
				"shasum": "1240f13eec4c4ef3385ef5d9e1e1adf7c4ce2cf2",
				"tarball": "https://registry.npmjs.org/vasync/-/vasync-1.5.1.tgz"
			},
			"directories": {}
		},
		"1.6.0": {
			"name": "vasync",
			"version": "1.6.0",
			"description": "utilities for observable asynchronous control flow",
			"main": "./lib/vasync.js",
			"repository": {
				"type": "git",
				"url": "git://github.com/davepacheco/node-vasync.git"
			},
			"scripts": {
				"test": "tap tests/ && ./node_modules/.bin/nodeunit tests/compat.js"
			},
			"devDependencies": {
				"tap": "~0.4.8",
				"nodeunit": "0.8.7"
			},
			"dependencies": {
				"jsprim": "0.6.1",
				"verror": "1.1.0"
			},
			"engines": [
				"node >=0.6.0"
			],
			"license": "MIT",
			"bugs": {
				"url": "https://github.com/davepacheco/node-vasync/issues"
			},
			"homepage": "https://github.com/davepacheco/node-vasync",
			"_id": "vasync@1.6.0",
			"_shasum": "eb99aab507a78d72566d4ed4181e950c335be694",
			"_from": ".",
			"_npmVersion": "1.4.9",
			"_npmUser": {
				"name": "dap",
				"email": "dap@cs.brown.edu"
			},
			"maintainers": [
				{
					"name": "dap",
					"email": "dap@cs.brown.edu"
				}
			],
			"dist": {
				"shasum": "eb99aab507a78d72566d4ed4181e950c335be694",
				"tarball": "https://registry.npmjs.org/vasync/-/vasync-1.6.0.tgz"
			},
			"directories": {}
		},
		"1.6.1": {
			"name": "vasync",
			"version": "1.6.1",
			"description": "utilities for observable asynchronous control flow",
			"main": "./lib/vasync.js",
			"repository": {
				"type": "git",
				"url": "git://github.com/davepacheco/node-vasync.git"
			},
			"scripts": {
				"test": "tap tests/ && ./node_modules/.bin/nodeunit tests/compat.js"
			},
			"devDependencies": {
				"tap": "~0.4.8",
				"nodeunit": "0.8.7"
			},
			"dependencies": {
				"jsprim": "0.6.1",
				"verror": "1.1.0"
			},
			"engines": [
				"node >=0.6.0"
			],
			"license": "MIT",
			"bugs": {
				"url": "https://github.com/davepacheco/node-vasync/issues"
			},
			"homepage": "https://github.com/davepacheco/node-vasync",
			"_id": "vasync@1.6.1",
			"_shasum": "834a47dd09f28bf83da42e24f2f2fd23796527ad",
			"_from": ".",
			"_npmVersion": "1.4.9",
			"_npmUser": {
				"name": "dap",
				"email": "dap@cs.brown.edu"
			},
			"maintainers": [
				{
					"name": "dap",
					"email": "dap@cs.brown.edu"
				}
			],
			"dist": {
				"shasum": "834a47dd09f28bf83da42e24f2f2fd23796527ad",
				"tarball": "https://registry.npmjs.org/vasync/-/vasync-1.6.1.tgz"
			},
			"directories": {}
		},
		"1.6.2": {
			"name": "vasync",
			"version": "1.6.2",
			"description": "utilities for observable asynchronous control flow",
			"main": "./lib/vasync.js",
			"repository": {
				"type": "git",
				"url": "git://github.com/davepacheco/node-vasync.git"
			},
			"scripts": {
				"test": "tap tests/ && ./node_modules/.bin/nodeunit tests/compat.js"
			},
			"devDependencies": {
				"tap": "~0.4.8",
				"nodeunit": "0.8.7"
			},
			"dependencies": {
				"verror": "1.1.0"
			},
			"engines": [
				"node >=0.6.0"
			],
			"license": "MIT",
			"bugs": {
				"url": "https://github.com/davepacheco/node-vasync/issues"
			},
			"homepage": "https://github.com/davepacheco/node-vasync",
			"_id": "vasync@1.6.2",
			"_shasum": "568edcf40b2b5c35b1cc048cad085de4739703fb",
			"_from": ".",
			"_npmVersion": "1.4.9",
			"_npmUser": {
				"name": "dap",
				"email": "dap@cs.brown.edu"
			},
			"maintainers": [
				{
					"name": "dap",
					"email": "dap@cs.brown.edu"
				}
			],
			"dist": {
				"shasum": "568edcf40b2b5c35b1cc048cad085de4739703fb",
				"tarball": "https://registry.npmjs.org/vasync/-/vasync-1.6.2.tgz"
			},
			"directories": {}
		},
		"1.6.3": {
			"name": "vasync",
			"version": "1.6.3",
			"description": "utilities for observable asynchronous control flow",
			"main": "./lib/vasync.js",
			"repository": {
				"type": "git",
				"url": "git://github.com/davepacheco/node-vasync.git"
			},
			"scripts": {
				"test": "tap tests/ && ./node_modules/.bin/nodeunit tests/compat.js"
			},
			"devDependencies": {
				"tap": "~0.4.8",
				"nodeunit": "0.8.7"
			},
			"dependencies": {
				"verror": "1.6.0"
			},
			"engines": [
				"node >=0.6.0"
			],
			"license": "MIT",
			"bugs": {
				"url": "https://github.com/davepacheco/node-vasync/issues"
			},
			"homepage": "https://github.com/davepacheco/node-vasync",
			"_id": "vasync@1.6.3",
			"_shasum": "4a69d7052a47f4ce85503d7641df1cbf40432a94",
			"_from": ".",
			"_npmVersion": "1.4.9",
			"_npmUser": {
				"name": "dap",
				"email": "dap@cs.brown.edu"
			},
			"maintainers": [
				{
					"name": "dap",
					"email": "dap@cs.brown.edu"
				}
			],
			"dist": {
				"shasum": "4a69d7052a47f4ce85503d7641df1cbf40432a94",
				"tarball": "https://registry.npmjs.org/vasync/-/vasync-1.6.3.tgz"
			},
			"directories": {}
		},
		"1.6.4": {
			"name": "vasync",
			"version": "1.6.4",
			"description": "utilities for observable asynchronous control flow",
			"main": "./lib/vasync.js",
			"repository": {
				"type": "git",
				"url": "git://github.com/davepacheco/node-vasync.git"
			},
			"scripts": {
				"test": "tap tests/ && ./node_modules/.bin/nodeunit tests/compat.js"
			},
			"devDependencies": {
				"tap": "~0.4.8",
				"nodeunit": "0.8.7"
			},
			"dependencies": {
				"verror": "1.6.0"
			},
			"engines": [
				"node >=0.6.0"
			],
			"license": "MIT",
			"gitHead": "e7a557e09fea5fcd712324e24f8859c8f1f12736",
			"bugs": {
				"url": "https://github.com/davepacheco/node-vasync/issues"
			},
			"homepage": "https://github.com/davepacheco/node-vasync#readme",
			"_id": "vasync@1.6.4",
			"_shasum": "dfe93616ad0e7ae801b332a9d88bfc5cdc8e1d1f",
			"_from": ".",
			"_npmVersion": "2.11.3",
			"_nodeVersion": "0.12.7",
			"_npmUser": {
				"name": "dap",
				"email": "dap@cs.brown.edu"
			},
			"maintainers": [
				{
					"name": "dap",
					"email": "dap@cs.brown.edu"
				}
			],
			"dist": {
				"shasum": "dfe93616ad0e7ae801b332a9d88bfc5cdc8e1d1f",
				"tarball": "https://registry.npmjs.org/vasync/-/vasync-1.6.4.tgz"
			},
			"_npmOperationalInternal": {
				"host": "packages-12-west.internal.npmjs.com",
				"tmp": "tmp/vasync-1.6.4.tgz_1458664991691_0.0071555261965841055"
			},
			"directories": {}
		},
		"2.0.0": {
			"name": "vasync",
			"version": "2.0.0",
			"description": "utilities for observable asynchronous control flow",
			"main": "./lib/vasync.js",
			"repository": {
				"type": "git",
				"url": "git://github.com/davepacheco/node-vasync.git"
			},
			"scripts": {
				"test": "tap --stdout tests/ && ./node_modules/.bin/nodeunit tests/compat.js && ./node_modules/.bin/nodeunit tests/compat_tryEach.js"
			},
			"devDependencies": {
				"tap": "~0.4.8",
				"nodeunit": "0.8.7"
			},
			"dependencies": {
				"verror": "1.6.0"
			},
			"engines": [
				"node >=0.6.0"
			],
			"license": "MIT",
			"gitHead": "0132f9ea2104981ca16d1e0360a72c1a7b76c509",
			"bugs": {
				"url": "https://github.com/davepacheco/node-vasync/issues"
			},
			"homepage": "https://github.com/davepacheco/node-vasync#readme",
			"_id": "vasync@2.0.0",
			"_shasum": "6712849dec6731923197b1cfb8a992e5ffc3f8b6",
			"_from": ".",
			"_npmVersion": "2.15.1",
			"_nodeVersion": "0.10.46",
			"_npmUser": {
				"name": "dap",
				"email": "dap@cs.brown.edu"
			},
			"maintainers": [
				{
					"name": "dap",
					"email": "dap@cs.brown.edu"
				}
			],
			"dist": {
				"shasum": "6712849dec6731923197b1cfb8a992e5ffc3f8b6",
				"tarball": "https://registry.npmjs.org/vasync/-/vasync-2.0.0.tgz"
			},
			"_npmOperationalInternal": {
				"host": "s3://npm-registry-packages",
				"tmp": "tmp/vasync-2.0.0.tgz_1502407023446_0.264645243762061"
			},
			"directories": {}
		},
		"2.1.0": {
			"name": "vasync",
			"version": "2.1.0",
			"description": "utilities for observable asynchronous control flow",
			"main": "./lib/vasync.js",
			"repository": {
				"type": "git",
				"url": "git://github.com/davepacheco/node-vasync.git"
			},
			"scripts": {
				"test": "tap --stdout tests/ && ./node_modules/.bin/nodeunit tests/compat.js && ./node_modules/.bin/nodeunit tests/compat_tryEach.js"
			},
			"devDependencies": {
				"tap": "~0.4.8",
				"nodeunit": "0.8.7"
			},
			"dependencies": {
				"verror": "1.10.0"
			},
			"engines": [
				"node >=0.6.0"
			],
			"license": "MIT",
			"gitHead": "548e7982ab07a0855e5694e6fe691f21397be527",
			"bugs": {
				"url": "https://github.com/davepacheco/node-vasync/issues"
			},
			"homepage": "https://github.com/davepacheco/node-vasync#readme",
			"_id": "vasync@2.1.0",
			"_shasum": "5343302b666d663227663fd128493be662943e08",
			"_from": ".",
			"_npmVersion": "2.15.1",
			"_nodeVersion": "0.10.46",
			"_npmUser": {
				"name": "dap",
				"email": "dap@cs.brown.edu"
			},
			"maintainers": [
				{
					"name": "dap",
					"email": "dap@cs.brown.edu"
				}
			],
			"dist": {
				"shasum": "5343302b666d663227663fd128493be662943e08",
				"tarball": "https://registry.npmjs.org/vasync/-/vasync-2.1.0.tgz"
			},
			"_npmOperationalInternal": {
				"host": "s3://npm-registry-packages",
				"tmp": "tmp/vasync-2.1.0.tgz_1505428360896_0.1874261803459376"
			},
			"directories": {}
		},
		"2.2.0": {
			"name": "vasync",
			"version": "2.2.0",
			"description": "utilities for observable asynchronous control flow",
			"main": "./lib/vasync.js",
			"repository": {
				"type": "git",
				"url": "git://github.com/davepacheco/node-vasync.git"
			},
			"scripts": {
				"test": "tap --stdout tests/ && ./node_modules/.bin/nodeunit tests/compat.js && ./node_modules/.bin/nodeunit tests/compat_tryEach.js"
			},
			"devDependencies": {
				"tap": "~0.4.8",
				"nodeunit": "0.8.7"
			},
			"dependencies": {
				"verror": "1.10.0"
			},
			"engines": [
				"node >=0.6.0"
			],
			"license": "MIT",
			"bugs": {
				"url": "https://github.com/davepacheco/node-vasync/issues"
			},
			"homepage": "https://github.com/davepacheco/node-vasync",
			"_id": "vasync@2.2.0",
			"_shasum": "cfde751860a15822db3b132bc59b116a4adaf01b",
			"_from": ".",
			"_npmVersion": "1.4.9",
			"_npmUser": {
				"name": "dap",
				"email": "dap@cs.brown.edu"
			},
			"maintainers": [
				{
					"name": "dap",
					"email": "dap@cs.brown.edu"
				}
			],
			"dist": {
				"shasum": "cfde751860a15822db3b132bc59b116a4adaf01b",
				"tarball": "https://registry.npmjs.org/vasync/-/vasync-2.2.0.tgz"
			},
			"_npmOperationalInternal": {
				"host": "s3://npm-registry-packages",
				"tmp": "tmp/vasync-2.2.0.tgz_1512139548991_0.5218220378737897"
			},
			"directories": {}
		}
	},
	"time": {
		"modified": "2019-09-06T22:14:12.991Z",
		"created": "2012-04-18T01:16:52.863Z",
		"1.0.0": "2012-04-18T01:16:54.275Z",
		"1.0.1": "2012-04-18T16:24:11.946Z",
		"1.1.0": "2012-05-01T19:23:09.649Z",
		"1.1.1": "2012-05-09T17:14:02.773Z",
		"1.2.0": "2012-05-11T22:45:38.400Z",
		"1.3.0": "2012-05-16T22:35:02.569Z",
		"1.3.1": "2012-06-26T23:27:55.437Z",
		"1.3.2": "2012-08-18T01:45:19.886Z",
		"1.3.3": "2013-01-07T18:10:51.785Z",
		"1.4.0": "2013-09-02T15:50:18.485Z",
		"1.4.1": "2013-12-16T22:35:03.692Z",
		"1.4.2": "2014-01-15T19:30:39.212Z",
		"1.4.3": "2014-01-21T23:20:31.578Z",
		"1.5.0": "2014-05-30T22:47:35.423Z",
		"1.5.1": "2014-08-07T18:47:45.431Z",
		"1.6.0": "2014-09-08T23:25:25.988Z",
		"1.6.1": "2014-09-25T00:10:47.839Z",
		"1.6.2": "2014-11-17T18:47:31.231Z",
		"1.6.3": "2015-04-01T15:21:10.972Z",
		"1.6.4": "2016-03-22T16:43:12.153Z",
		"2.0.0": "2017-08-10T23:17:03.525Z",
		"2.1.0": "2017-09-14T22:32:41.056Z",
		"2.2.0": "2017-12-01T14:45:49.576Z"
	},
	"dist-tags": {
		"latest": "2.2.0"
	},
	"_uplinks": {
		"npmjs": {
			"etag": "W/\"07dffe52cc71363886c58ce68cb7a64b\"",
			"fetched": 1568994345453
		}
	},
	"_distfiles": {
		"vasync-1.0.0.tgz": {
			"url": "https://registry.npmjs.org/vasync/-/vasync-1.0.0.tgz",
			"sha": "6cce87861e8c8bfdbddf408b578a9177e88bfbfa",
			"registry": "npmjs"
		},
		"vasync-1.0.1.tgz": {
			"url": "https://registry.npmjs.org/vasync/-/vasync-1.0.1.tgz",
			"sha": "96385f81789a9580a96c5e96f94a7d2e69e0a4ad",
			"registry": "npmjs"
		},
		"vasync-1.1.0.tgz": {
			"url": "https://registry.npmjs.org/vasync/-/vasync-1.1.0.tgz",
			"sha": "d8441bc617256be5cf11c338875c0ce0bfd25b59",
			"registry": "npmjs"
		},
		"vasync-1.1.1.tgz": {
			"url": "https://registry.npmjs.org/vasync/-/vasync-1.1.1.tgz",
			"sha": "81cf5b09e7686effa9cbc3570bacbd67b93b4f38",
			"registry": "npmjs"
		},
		"vasync-1.2.0.tgz": {
			"url": "https://registry.npmjs.org/vasync/-/vasync-1.2.0.tgz",
			"sha": "659b6820a1e6a9e8c94c281a41b97def30d5083c",
			"registry": "npmjs"
		},
		"vasync-1.3.0.tgz": {
			"url": "https://registry.npmjs.org/vasync/-/vasync-1.3.0.tgz",
			"sha": "aa46b6e77c81caf566b567c23c44846f29c1268f",
			"registry": "npmjs"
		},
		"vasync-1.3.1.tgz": {
			"url": "https://registry.npmjs.org/vasync/-/vasync-1.3.1.tgz",
			"sha": "c094498733effa12456fe6aca603895c44f0f15a",
			"registry": "npmjs"
		},
		"vasync-1.3.2.tgz": {
			"url": "https://registry.npmjs.org/vasync/-/vasync-1.3.2.tgz",
			"sha": "818ff03de2e24fe81d01dde13e7133f8184b6f53",
			"registry": "npmjs"
		},
		"vasync-1.3.3.tgz": {
			"url": "https://registry.npmjs.org/vasync/-/vasync-1.3.3.tgz",
			"sha": "84917680717020b67e043902e63bc143174c8728",
			"registry": "npmjs"
		},
		"vasync-1.4.0.tgz": {
			"url": "https://registry.npmjs.org/vasync/-/vasync-1.4.0.tgz",
			"sha": "6ea5a63582358868d8743cbdd6ffadc9083b910f",
			"registry": "npmjs"
		},
		"vasync-1.4.1.tgz": {
			"url": "https://registry.npmjs.org/vasync/-/vasync-1.4.1.tgz",
			"sha": "9cb6ff02a67baae1a518173513b0b3a2890d9808",
			"registry": "npmjs"
		},
		"vasync-1.4.2.tgz": {
			"url": "https://registry.npmjs.org/vasync/-/vasync-1.4.2.tgz",
			"sha": "443b82d948e4051e089c55b8cc9f74199bf83e39",
			"registry": "npmjs"
		},
		"vasync-1.4.3.tgz": {
			"url": "https://registry.npmjs.org/vasync/-/vasync-1.4.3.tgz",
			"sha": "c86d52e2b71613d29eedf159f3135dbe749cee37",
			"registry": "npmjs"
		},
		"vasync-1.5.0.tgz": {
			"url": "https://registry.npmjs.org/vasync/-/vasync-1.5.0.tgz",
			"sha": "c7dffa8cadc665cbd9a1d5204d4e3e6f5474c69b",
			"registry": "npmjs"
		},
		"vasync-1.5.1.tgz": {
			"url": "https://registry.npmjs.org/vasync/-/vasync-1.5.1.tgz",
			"sha": "1240f13eec4c4ef3385ef5d9e1e1adf7c4ce2cf2",
			"registry": "npmjs"
		},
		"vasync-1.6.0.tgz": {
			"url": "https://registry.npmjs.org/vasync/-/vasync-1.6.0.tgz",
			"sha": "eb99aab507a78d72566d4ed4181e950c335be694",
			"registry": "npmjs"
		},
		"vasync-1.6.1.tgz": {
			"url": "https://registry.npmjs.org/vasync/-/vasync-1.6.1.tgz",
			"sha": "834a47dd09f28bf83da42e24f2f2fd23796527ad",
			"registry": "npmjs"
		},
		"vasync-1.6.2.tgz": {
			"url": "https://registry.npmjs.org/vasync/-/vasync-1.6.2.tgz",
			"sha": "568edcf40b2b5c35b1cc048cad085de4739703fb",
			"registry": "npmjs"
		},
		"vasync-1.6.3.tgz": {
			"url": "https://registry.npmjs.org/vasync/-/vasync-1.6.3.tgz",
			"sha": "4a69d7052a47f4ce85503d7641df1cbf40432a94",
			"registry": "npmjs"
		},
		"vasync-1.6.4.tgz": {
			"url": "https://registry.npmjs.org/vasync/-/vasync-1.6.4.tgz",
			"sha": "dfe93616ad0e7ae801b332a9d88bfc5cdc8e1d1f",
			"registry": "npmjs"
		},
		"vasync-2.0.0.tgz": {
			"url": "https://registry.npmjs.org/vasync/-/vasync-2.0.0.tgz",
			"sha": "6712849dec6731923197b1cfb8a992e5ffc3f8b6",
			"registry": "npmjs"
		},
		"vasync-2.1.0.tgz": {
			"url": "https://registry.npmjs.org/vasync/-/vasync-2.1.0.tgz",
			"sha": "5343302b666d663227663fd128493be662943e08",
			"registry": "npmjs"
		},
		"vasync-2.2.0.tgz": {
			"url": "https://registry.npmjs.org/vasync/-/vasync-2.2.0.tgz",
			"sha": "cfde751860a15822db3b132bc59b116a4adaf01b",
			"registry": "npmjs"
		}
	},
	"_attachments": {},
	"_rev": "1-f4ca2f06121bfd5b",
	"_id": "vasync",
	"readme": "# vasync: observable asynchronous control flow\n\nThis module provides several functions for asynchronous control flow.  There are\nmany modules that do this already (notably async.js).  This one's claim to fame\nis improved debuggability.\n\n\n## Observability is important\n\nWorking with Node's asynchronous, callback-based model is much easier with a\nhandful of simple control-flow abstractions, like:\n\n* waterfalls and pipelines (which invoke a list of asynchronous callbacks\n  sequentially)\n* parallel pipelines (which invoke a list of asynchronous callbacks in parallel\n  and invoke a top-level callback when the last one completes).\n* queues\n* barriers\n\nBut these structures also introduce new types of programming errors: failing to\ninvoke the callback can cause the program to hang, and inadvertently invoking it\ntwice can cause all kinds of mayhem that's very difficult to debug.\n\nThe functions in this module keep track of what's going on so that you can\nfigure out what happened when your program goes wrong.  They generally return an\nobject describing details of the current state.  If your program goes wrong, you\nhave several ways of getting at this state:\n\n* On illumos-based systems, use MDB to [find the status object](http://dtrace.org/blogs/bmc/2012/05/05/debugging-node-js-memory-leaks/)\n  and then [print it out](http://dtrace.org/blogs/dap/2012/01/13/playing-with-nodev8-postmortem-debugging/).\n* Provide an HTTP API (or AMQP, or whatever) that returns these pending status\n  objects as JSON (see [kang](https://github.com/davepacheco/kang)).\n* Incorporate a REPL into your program and print out the status object.\n* Use the Node debugger to print out the status object.\n\n## Functions\n\n* [parallel](#parallel-invoke-n-functions-in-parallel): invoke N functions in\n  parallel (and merge the results)\n* [forEachParallel](#foreachparallel-invoke-the-same-function-on-n-inputs-in-parallel):\n  invoke the same function on N inputs in parallel\n* [pipeline](#pipeline-invoke-n-functions-in-series-and-stop-on-failure): invoke\n  N functions in series (and stop on failure)\n* [tryEach](#tryeach-invoke-n-functions-in-series-and-stop-on-success): invoke\n  N functions in series (and stop on success)\n* [forEachPipeline](#foreachpipeline-invoke-the-same-function-on-n-inputs-in-series-and-stop-on-failure):\n  invoke the same function on N inputs in series (and stop on failure)\n* [filter/filterSeries/filterLimit](#filterfilterlimitfilterseries-filter-n-inputs-serially-or-concurrently):\n  filter N inputs serially or concurrently\n* [whilst](#whilst-invoke-a-function-repeatedly-until-a-stopping-condition-is-met):\n  invoke a function repeatedly until a stopping condition is met\n* [waterfall](#waterfall-invoke-n-functions-in-series-stop-on-failure-and-propagate-results):\n  like pipeline, but propagating results between stages\n* [barrier](#barrier-coordinate-multiple-concurrent-operations): coordinate\n  multiple concurrent operations\n* [queue/queuev](#queuequeuev-fixed-size-worker-queue): fixed-size worker queue\n\n### parallel: invoke N functions in parallel\n\nSynopsis: `parallel(args, callback)`\n\nThis function takes a list of input functions (specified by the \"funcs\" property\nof \"args\") and runs them all.  These input functions are expected to be\nasynchronous: they get a \"callback\" argument and should invoke it as\n`callback(err, result)`.  The error and result will be saved and made available\nto the original caller when all of these functions complete.\n\nThis function returns the same \"result\" object it passes to the callback, and\nyou can use the fields in this object to debug or observe progress:\n\n* `operations`: array corresponding to the input functions, with\n    * `func`: input function,\n    * `status`: \"pending\", \"ok\", or \"fail\",\n    * `err`: returned \"err\" value, if any, and\n    * `result`: returned \"result\" value, if any\n* `successes`: \"result\" field for each of \"operations\" where\n  \"status\" == \"ok\" (in no particular order)\n* `ndone`: number of input operations that have completed\n* `nerrors`: number of input operations that have failed\n\nThis status object lets you see in a debugger exactly which functions have\ncompleted, what they returned, and which ones are outstanding.\n\nAll errors are combined into a single \"err\" parameter to the final callback (see\nbelow).\n\nExample usage:\n\n```js\nconsole.log(mod_vasync.parallel({\n    'funcs': [\n        function f1 (callback) { mod_dns.resolve('joyent.com', callback); },\n        function f2 (callback) { mod_dns.resolve('github.com', callback); },\n        function f3 (callback) { mod_dns.resolve('asdfaqsdfj.com', callback); }\n    ]\n}, function (err, results) {\n        console.log('error: %s', err.message);\n        console.log('results: %s', mod_util.inspect(results, null, 3));\n}));\n```\n\nIn the first tick, this outputs:\n\n```js\nstatus: { operations:\n   [ { func: [Function: f1], status: 'pending' },\n     { func: [Function: f2], status: 'pending' },\n     { func: [Function: f3], status: 'pending' } ],\n  successes: [],\n  ndone: 0,\n  nerrors: 0 }\n```\n\nshowing that there are three operations pending and none has yet been started.\nWhen the program finishes, it outputs this error:\n\n    error: first of 1 error: queryA ENOTFOUND\n\nwhich encapsulates all of the intermediate failures.  This model allows you to\nwrite the final callback like you normally would:\n\n```js\nif (err)\n  return (callback(err));\n```\n\nand still propagate useful information to callers that don't deal with multiple\nerrors (i.e. most callers).\n\nThe example also prints out the detailed final status, including all of the\nerrors and return values:\n\n```js\nresults: { operations:\n   [ { func: [Function: f1],\n       funcname: 'f1',\n       status: 'ok',\n       err: null,\n       result: [ '165.225.132.33' ] },\n     { func: [Function: f2],\n       funcname: 'f2',\n       status: 'ok',\n       err: null,\n       result: [ '207.97.227.239' ] },\n     { func: [Function: f3],\n       funcname: 'f3',\n       status: 'fail',\n       err: { [Error: queryA ENOTFOUND] code: 'ENOTFOUND',\n          errno: 'ENOTFOUND', syscall: 'queryA' },\n       result: undefined } ],\n  successes: [ [ '165.225.132.33' ], [ '207.97.227.239' ] ],\n  ndone: 3,\n  nerrors: 1 }\n```\n\nYou can use this if you want to handle all of the errors individually or to get\nat all of the individual return values.\n\nNote that \"successes\" is provided as a convenience and the order of items in\nthat array may not correspond to the order of the inputs.  To consume output in\nan ordered manner, you should iterate over \"operations\" and pick out the result\nfrom each item.\n\n\n### forEachParallel: invoke the same function on N inputs in parallel\n\nSynopsis: `forEachParallel(args, callback)`\n\nThis function is exactly like `parallel`, except that the input is specified as\na *single* function (\"func\") and a list of inputs (\"inputs\").  The function is\ninvoked on each input in parallel.\n\nThis example is exactly equivalent to the one above:\n\n```js\nconsole.log(mod_vasync.forEachParallel({\n    'func': mod_dns.resolve,\n    'inputs': [ 'joyent.com', 'github.com', 'asdfaqsdfj.com' ]\n}, function (err, results) {\n    console.log('error: %s', err.message);\n    console.log('results: %s', mod_util.inspect(results, null, 3));\n}));\n```\n\n### pipeline: invoke N functions in series (and stop on failure)\n\nSynopsis: `pipeline(args, callback)`\n\nThe named arguments (that go inside `args`) are:\n\n* `funcs`: input functions, to be invoked in series\n* `arg`: arbitrary argument that will be passed to each function\n\nThe functions are invoked in order as `func(arg, callback)`, where \"arg\" is the\nuser-supplied argument from \"args\" and \"callback\" should be invoked in the usual\nway.  If any function emits an error, the whole pipeline stops.\n\nThe return value and the arguments to the final callback are exactly the same as\nfor `parallel`.  The error object for the final callback is just the error\nreturned by whatever pipeline function failed (if any).\n\nThis example is similar to the one above, except that it runs the steps in\nsequence and stops early because `pipeline` stops on the first error:\n\n```js\nconsole.log(mod_vasync.pipeline({\n    'funcs': [\n        function f1 (_, callback) { mod_fs.stat('/tmp', callback); },\n        function f2 (_, callback) { mod_fs.stat('/noexist', callback); },\n        function f3 (_, callback) { mod_fs.stat('/var', callback); }\n    ]\n}, function (err, results) {\n        console.log('error: %s', err.message);\n        console.log('results: %s', mod_util.inspect(results, null, 3));\n}));\n```\n\nAs a result, the status after the first tick looks like this:\n\n```js\n{ operations:\n   [ { func: [Function: f1], status: 'pending' },\n     { func: [Function: f2], status: 'waiting' },\n     { func: [Function: f3], status: 'waiting' } ],\n  successes: [],\n  ndone: 0,\n  nerrors: 0 }\n```\n\nNote that the second and third stages are now \"waiting\", rather than \"pending\"\nin the `parallel` case.  The error and complete result look just like the\nparallel case.\n\n### tryEach: invoke N functions in series (and stop on success)\n\nSynopsis: `tryEach(funcs, callback)`\n\nThe `tryEach` function invokes each of the asynchronous functions in `funcs`\nserially. Each function takes a single argument: an interstitial-callback.\n`tryEach` will keep calling the functions until one of them succeeds (or they\nall fail).  At the end, the terminating-callback is invoked with the error\nand/or results provided by the last function that was called (either the last\none that failed or the first one that succeeded).\n\nThis example is similar to the one above, except that it runs the steps in\nsequence and stops early because `tryEach` stops on the first success:\n\n```js\nconsole.log(mod_vasync.tryEach([\n        function f1 (callback) { mod_fs.stat('/notreal', callback); },\n        function f2 (callback) { mod_fs.stat('/noexist', callback); },\n        function f3 (callback) { mod_fs.stat('/var', callback); },\n        function f4 (callback) { mod_fs.stat('/noexist', callback); }\n    ],\n    function (err, results) {\n            console.log('error: %s', err);\n            console.log('results: %s', mod_util.inspect(results));\n}));\n\n```\n\nThe above code will stop when it finishes f3, and we will only print a single\nresult and no errors:\n\n```js\nerror: null\nresults: { dev: 65760,\n  mode: 16877,\n  nlink: 41,\n  uid: 0,\n  gid: 3,\n  rdev: -1,\n  blksize: 2560,\n  ino: 11,\n  size: 41,\n  blocks: 7,\n  atime: Thu May 28 2015 16:21:25 GMT+0000 (UTC),\n  mtime: Thu Jan 21 2016 22:08:50 GMT+0000 (UTC),\n  ctime: Thu Jan 21 2016 22:08:50 GMT+0000 (UTC) }\n```\n\nIf we comment out `f3`, we get the following output:\n\n```js\nerror: Error: ENOENT, stat '/noexist'\nresults: undefined\n```\n\nNote that: there is a mismatch (inherited from `async`) between the semantics\nof the interstitial callback and the sematics of the terminating callback. See\nthe following example:\n\n```js\nconsole.log(mod_vasync.tryEach([\n        function f1 (callback) { callback(new Error()); },\n        function f2 (callback) { callback(new Error()); },\n        function f3 (callback) { callback(null, 1, 2, 3); },\n        function f4 (callback) { callback(null, 1); }\n    ],\n    function (err, results) {\n            console.log('error: %s', err);\n            console.log('results: %s', mod_util.inspect(results));\n}));\n\n```\n\nWe pass one or more results to the terminating-callback via the\ninterstitial-callback's arglist -- `(err, res1, res2, ...)`. From the\ncallback-implementor's perspective, the results get wrapped up in an array\n`(err, [res1, res2, ...])` -- unless there is only one result, which simply\ngets passed through as the terminating callback's second argument. This means\nthat when we call the callback in `f3` above, the terminating callback receives\nthe list `[1, 2, 3]` as its second argument. If, we comment out `f3`, we will\nend up calling the callback in `f4` which will end up invoking the terminating\ncallback with a single result: `1`, instead of `[1]`.\n\n\nIn short, be mindful that there is not always a 1:1 correspondence between the\nterminating callback that you define, and the interstitial callback that gets\ncalled from the function.\n\n\n\n### forEachPipeline: invoke the same function on N inputs in series (and stop on failure)\n\nSynopsis: `forEachPipeline(args, callback)`\n\nThis function is exactly like `pipeline`, except that the input is specified as\na *single* function (\"func\") and a list of inputs (\"inputs\").  The function is\ninvoked on each input in series.\n\nThis example is exactly equivalent to the one above:\n\n```js\nconsole.log(mod_vasync.forEachPipeline({\n    'func': mod_dns.resolve,\n    'inputs': [ 'joyent.com', 'github.com', 'asdfaqsdfj.com' ]\n}, function (err, results) {\n    console.log('error: %s', err.message);\n    console.log('results: %s', mod_util.inspect(results, null, 3));\n}));\n```\n\n### waterfall: invoke N functions in series, stop on failure, and propagate results\n\nSynopsis: `waterfall(funcs, callback)`\n\nThis function works like `pipeline` except for argument passing.\n\nEach function is passed any values emitted by the previous function (none for\nthe first function), followed by the callback to invoke upon completion.  This\ncallback must be invoked exactly once, regardless of success or failure.  As\nconventional in Node, the first argument to the callback indicates an error (if\nnon-null).  Subsequent arguments are passed to the next function in the \"funcs\"\nchain.\n\nIf any function fails (i.e., calls its callback with an Error), then the\nremaining functions are not invoked and \"callback\" is invoked with the error.\n\nThe only difference between waterfall() and pipeline() are the arguments passed\nto each function in the chain.  pipeline() always passes the same argument\nfollowed by the callback, while waterfall() passes whatever values were emitted\nby the previous function followed by the callback.\n\nHere's an example:\n\n```js\nmod_vasync.waterfall([\n    function func1(callback) {\n \tsetImmediate(function () {\n\t\tcallback(null, 37);\n\t});\n    },\n    function func2(extra, callback) {\n\tconsole.log('func2 got \"%s\" from func1', extra);\n\tcallback();\n    }\n], function () {\n\tconsole.log('done');\n});\n```\n\nThis prints:\n\n```\nfunc2 got \"37\" from func1\nbetter stop early\n```\n\n### filter/filterLimit/filterSeries: filter N inputs serially or concurrently\n\nSynopsis: `filter(inputs, filterFunc, callback)`\n\nSynopsis: `filterSeries(inputs, filterFunc, callback)`\n\nSynopsis: `filterLimit(inputs, limit, filterFunc, callback)`\n\nThese functions take an array (of anything) and a function to call on each\nelement of the array.  The function must callback with a true or false value as\nthe second argument or an error object as the first argument.  False values\nwill result in the element being filtered out of the results array.  An error\nobject passed as the first argument will cause the filter function to stop\nprocessing new elements and callback to the caller with the error immediately.\nOriginal input array order is maintained.\n\n`filter` and `filterSeries` are analogous to calling `filterLimit` with\na limit of `Infinity` and `1` respectively.\n\n\n```js\nvar inputs = [\n    'joyent.com',\n    'github.com',\n    'asdfaqsdfj.com'\n];\nfunction filterFunc(input, cb) {\n    mod_dns.resolve(input, function (err, results) {\n        if (err) {\n            cb(null, false);\n        } else {\n            cb(null, true);\n        }\n    }\n}\nmod_vasync.filter(inputs, filterFunc, function (err, results) {\n    // err => undefined\n    // results => ['joyent.com', 'github.com']\n});\n```\n\n### whilst: invoke a function repeatedly until a stopping condition is met\n\nSynopsis: `whilst(testFunc, iterateFunc, callback)`\n\nRepeatedly invoke `iterateFunc` while `testFunc` returns a true value.\n`iterateFunc` is an asychronous function that must call its callback (the first\nand only argument given to it) when it is finished with an optional error\nobject as the first argument, and any other arbitrary arguments.  If an error\nobject is given as the first argument, `whilst` will finish and call `callback`\nwith the error object.  `testFunc` is a synchronous function that must return\na value - if the value resolves to true `whilst` will invoke `iterateFunc`, if\nit resolves to false `whilst` will finish and invoke `callback` with the last\nset of arguments `iterateFunc` called back with.\n\n`whilst` also returns an object suitable for introspecting the current state of\nthe specific `whilst` invocation which contains the following properties:\n\n* `finished`: boolean if this invocation has finished or is in progress\n* `iterations`: number of iterations performed (calls to `iterateFunc`)\n\nCompatible with `async.whilst`\n\n```js\nvar n = 0;\n\nvar w = mod_vasync.whilst(\n    function testFunc() {\n        return (n < 5);\n    },\n    function iterateFunc(cb) {\n        n++;\n        cb(null, {n: n});\n    },\n    function whilstDone(err, arg) {\n        // err => undefined\n        // arg => {n: 5}\n        // w => {finished: true, iterations: 5}\n    }\n);\n\n// w => {finished: false, iterations: 0}\n```\n\n### barrier: coordinate multiple concurrent operations\n\nSynopsis: `barrier([args])`\n\nReturns a new barrier object.  Like `parallel`, barriers are useful for\ncoordinating several concurrent operations, but instead of specifying a list of\nfunctions to invoke, you just say how many (and optionally which ones) are\noutstanding, and this object emits `'drain'` when they've all completed.  This\nis syntactically lighter-weight, and more flexible.\n\n* Methods:\n\n    * start(name): Indicates that the named operation began.  The name must not\n      match an operation which is already ongoing.\n    * done(name): Indicates that the named operation ended.\n\n\n* Read-only public properties (for debugging):\n\n    * pending: Set of pending operations.  Keys are names passed to \"start\", and\n      values are timestamps when the operation began.\n    * recent: Array of recent completed operations.  Each element is an object\n      with a \"name\", \"start\", and \"done\" field.  By default, 10 operations are\n      remembered.\n\n\n* Options:\n\n    * nrecent: number of recent operations to remember (for debugging)\n\nExample: printing sizes of files in a directory\n\n```js\nvar mod_fs = require('fs');\nvar mod_path = require('path');\nvar mod_vasync = require('../lib/vasync');\n\nvar barrier = mod_vasync.barrier();\n\nbarrier.on('drain', function () {\n  console.log('all files checked');\n});\n\nbarrier.start('readdir');\n\nmod_fs.readdir(__dirname, function (err, files) {\n  barrier.done('readdir');\n\n  if (err)\n    throw (err);\n\n  files.forEach(function (file) {\n    barrier.start('stat ' + file);\n\n    var path = mod_path.join(__dirname, file);\n\n    mod_fs.stat(path, function (err2, stat) {\n      barrier.done('stat ' + file);\n      console.log('%s: %d bytes', file, stat['size']);\n    });\n  });\n});\n```\n\nThis emits:\n\n    barrier-readdir.js: 602 bytes\n    foreach-parallel.js: 358 bytes\n    barrier-basic.js: 552 bytes\n    nofail.js: 384 bytes\n    pipeline.js: 490 bytes\n    parallel.js: 481 bytes\n    queue-serializer.js: 441 bytes\n    queue-stat.js: 529 bytes\n    all files checked\n\n\n### queue/queuev: fixed-size worker queue\n\nSynopsis: `queue(worker, concurrency)`\n\nSynopsis: `queuev(args)`\n\nThis function returns an object that allows up to a fixed number of tasks to be\ndispatched at any given time.  The interface is compatible with that provided\nby the \"async\" Node library, except that the returned object's fields represent\na public interface you can use to introspect what's going on.\n\n* Arguments\n\n    * worker: a function invoked as `worker(task, callback)`, where `task` is a\n      task dispatched to this queue and `callback` should be invoked when the\n      task completes.\n    * concurrency: a positive integer indicating the maximum number of tasks\n      that may be dispatched at any time.  With concurrency = 1, the queue\n      serializes all operations.\n\n\n* Methods\n\n    * push(task, [callback]): add a task (or array of tasks) to the queue, with\n      an optional callback to be invoked when each task completes.  If a list of\n      tasks are added, the callback is invoked for each one.\n    * length(): for compatibility with node-async.\n    * close(): signal that no more tasks will be enqueued.  Further attempts to\n      enqueue tasks to this queue will throw.  Once all pending and queued\n      tasks are completed the object will emit the \"end\" event.  The \"end\"\n      event is the last event the queue will emit, and it will be emitted even\n      if no tasks were ever enqueued.\n    * kill(): clear enqueued tasks and implicitly close the queue.  Several\n      caveats apply when kill() is called:\n        * The completion callback will _not_ be called for items purged from\n          the queue.\n        * The drain handler is cleared (for node-async compatibility)\n        * Subsequent calls to kill() or close() are no-ops.\n        * As with close(), it is not legal to call push() after kill().\n\n\n* Read-only public properties (for debugging):\n\n    * concurrency: for compatibility with node-async\n    * worker: worker function, as passed into \"queue\"/\"queuev\"\n    * worker\\_name: worker function's \"name\" field\n    * npending: the number of tasks currently being processed\n    * pending: an object (*not* an array) describing the tasks currently being\n      processed\n    * queued: array of tasks currently queued for processing\n    * closed: true when close() has been called on the queue\n    * ended: true when all tasks have completed processing, and no more\n      processing will occur\n    * killed: true when kill() has been called on the queue\n\n\n* Hooks (for compatibility with node-async):\n\n    * saturated\n    * empty\n    * drain\n\n* Events\n\n    * 'end': see close()\n\nIf the tasks are themselves simple objects, then the entire queue may be\nserialized (as via JSON.stringify) for debugging and monitoring tools.  Using\nthe above fields, you can see what this queue is doing (worker\\_name), which\ntasks are queued, which tasks are being processed, and so on.\n\n### Example 1: Stat several files\n\nHere's an example demonstrating the queue:\n\n```js\nvar mod_fs = require('fs');\nvar mod_vasync = require('../lib/vasync');\n\nvar queue;\n\nfunction doneOne()\n{\n  console.log('task completed; queue state:\\n%s\\n',\n      JSON.stringify(queue, null, 4));\n}\n\nqueue = mod_vasync.queue(mod_fs.stat, 2);\n\nconsole.log('initial queue state:\\n%s\\n', JSON.stringify(queue, null, 4));\n\nqueue.push('/tmp/file1', doneOne);\nqueue.push('/tmp/file2', doneOne);\nqueue.push('/tmp/file3', doneOne);\nqueue.push('/tmp/file4', doneOne);\n\nconsole.log('all tasks dispatched:\\n%s\\n', JSON.stringify(queue, null, 4));\n```\n\nThe initial queue state looks like this:\n\n```js\ninitial queue state:\n{\n    \"nextid\": 0,\n    \"worker_name\": \"anon\",\n    \"npending\": 0,\n    \"pending\": {},\n    \"queued\": [],\n    \"concurrency\": 2\n}\n```\nAfter four tasks have been pushed, we see that two of them have been dispatched\nand the remaining two are queued up:\n\n```js\nall tasks pushed:\n{\n    \"nextid\": 4,\n    \"worker_name\": \"anon\",\n    \"npending\": 2,\n    \"pending\": {\n        \"1\": {\n            \"id\": 1,\n            \"task\": \"/tmp/file1\"\n        },\n        \"2\": {\n            \"id\": 2,\n            \"task\": \"/tmp/file2\"\n        }\n    },\n    \"queued\": [\n        {\n            \"id\": 3,\n            \"task\": \"/tmp/file3\"\n        },\n        {\n            \"id\": 4,\n            \"task\": \"/tmp/file4\"\n        }\n    ],\n    \"concurrency\": 2\n}\n```\n\nAs they complete, we see tasks moving from \"queued\" to \"pending\", and completed\ntasks disappear:\n\n```js\ntask completed; queue state:\n{\n    \"nextid\": 4,\n    \"worker_name\": \"anon\",\n    \"npending\": 1,\n    \"pending\": {\n        \"3\": {\n            \"id\": 3,\n            \"task\": \"/tmp/file3\"\n        }\n    },\n    \"queued\": [\n        {\n            \"id\": 4,\n            \"task\": \"/tmp/file4\"\n        }\n    ],\n    \"concurrency\": 2\n}\n```\n\nWhen all tasks have completed, the queue state looks like it started:\n\n```js\ntask completed; queue state:\n{\n    \"nextid\": 4,\n    \"worker_name\": \"anon\",\n    \"npending\": 0,\n    \"pending\": {},\n    \"queued\": [],\n    \"concurrency\": 2\n}\n```\n\n\n### Example 2: A simple serializer\n\nYou can use a queue with concurrency 1 and where the tasks are themselves\nfunctions to ensure that an arbitrary asynchronous function never runs\nconcurrently with another one, no matter what each one does.  Since the tasks\nare the actual functions to be invoked, the worker function just invokes each\none:\n\n```js\nvar mod_vasync = require('../lib/vasync');\n\nvar queue = mod_vasync.queue(\n    function (task, callback) { task(callback); }, 1);\n\nqueue.push(function (callback) {\n  console.log('first task begins');\n  setTimeout(function () {\n    console.log('first task ends');\n    callback();\n  }, 500);\n});\n\nqueue.push(function (callback) {\n  console.log('second task begins');\n  process.nextTick(function () {\n    console.log('second task ends');\n    callback();\n  });\n});\n```\n\nThis example outputs:\n\n    $ node examples/queue-serializer.js\n    first task begins\n    first task ends\n    second task begins\n    second task ends"
}