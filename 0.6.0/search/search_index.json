{"config":{"lang":["en"],"separator":"[\\s\\u200b\\-_,:!=\\[\\]()\"`/]+|\\.(?!\\d)|&[lg]t;|(?!\\b)(?=[A-Z][a-z])","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Caliper","text":"<p>Caliper is a blockchain performance benchmark framework, which allows users to test different blockchain solutions with predefined use cases, and get a set of performance test results.</p>"},{"location":"#supported-blockchain-solutions","title":"Supported Blockchain Solutions","text":"<p>Currently supported blockchain solutions:</p> <ul> <li>Hyperledger Besu</li> <li>Ethereum</li> <li>Hyperledger Fabric</li> </ul>"},{"location":"#supported-performance-metrics","title":"Supported Performance Metrics","text":"<ul> <li>Transaction/read throughput</li> <li>Transaction/read latency (minimum, maximum, average, percentile)</li> <li>Resource consumption (CPU, Memory, Network IO, \u2026)</li> </ul> <p>See PSWG for the exact definitions and corresponding measurement methods.</p>"},{"location":"#architecture","title":"Architecture","text":"<p>It helps to have a basic understanding of how Caliper works before diving into the examples. Have a look at the Architecture page!</p>"},{"location":"#installing-caliper","title":"Installing Caliper","text":"<p>Head to the Install &amp; Usage page if you want to try Caliper right now. It\u2019s as simple as downloading an NPM package or starting a Docker container!</p>"},{"location":"#sample-networks","title":"Sample Networks","text":"<p>Sample benchmarks that may be used by Caliper are hosted on a companion GitHub repository.</p> <p>Important</p> <p>make sure that the version/tag of the benchmark repository matches the version of Caliper you are using! For example, if you are using Caliper v0.6.0, then <code>checkout</code> the <code>v0.6.0</code> tag after cloning the benchmark repository. The <code>main</code> branch of the benchmark repository corresponds to the latest <code>unstable</code> Caliper version.</p>"},{"location":"#how-to-contribute","title":"How to Contribute","text":"<p>Every contribution is welcome! See the Contributing page for details.</p>"},{"location":"#license","title":"License","text":"<p>The Caliper codebase is released under the Apache 2.0 license. Any documentation developed by the Caliper Project is licensed under the Creative Commons Attribution 4.0 International License. You may obtain a copy of the license, titled CC-BY-4.0, at http://creativecommons.org/licenses/by/4.0/.</p>"},{"location":"concepts/bench-config/","title":"Benchmark Configuration","text":""},{"location":"concepts/bench-config/#overview","title":"Overview","text":"<p>The <code>benchmark configuration file</code> is one of the required configuration files necessary to run a Caliper benchmark. In contrast to the runtime configurations, used for tweaking the internal behavior of Caliper, the benchmark configuration pertains only to the execution of the benchmark workload and collection of the results.</p> <p>Note</p> <p>In theory, a benchmark configuration is independent of the system under test (SUT) and the internal configuration of Caliper. However, this independence might be limited by the implementation details of the benchmark workload module, which could target only a single SUT type.</p> <p>The benchmark configuration consists of three main parts:</p> <ul> <li>Overview</li> <li>Benchmark test settings</li> <li>Monitoring settings</li> <li>Example</li> <li>License</li> </ul> <p>For a complete benchmark configuration example, refer to the last section.</p> <p>Note</p> <p>The configuration file can be either a YAML or JSON file, conforming to the format described below. The benchmark configuration file path can be specified for the manager and worker processes using the <code>caliper-benchconfig</code> setting key.</p>"},{"location":"concepts/bench-config/#benchmark-test-settings","title":"Benchmark test settings","text":"<p>The settings related to the benchmark workload all reside under the root <code>test</code> attribute, which has some general child attributes, and the important <code>rounds</code> attribute.</p> Attribute Description test.name Short name of the benchmark to display in the report. test.description Detailed description of the benchmark to display in the report. test.workers Object of worker-related configurations. test.workers.type Currently unused. test.workers.number Specifies the number of worker processes to use for executing the workload. test.rounds Array of objects, each describing the settings of a round. test.rounds[i].label A short name of the rounds, usually corresponding to the types of submitted TXs. test.rounds[i].txNumber The number of TXs Caliper should submit during the round. test.rounds[i].txDuration The length of the round in seconds during which Caliper will submit TXs. test.rounds[i].rateControl The object describing the rate controller to use for the round. test.rounds[i].workload The object describing the workload module used for the round. test.rounds[i].workload.module The path to the benchmark workload module implementation that will construct the TXs to submit. test.rounds[i].workload.arguments Arbitrary object that will be passed to the workload module as configuration. <p>A benchmark configuration with the above structure will define a benchmark run that consists of multiple rounds. Each round is associated with a rate controller that is responsible for the scheduling of TXs, and a workload module that will generate the actual content of the scheduled TXs.</p>"},{"location":"concepts/bench-config/#monitoring-settings","title":"Monitoring settings","text":"<p>The monitoring configuration determines what kind of metrics the manager process can gather and from where. The configuration resides under the <code>monitors</code> attribute. Refer to the monitors configuration page for the details.</p>"},{"location":"concepts/bench-config/#example","title":"Example","text":"<p>The example configuration below says the following:</p> <ul> <li>Perform the benchmark run using 5 worker processes.</li> <li>There will be two rounds.</li> <li>The first init round will submit 500 TXs at a fixed 25 TPS send rate.</li> <li>The content of the TXs are determined by the <code>init.js</code> workload module.</li> <li>The second <code>query</code> round will submit TXs for 60 seconds at a fixed 5 TPS send rate.</li> <li>The content of the TXs are determined by the <code>query.js</code> workload module.</li> <li>The manager process will allow a Prometheus server to scrape information on port 3000 with a default scrape url of /metrics</li> <li>The manager process should include the predefined metrics of all local Docker containers in the report.</li> <li>The manager process should include the custom metric <code>Endorse Time (s)</code> based on the provided query for every available (peer) instance.</li> </ul> <pre><code>test:\n  workers:\n    number: 5\n  rounds:\n    - label: init\n      txNumber: 500\n      rateControl:\n        type: fixed-rate\n        opts:\n          tps: 25\n      workload:\n        module: benchmarks/samples/fabric/marbles/init.js\n    - label: query\n      txDuration: 60\n      rateControl:\n        type: fixed-rate\n        opts:\n          tps: 5\n      workload:\n        module: benchmarks/samples/fabric/marbles/query.js\nmonitors:\n  transaction:\n  - module: prometheus\n  resource:\n  - module: docker\n    options:\n      interval: 1\n      containers: ['all']\n  - module: prometheus\n    options:\n      url: \"http://prometheus:9090\"\n      metrics:\n        include: [dev-.*, couch, peer, orderer]\n        queries:\n        - name: Endorse Time (s)\n          query: rate(endorser_propsal_duration_sum{chaincode=\"marbles:v0\"}[5m])/rate(endorser_propsal_duration_count{chaincode=\"marbles:v0\"}[5m])\n          step: 1\n          label: instance\n          statistic: avg\n</code></pre>"},{"location":"concepts/bench-config/#license","title":"License","text":"<p>The Caliper codebase is released under the Apache 2.0 license. Any documentation developed by the Caliper Project is licensed under the Creative Commons Attribution 4.0 International License. You may obtain a copy of the license, titled CC-BY-4.0, at http://creativecommons.org/licenses/by/4.0/.</p>"},{"location":"concepts/benchmark-generators/","title":"Benchmark Generators","text":""},{"location":"concepts/benchmark-generators/#overview","title":"Overview","text":"<p>The Caliper benchmark generator is a Yeoman generator for generating the configuration and callback files used to perform benchmarks on deployed smart contracts. This page will take you through installing and using the generator.</p>"},{"location":"concepts/benchmark-generators/#installation","title":"Installation","text":"<p>You must first have Yeoman installed to be able to install and use the generator. You can do this using the following command:</p> <pre><code>npm install -g yo\n</code></pre> <p>Once Yeoman is installed, use the following command to install the generator:</p> <pre><code>npm install -g @hyperledger/generator-caliper\n</code></pre>"},{"location":"concepts/benchmark-generators/#using-the-generator","title":"Using the Generator","text":"<p>To use the generator, run the following command</p> <pre><code>yo caliper\n</code></pre> <p>If successful, you should get the following output where you will be prompted to choose a generator - choose Benchmark to run the Caliper benchmark generator:</p> <pre><code>Welcome to the Hyperledger Caliper generator!\n? Which generator would you like to run? (Use arrow keys)\n\u276f Benchmark\n</code></pre> <p>Note</p> <p>Alternatively, you can run the benchmark generator using: <code>yo caliper:benchmark</code>.</p> <p>You will then get the following output where you will be prompted to name your workspace:</p> <pre><code>Welcome to the Hyperledger Caliper benchmark generator!\nLet's start off by creating a workspace folder!\n? What would you like to call your workspace? myWorkspace\n</code></pre>"},{"location":"concepts/benchmark-generators/#callback-prompts","title":"Callback Prompts","text":"<p>The benchmark generator will inititally take you through generating the callback file and you will be prompted for:</p> <ul> <li>the name of your smart contract,</li> <li>the version of your smart contract,</li> <li>a smart contract function</li> <li>the argument variables of your smart contract function, which must be entered in array format</li> </ul> <p>By the end, you should have something similar to the following:</p> <pre><code>Now for the callback file...\n? What is the name of your smart contract? fabcar\n? What is the version of your smart contract? 0.0.1\n? Which smart contract function would you like to perform the benchmark on? changeCarOwner\n? What are the arguments of your smart contract function? (e.g. [\"arg1\", \"arg2\"]) [\"CAR001\", \"Tom\"]\n</code></pre>"},{"location":"concepts/benchmark-generators/#configuration-prompts","title":"Configuration Prompts","text":"<p>Next, you will be taken through generating the configuration file and you will be prompted for:</p> <ul> <li>the name of the benchmark</li> <li>a description of the benchmark</li> <li>the number of workers</li> </ul> <p>Note</p> <p>On an invalid input value for workers, a default value will be used.</p> <ul> <li>a label for differentiating between multiple rounds</li> <li>the rate controller you would like to use. The generator currently provides the rate controllers displayed below as options. The generated configuration file will use default <code>opts</code> for whichever rate controller is chosen.</li> </ul> <pre><code>? Which rate controller would you like to use? (Use arrow keys)\n\u276f Fixed Rate\n  Fixed Backlog\n  Linear Rate\n  Fixed Feedback Rate\n</code></pre> <ul> <li>the method of which you should like to measure the length of the round. The round may be measured using either transaction duration, which defines the length of the round in seconds, or transaction number, which defines the length of the round using the number of transactions to be generated in the round.</li> </ul> <pre><code>? How would you like to measure the length of the round? (Use arrow keys)\n\u276f Transaction Duration\n  Transaction Number\n</code></pre> <ul> <li>a value for either <code>txNumber</code> or <code>txDuration</code> depending on the answer to previous prompt.</li> </ul> <p>Note</p> <p>On an invalid input value for either txDuration or txNumber, a default value will be used.</p> <p>By the end, you should have something similar to the following:</p> <pre><code>Now for the benchmark configuration file...\n? What would you like to name your benchmark? Fabcar benchmark\n? What description would you like to provide for your benchamrk? Benchmark for performance testing fabcar contract modules\n? How many workers would you like to have? 5\n? What label (hint for test) would you like to provide for your benchmark? Round for changing car owner\n? Which rate controller would you like to use? Fixed Rate\n? How would you like to measure the length of the round? Transaction Number\n? How many transactions would you like to have in this round? 60\n</code></pre> <p>On successful generation, you should see the following:</p> <pre><code>Generating benchmarking files...\n   create myBenchmark/benchmarks/callbacks/changeCarOwner.js\n   create myBenchmark/benchmarks/config.yaml\nFinished generating benchmarking files\n</code></pre> <p>The generator can also be run non-interactively from the command line using the following command line options:</p> Options Default Description <code>--workspace</code> A workspace to put all the generated benchmark files. <code>--contractId</code> The name of your smart contract. <code>--version</code> The version of your smart contract. <code>--contractFunction</code> Your smart contract function. <code>--contractArguments</code> <code>[]</code> The arguments of your smart contract function. These must be in an array format. <code>--benchmarkName</code> A name for your benchmark. <code>--benchmarkDescription</code> A description for your benchmark. <code>--workers</code> <code>5</code> A value for the number of workers. <code>--label</code> A label for the round. <code>--rateController</code> The rate controller. <code>--txType</code> The way you would like to measure the length of the round - either \u201ctxDuration\u201d or \u201ctxNumber\u201d. <code>--txDuration</code> <code>50</code> The value for transaction duration if \u201ctxDuration\u201d was entered for txType. <code>--txNumber</code> <code>50</code> The value for transaction number if \u201ctxNumber\u201d was entered for txType. <p>Below is an example of the generator being run non-interactively from the command line using the options above:</p> <pre><code>yo caliper:benchmark -- --workspace 'myWorkspace' --contractId 'fabcar' --version '0.0.1' --contractFunction 'changeCarOwner' --contractArguments '[\"CAR001\", \"Tom\"]' --benchmarkName 'Fabcar benchmark' --benchmarkDescription 'Benchmark for performance testing fabcar contract modules' --workers 5 --label 'Round for changing car owner' --rateController 'fixed-rate' --txType 'txDuration' --txDuration 50\n</code></pre> <p>Note</p> <p>All the options above are required when using the generator non-interactively.</p>"},{"location":"concepts/benchmark-generators/#next-steps","title":"Next Steps","text":"<p>The generated files will be placed within the workspace directory you named at the beginning of the generator, and you should have a directory structure similar to the one shown below:</p> <pre><code>.myWorkspace\n\u2514\u2500\u2500 benchmarks\n    \u2502  callbacks\n    \u2502  \u2514\u2500\u2500 changeCarOwner.js\n    \u2514\u2500 config.yaml\n</code></pre> <p>Currently, the generator does not provide <code>invokerIdentity</code> or <code>contractArguments</code> as inputs to your callback file. Should these be required, you will need to provide these in the <code>run</code> function of your callback file.</p> <p>The generator only generates a single callback file for a single smart contract function. If you would like to test other smart contract functions, you may create more callback files under the callbacks directory. You will also need to update your benchmark configuration file to take into account the extra callbacks.</p> <p>Note</p> <p>The benchmark generator will only create the benchmark configuration file and the callback file. You will still need to provide a network configuration file to be able to perform the benchmark.</p>"},{"location":"concepts/benchmark-generators/#license","title":"License","text":"<p>The Caliper codebase is released under the Apache 2.0 license. Any documentation developed by the Caliper Project is licensed under the Creative Commons Attribution 4.0 International License. You may obtain a copy of the license, titled CC-BY-4.0, at http://creativecommons.org/licenses/by/4.0/.</p>"},{"location":"concepts/caliper-messengers/","title":"Messengers","text":""},{"location":"concepts/caliper-messengers/#overview","title":"Overview","text":"<p>Caliper uses an orchestrator to control workers that interact with the SUT in order to perform a benchmark. Messages are passed between the orchestrator and all workers in order to keep the workers synchronized, and to progress the specified benchmark tests. A user may specify the messaging protocol that is user by Caliper in order to facilitate communications between the orchestrator and worker.</p>"},{"location":"concepts/caliper-messengers/#messengers","title":"Messengers","text":"<p>The messaging protocol to be used for communications between the orchestrator and worker during a benchmark is declared in the <code>caliper runtime configuration file</code>. Unspecified values will default to those specified in the default configuration file.</p> <p>Permitted messengers are:</p> <ul> <li>Process: The <code>process</code> messenger is the default messenger and is based on native NodeJS <code>process</code> based communications. This messenger type is only valid for instances when local workers are being used to perform a benchmark.</li> <li>MQTT: The <code>mqtt</code> messenger uses MQTT to facilitate communication between the orchestrator and workers. This messenger type is valid for both local and distributed workers, and assumes the existence of an MQTT broker service that may be used, such as mosquitto.</li> </ul> <p>Note</p> <p>Mosquitto v2 requires explicit authorization and authentication configurations, which is a breaking change compared to v1. To migrate to v2, follow the official migration guide of Mosquitto.</p> <p>The following yaml extract specifies the use of an MQTT communication method, using an existing MQTT broker that may be connected to via the specified address:</p> <pre><code>    worker:\n        communication:\n            method: mqtt\n            address: mqtt://localhost:1883\n</code></pre> <p>If not specifying a <code>caliper.yaml</code> configuration file, the above may be specified as command line arguments to the CLI process as:</p> <pre><code>--caliper-worker-communication-method mqtt --caliper-worker-communication-address mqtt://localhost:1883\n</code></pre>"},{"location":"concepts/caliper-messengers/#license","title":"License","text":"<p>The Caliper codebase is released under the Apache 2.0 license. Any documentation developed by the Caliper Project is licensed under the Creative Commons Attribution 4.0 International License. You may obtain a copy of the license, titled CC-BY-4.0, at http://creativecommons.org/licenses/by/4.0/.</p>"},{"location":"concepts/caliper-monitors/","title":"Resource and Transaction Monitors","text":""},{"location":"concepts/caliper-monitors/#overview","title":"Overview","text":"<p>Caliper monitoring modules are used to collect resource utilization and transaction statistics during test execution, with the output being collated into the generated reports. Caliper monitors resources and transactions using:</p> <ul> <li>Resource monitors. Collect statistics on resource utilization during benchmarking, with monitoring reset between test rounds.</li> <li>Transaction monitors. Collect worker transaction statistics and provide conditional dispatch actions.</li> </ul>"},{"location":"concepts/caliper-monitors/#resource","title":"Resource","text":"<p>The type of resource monitor to be used within a Caliper benchmark is declared in the <code>benchmark configuration file</code> through the specification one or more monitoring modules in an array under the label <code>monitors.resource</code>.</p> <p>Permitted monitors are:</p> <ul> <li>Process: The <code>process</code> monitor enables monitoring of a named process on the host machine, and is most typically used to monitor the resources consumed by the running clients. This monitor will retrieve statistics on: [memory(max), memory(avg), CPU(max), CPU(avg), Network I/O, Disc I/O]</li> <li>Docker: The <code>docker</code> monitor enables monitoring of specified Docker containers on the host or a remote machine, through using the Docker Remote API to retrieve container statistics. This monitor will retrieve statistics on: [memory(max), memory(avg), CPU(max), CPU(avg), Network I/O, Disc I/O]</li> <li>Prometheus: The <code>prometheus</code> monitor enables the retrieval of data from Prometheus. This monitor will only report based on explicit user provided queries that are issued to Prometheus. If defined, the provision of a Prometheus server will cause Caliper to default to using the Prometheus PushGateway.</li> </ul> <p>Each declared resource monitoring module is accompanied with options required to configure each of the named monitors. A common option for some modules is <code>interval</code>, which is used to configure the refresh interval at which point resource utilization is measured by the monitor.</p>"},{"location":"concepts/caliper-monitors/#process-monitor","title":"Process Monitor","text":"<p>The process monitoring module options comprise:</p> <ul> <li>interval: monitor update interval in seconds</li> <li>processes: of an array of <code>[command, arguments, multiOutput]</code> key:value pairs.<ul> <li>command: names the parent process to monitor</li> <li>arguments: filters on the parent process being monitored</li> <li>multiOutput: enables handling of the discovery of multiple processes and may be one of:</li> <li>avg: take the average of process values discovered under <code>command/name</code></li> <li>sum: sum all process values discovered under <code>command/name</code></li> </ul> </li> </ul> <p>The following declares the monitoring of all local <code>node</code> processes that match <code>caliper.js</code>, with a 3 second update frequency, and the average of all discovered processes being taken.</p> <pre><code>monitors:\n  resource:\n  - module: process\n    options:\n      interval: 3\n      processes: [{ command: 'node', arguments: 'caliper.js', multiOutput: 'avg' }]\n</code></pre>"},{"location":"concepts/caliper-monitors/#docker-monitor","title":"Docker Monitor","text":"<p>The docker monitoring module options comprise:</p> <ul> <li>interval: monitor update interval in seconds</li> <li>cpuUsageNormalization: an optional boolean that may be used to convert the cpu usage in a more covenient value (scaled to 100) by normalising for the number of cores of the host machine, default is set to false</li> <li>containers: an array of container names that may relate to local or remote docker containers to be monitored. If all local docker containers are to be monitored, this may be achieved by providing <code>all</code> as a name</li> </ul> <p>The following declares the monitoring of two named docker containers; one local and the other remote, with a 5 second update frequency:</p> <pre><code>monitors:\n  resource:\n  - module: docker\n    options:\n      interval: 5\n      containers:\n      - peer0.org1.example.com\n      - http://192.168.1.100:2375/orderer.example.com\n</code></pre> <p>The following declares the monitoring of all local docker containers, with a 5 second update frequency and normalization of the cpuUsage metric set to true.</p> <pre><code>monitors:\n  resource:\n  - module: docker\n    options:\n      interval: 5\n      cpuUsageNormalization: true\n      containers:\n      - all\n</code></pre>"},{"location":"concepts/caliper-monitors/#prometheus-monitor","title":"Prometheus Monitor","text":"<p>Prometheus is an open-source systems monitoring and alerting toolkit that scrapes metrics from instrumented jobs, either directly or via an intermediary push gateway for short-lived jobs. It stores all scraped samples locally and runs rules over this data to either aggregate and record new time series from existing data or generate alerts. Grafana or other API consumers can be used to visualize the collected data.</p> <p>All data stored on Prometheus may be queried by Caliper using the Prometheus query HTTP API. At a minimum this may be used to perform aggregate queries in order to report back the transaction statistics, though it is also possible to perform custom queries in order to report back information that has been scraped from other connected sources. Queries issued are intended to generate reports and so are expected to result in either a single value, or a vector that can be condensed into a single value through the application of a statistical routine. It is advisable to create required queries using Grafana to ensure correct operation before transferring the query into the monitor. Please see Prometheus and Grafana documentation for more information.</p>"},{"location":"concepts/caliper-monitors/#configuring-the-prometheus-monitor","title":"Configuring The Prometheus Monitor","text":"<p>The prometheus monitoring module options comprise:</p> <ul> <li>url: The Prometheus URL, used for direct queries</li> <li>metrics: The queries to be run for inclusion within the Caliper report, comprised of to keys: include and queries.<ul> <li><code>include</code> a string array that is used to determine metric inclusion through javascript regex. Any query results where the label of interest, as specified in the queries block, matches an item within the include list via regex, will be included in a generated report.</li> <li><code>queries</code> a series of blocks that describe the queries that are to be run at the end of each Caliper test.</li> </ul> </li> </ul> <p>The <code>queries</code> block is defined by:</p> <ul> <li>name: the metric name that the query relates to, used when building the report</li> <li>query: the query to be issued to the Prometheus server at the end of each test. Note that Caliper will add time bounding for the query so that only results pertaining to the test round are included.</li> <li>step: the timing step size to use within the range query</li> <li>label: a string to match on the returned query and used as a component identifier when populating the report</li> <li>statistic: if multiple values are returned, for instance if looking at a specific resource over a time range, the statistic will condense the values to a single result to enable reporting. Permitted options are:<ul> <li>avg: return the average from all values</li> <li>max: return the maximum from all values</li> <li>min: return the minimum from all values</li> <li>sum: return the summation of all values</li> <li>multiplier: An optional multiplier that may be used to convert exported metrics into a more convenient value (such as converting bytes to GB)</li> </ul> </li> </ul> <p>The following declares a Prometheus monitor that will run two bespoke queries between each test within the benchmark</p> <p><pre><code>monitors:\n    resource:\n    - module: prometheus\n      options:\n        url: \"http://localhost:9090\"\n        metrics:\n            include: [dev-.*, couch, peer, orderer]\n            queries:\n                - name: Endorse Time (s)\n                  query: rate(endorser_propsal_duration_sum{chaincode=\"marbles:v0\"}[1m])/rate(endorser_propsal_duration_count{chaincode=\"marbles:v0\"}[1m])\n                  step: 1\n                  label: instance\n                  statistic: avg\n                - name: Max Memory (MB)\n                  query: sum(container_memory_rss{name=~\".+\"}) by (name)\n                  step: 10\n                  label: name\n                  statistic: max\n                  multiplier: 0.000001\n</code></pre> The two queries above will be listed in the generated report as \u201cEndorse Time (s)\u201d and \u201cMax Memory (MB)\u201d respectively:</p> <ul> <li>Endorse Time (s): Runs the listed query with a step size of 1; filters on return tags within the Prometheus query response using the <code>instance</code> label; exclude the result if the instance value does not regex match any of the string values provided in the <code>include</code> array; if the instance does match an include option, then determine the average of all return results and return this value to be reported under \u201cEndorse Time (s)\u201d.</li> <li>Max Memory (MB): Runs the listed query with a step size of 10; filter return tags within the Prometheus query response using the <code>name</code> label; exclude the result if the instance value does not regex match any of the string values provided in the <code>include</code> array; if the instance does match an include option, then determine the maximum of all return results; multiply by the provided multiplier and return this value to be reported under \u201cMax Memory (MB)\u201d.</li> </ul> <p>Returned components with labels that pass a regex test against the <code>include</code> array items, will be included within the report; all others will be omitted.</p>"},{"location":"concepts/caliper-monitors/#basic-auth","title":"Basic Auth","text":"<p>It is possible to use a Prometheus Server that is secured via basic authentication through provision of a username and password as runtime parameters, under the flags:</p> <ul> <li>caliper-auth-prometheus-username</li> <li>caliper-auth-prometheus-password</li> </ul> <p>These will be used to augment the configuration file based URL prior to making a connection.</p>"},{"location":"concepts/caliper-monitors/#transaction","title":"Transaction","text":"<p>Transaction monitors are used by Caliper workers to act on the completion of transactions. They are used internally to aggregate and dispatch transaction statistics to the manager process to enable transaction statistics aggregation for progress reporting via the default transaction monitor, and report generation.</p> <p>The default transaction monitor, used for progress reporting by consuming information from the internal transaction monitor, may be updated through configuration file settings:</p> <ul> <li><code>caliper-progress-reporting-enabled</code>: boolean flag to enable progress reporting, default true</li> <li> <p><code>caliper-progress-reporting-interval</code>: numeric value to set the update frequency, in milliseconds (default 5000) Additional transaction monitoring modules include:</p> </li> <li> <p>logging</p> </li> <li>prometheus-push</li> </ul> <p>One or more transaction modules may be specified by naming them as modules with an accompanying options block in an array format under <code>monitors.transaction</code>.</p>"},{"location":"concepts/caliper-monitors/#logging","title":"Logging","text":"<p>The <code>logging</code> transaction module is used to log aggregated transaction statistics at the completion of a test round, within the worker. The following specifies the use of a <code>logging</code> transaction monitor. No options are required by the module.</p> <pre><code>monitors:\n    transaction:\n    - module: logging\n</code></pre>"},{"location":"concepts/caliper-monitors/#prometheus","title":"Prometheus","text":"<p>The <code>prometheus</code> transaction module is used to expose current transaction statistics of all workers to a Prometheus server, via a scrape mechanism. The module exposes the following metrics:</p> <ul> <li>caliper_tx_submitted (counter)</li> <li>caliper_tx_finished (counter)</li> <li>caliper_tx_e2e_latency (histogram)</li> </ul> <p>The following specifies the use of a <code>prometheus</code> transaction module that exposes metrics for collection on the default port (3000) and the default scrape URL (<code>/metrics</code>).</p> <pre><code>monitors:\n    transaction:\n    - module: prometheus\n</code></pre> <p>If operating with process based workers, each worker will increment the default (or overridden) port with their 0 based index, thereby exposing metrics for each worker on different ports.</p> <p>It is the responsibility of the user to configure a Prometheus server that correctly targets the exposed URLS through a correctly specified configuration file.</p> <p>Options comprise:</p> <ul> <li>metricPath: override for the metrics path to be scraped (default /metrics).</li> <li>scrapePort: override for the port to be used when configuring the scrape sever (default 3000).</li> <li>processMetricCollectInterval: time interval for default metrics collection, enabled when present</li> <li>defaultLabels: object of key:value pairs to augment the default labels applied to the exposed metrics during collection.</li> <li>histogramBuckets: override for the histogram to be used for collection of caliper_tx_e2e_latency<ul> <li>explicit: direct pass through of user defined bucket</li> <li>linear: use a linear bucket with user defined start, width and count parameters<ul> <li>start: start bucket size</li> <li>width: bucket width</li> <li>count: number of buckets to create</li> </ul> </li> <li>exponential<ul> <li>start: start bucket size</li> <li>factor: bucket factor</li> <li>count: number of buckets to create</li> </ul> </li> </ul> </li> </ul>"},{"location":"concepts/caliper-monitors/#prometheus-push-gateway","title":"Prometheus Push Gateway","text":"<p>The <code>prometheus-push</code> transaction module is used to expose current transaction statistics of all workers to a Prometheus server, via a push gateway. The module exposes the following metrics:</p> <ul> <li>caliper_tx_submitted (counter)</li> <li>caliper_tx_finished (counter)</li> <li>caliper_tx_e2e_latency (histogram)</li> </ul> <p>The following specifies the use of a <code>prometheus-push</code> transaction module that sends current transaction statistics to a push gateway located at <code>http://localhost:9091</code> at 5 second intervals.</p> <pre><code>monitors:\n    transaction:\n    - module: prometheus-push\n      options:\n        pushInterval: 5000\n        pushUrl: \"http://localhost:9091\"\n</code></pre> <p>Options comprise:</p> <ul> <li>pushInterval: push interval in milliseconds</li> <li>pushUrl: URL for Prometheus Push Gateway</li> <li>processMetricCollectInterval: time interval for default metrics collection, enabled when present</li> <li>defaultLabels: object of key:value pairs to augment the default labels applied to the exposed metrics during collection.</li> <li>histogramBuckets: override for the histogram to be used for collection of caliper_tx_e2e_latency<ul> <li>explicit: direct pass through of user defined bucket</li> <li>linear: use a linear bucket with user defined start, width and count parameters<ul> <li>start: start bucket size</li> <li>width: bucket width</li> <li>count: number of buckets to create</li> </ul> </li> <li>exponential<ul> <li>start: start bucket size</li> <li>factor: bucket factor</li> <li>count: number of buckets to create</li> </ul> </li> </ul> </li> </ul> <p>Use of a <code>prometheus-push</code> transaction module is predicated on the availability and use of a Prometheus Push Gateway that is available as a scrape target to Prometheus.</p>"},{"location":"concepts/caliper-monitors/#basic-auth_1","title":"Basic Auth","text":"<p>It is possible to use a Prometheus Push Gateway that is secured via basic authentication through provision of a username and password as runtime parameters, under the flags:</p> <ul> <li>caliper-auth-prometheuspush-username</li> <li>caliper-auth-prometheuspush-password</li> </ul> <p>These will be used to augment the configuration file based URL prior to making a connection.</p>"},{"location":"concepts/caliper-monitors/#grafana-visualization","title":"Grafana Visualization","text":"<p>Grafana is an analytics platform that may be used to query and visualize metrics collected by Prometheus. Caliper clients make the following metrics available, either via a direct scrape or indirectly via a Prometheus Push Gateway:</p> <ul> <li>caliper_tx_submitted (counter)</li> <li>caliper_tx_finished (counter)</li> <li>caliper_tx_e2e_latency (histogram)</li> </ul> <p>Each of the above are tagged with the following default labels:</p> <ul> <li>roundLabel: the current test round label</li> <li>roundIndex: the current test round index</li> <li>workerIndex: the zero based worker index that is sending the information</li> </ul> <p>We are currently working on a Grafana dashboard to give you immediate access to the metrics published above, but in the interim please feel free to create custom queries to view the above metrics that are accessible in real time.</p>"},{"location":"concepts/caliper-monitors/#resource-charting","title":"Resource Charting","text":"<p>The data from each monitor is capable of being output in chart form within the generated Caliper report, via an option within the benchmark configuration file for each monitor. In addition to tabulated data for resource monitors, Caliper currently supports rendering of the following charts using <code>charting.js</code>:</p> <ul> <li>horizontal bar</li> <li>polar area</li> </ul> <p>Charting is an option that is available for each resource monitor, and the specification of the charting to be produced is specified under each monitor type within the benchmark configuration file, under a charting block. It is possible to specify multiple charting options for a single resource monitor.</p> <p>A chart will contain data for all items that are being tracked by the monitor; it is only possible to filter on the metrics that are to be charted. The following declares the <code>charting</code> block that is valid for the listed monitors:</p> <pre><code>charting:\n  bar:\n  - metrics: [all | &lt;sting list&gt;]\n  polar:\n  - metrics: [all | &lt;sting list&gt;]\n</code></pre> <p>If the <code>all</code> option is specified, then a chart will be output for each metric and include all monitored items within each chart. It is possible to filter on metrics by providing a comma separated list. The provided list is matched against metrics using a string comparison, and so it is only required to provide the initial part of the required match. The following declares a charting block that specifies a bar chart for all available metrics, and a polar chart for only metric0 and metric1:</p> <pre><code>charting:\n  bar:\n  - metrics: [all]\n  polar:\n  - metrics: [metric0, metric1]\n</code></pre>"},{"location":"concepts/caliper-monitors/#process-charting","title":"Process Charting","text":"<p>he process resource monitor exposes the following metrics: Memory(max), Memory(avg), CPU%(max), CPU%(avg).</p> <p>The following declares the monitoring of any running processes named caliper.js, with charting options specified to produce bar charts for all available metrics. Charts will be produced containing data from all monitored processes:</p> <pre><code>monitors:\n  resource:\n  - module: process\n    options:\n      interval: 3\n      processes: [{ command: 'node', arguments: 'caliper.js', multiOutput: 'avg' }]\n      charting:\n        bar:\n          metrics: [all]\n</code></pre>"},{"location":"concepts/caliper-monitors/#docker-charting","title":"Docker Charting","text":"<p>The docker resource monitor exposes the following metrics: Memory(max), Memory(avg), CPU%(max), CPU%(avg), Traffic In, Traffic Out, Disc Read, Disc Write.</p> <p>The following declares the monitoring of all local docker containers, with charting options specified to produce bar charts for <code>Memory(avg)</code> and <code>CPU%(avg)</code>, and polar charts for all metrics. Charts will be produced containing data from all monitored containers:</p> <pre><code>monitors:\n  resource:\n  - module: docker\n    options:\n      interval: 5\n      containers:\n      - all\n      charting:\n        bar:\n          metrics: [Memory(avg), CPU%(avg)]\n        polar:\n          metrics: [all]\n</code></pre>"},{"location":"concepts/caliper-monitors/#prometheus-charting","title":"Prometheus Charting","text":"<p>The Prometheus monitor enables user definition of all metrics within the configuration file.</p> <p>The following declares the monitoring of two user defined metrics <code>Endorse Time(s)</code> and <code>Max Memory(MB)</code>. Charting options are specified to produce polar charts filtered on the metric <code>Max Memory (MB)</code>, and bar charts of all user defined metrics.</p> <pre><code>monitors:\n    resource:\n    - module: prometheus\n      options:\n        url: \"http://localhost:9090\"\n        metrics:\n            include: [dev.*, couch, peer, orderer]\n            queries:\n                - name: Endorse Time (s)\n                  query: rate(endorser_propsal_duration_sum{chaincode=\"marbles:v0\"}[1m])/rate(endorser_propsal_duration_count{chaincode=\"marbles:v0\"}[1m])\n                  step: 1\n                  label: instance\n                  statistic: avg\n                - name: Max Memory (MB)\n                  query: sum(container_memory_rss{name=~\".+\"}) by (name)\n                  step: 10\n                  label: name\n                  statistic: max\n                  multiplier: 0.000001\n        charting:\n          polar:\n            metrics: [Max Memory (MB)]\n          bar:\n            metrics: [all]\n</code></pre>"},{"location":"concepts/caliper-monitors/#license","title":"License","text":"<p>The Caliper codebase is released under the Apache 2.0 license. Any documentation developed by the Caliper Project is licensed under the Creative Commons Attribution 4.0 International License. You may obtain a copy of the license, titled CC-BY-4.0, at http://creativecommons.org/licenses/by/4.0/.</p>"},{"location":"concepts/declarative-workload-module/","title":"Declarative Workloads","text":""},{"location":"concepts/declarative-workload-module/#overview","title":"Overview","text":"<p><code>DeclarativeWorkloadModuleBase</code> is a base class that can be implemented for declaratively assigning workload parameters. The Contracts, Functions and Parameters for test runs are specified under <code>arguments.behavior</code>.</p>"},{"location":"concepts/declarative-workload-module/#example","title":"Example","text":"<pre><code>workload:\n  module: declarative\n  arguments:\n    parameterOne: param1\n    parameterTwo: 42\n    behavior:\n      contracts:\n      - name: contract1\n        functions:\n        - name: function1\n          parameters:\n          - name: randomNumber\n            type: uniform_random\n            options:\n              min: 10\n              max: 100\n</code></pre> <p>The example above means the follows:</p> <ul> <li>The WorkloadModule used here is <code>declarative</code>.</li> <li>The <code>roundArguments</code> taken in by Caliper are <code>parameterOne</code>, assigned the value of <code>'param1'</code> and <code>parameterTwo</code> assigned the value of <code>42</code>.</li> <li>The <code>arguments.behavior</code> section specifies the declared properties of the workload module.</li> <li>A <code>contracts</code> list is defined.</li> <li><code>contracts</code> contains name, followed by <code>functions</code> which has <code>function1</code> present in it as the only list item.</li> <li><code>functions</code> contains <code>name</code> and <code>parameters</code>.</li> <li><code>parameters</code> contains a value provider with the <code>name</code> randomNumber of <code>type</code> uniform_random. This generates a random number between 10 and 100 for the parameter. </li> </ul>"},{"location":"concepts/declarative-workload-module/#hierarchy","title":"Hierarchy","text":"<p>Under <code>arguments.behavior</code>, <code>contracts</code> is the top layer. It consists of a list of contracts to be tested. Within a single <code>contracts</code> list element, <code>functions</code> property holds the list of all functions present under that contract. Similarly, under each <code>functions</code> list item, there is a <code>parameters</code> list which has different types of user defined parameters under it.</p>"},{"location":"concepts/declarative-workload-module/#contracts","title":"Contracts","text":"<p>Used to specify the list of contracts to be tested. Each <code>contracts</code> list element has the following format.</p> Property Type Description name string Name of the SUT contract to be tested. functionSelection string Type of contract picking logic. function list List of function descriptions."},{"location":"concepts/declarative-workload-module/#functions","title":"Functions","text":"<p>Used to specify the list of functions under a contract to be tested. Each <code>functions</code> list element has the following format.</p> Property Type Description name string Name of the SUT function to be tested. parameters list List of parameter descriptions for the function."},{"location":"concepts/declarative-workload-module/#parameters","title":"Parameters","text":"<p>Used to specify different generated parameters for each function.</p> Property Type Description type string Assigned a value according to the type of parameter used. name string Parameter Name. options string Additional information about the parameter definition. <p>The <code>parameters</code> list can contain one or more of the following items.</p>"},{"location":"concepts/declarative-workload-module/#uniform-random","title":"Uniform Random","text":"<p>Value provider format for generating a random number within a given range.</p>"},{"location":"concepts/declarative-workload-module/#example_1","title":"Example","text":"<pre><code>- name: randomNumber\n  type: uniform_random\n  options:\n    min: 0\n    max: 100\n</code></pre>"},{"location":"concepts/declarative-workload-module/#attributes","title":"Attributes","text":"Property Type Description options.min number Minimum inclusive range for generated random number. options.max number Maximum inclusive range for generated random number."},{"location":"concepts/declarative-workload-module/#parameters-reference","title":"Parameters Reference","text":"<p>Value Provider format for referencing a <code>module.arguments</code> item.</p>"},{"location":"concepts/declarative-workload-module/#example_2","title":"Example","text":"<pre><code>- name: referenceNumber\n  type: parameter_reference\n  options:\n    name: marbleNumber #assuming this is defined under round.arguments\n</code></pre>"},{"location":"concepts/declarative-workload-module/#attributes_1","title":"Attributes","text":"Property Type Description options.name string Should be a variable name specified under module.arguments."},{"location":"concepts/declarative-workload-module/#variable-reference","title":"Variable Reference","text":"<p>Value Provider format for referencing a Caliper workload variable.</p>"},{"location":"concepts/declarative-workload-module/#example_3","title":"Example","text":"<pre><code>- name: referenceNumber\n  type: variable_reference\n  options:\n    name: txIndex #a Caliper workload parameter\n</code></pre>"},{"location":"concepts/declarative-workload-module/#attributes_2","title":"Attributes","text":"Property Type Description options.name string Should refer to a base-class provided variable."},{"location":"concepts/declarative-workload-module/#list-element","title":"List Element","text":"<p>Value provider format for selecting an item from a given list.</p>"},{"location":"concepts/declarative-workload-module/#example_4","title":"Example","text":"<pre><code>- name: selectedColor\n  type: list_element\n  options:\n    list: ['red', 'blue', 'green']\n    selector:\n      type: variable_reference\n      options:\n        name: txIndex #assuming this is defined under module.arguments\n</code></pre>"},{"location":"concepts/declarative-workload-module/#attributes_3","title":"Attributes","text":"Property Type Description options.list list List from which an element is chosen. options.selector object Contains information about any valid numeric value provider for selecting elements by index."},{"location":"concepts/declarative-workload-module/#formatted-string","title":"Formatted String","text":"<p>Value provider format for generating formatted strings.</p>"},{"location":"concepts/declarative-workload-module/#example_5","title":"Example","text":"<pre><code>- name: generatedString\n  type: formatted_string\n  options:\n    format: 'example_{1}_{2}'\n    parts:\n      - type: parameter_reference\n        options:\n          name: marbleIndex\n      - type: variable_reference\n        options:\n          name: txIndex\n</code></pre>"},{"location":"concepts/declarative-workload-module/#attributes_4","title":"Attributes","text":"Property Type Description options.format string Specifies format and placeholders for variables. Placeholders are specified using this syntax: {variable_no}. 1-based indexing of the parts list is used for this purpose. options.parts list Specifies variable and parameter reference value providers for use in the string."},{"location":"concepts/declarative-workload-module/#implementing-the-declarativeworkloadmodulebase-class","title":"Implementing the DeclarativeWorkloadModuleBase class","text":""},{"location":"concepts/declarative-workload-module/#submitwitharguments","title":"submitWithArguments","text":"<p>The <code>DeclarativeWorkloadModuleBase</code> is exported as a module. In order to use it, <code>submitWithArguments()</code> needs to be implemented by the user. It accepts <code>generatedArguments</code> during a Caliper run.</p>"},{"location":"concepts/logging-control/","title":"Logging Control","text":""},{"location":"concepts/logging-control/#overview","title":"Overview","text":"<p>Caliper builds on the winston logger module to provide a flexible, multi-target logging mechanism. There are three different aspects when it comes to interacting with the Caliper logging subsystem:</p> <ol> <li>Customizing the logging style</li> <li>Configuring logging targets</li> <li>Creating your own loggers</li> </ol> <p>The first two points can be achieved through the runtime configuration mechanism of Caliper. So make sure that you are familiar with the different way of overriding runtime settings before reading on. The examples below only set the different options through the command line. Naturally, any other setting source could be used.</p> <p>The runtime configuration settings corresponding to logging reside under the <code>caliper-logging</code> key hierarchy. See the <code>caliper.logging</code> section of the default configuration file bundled with Caliper for the general structure of the settings.</p>"},{"location":"concepts/logging-control/#customizing-the-logging-style","title":"Customizing the logging style","text":"<p>The two main aspects of the logging style are the message structure and the different formats that modify the message appearance if applied. The corresponding attributes are the <code>caliper.logging.template</code> property and the entire <code>caliper.logging.formats</code> property hierarchy, respectively.</p> <p>The <code>caliper.logging.formats</code> hierarchy is special in a sense that every leaf property can be overridden one-by-one, even from the command line or from environment variables. As you will see later, this is not the case for the logging target settings.</p> <p>Note</p> <p>the following style settings apply to every specified logging target!</p>"},{"location":"concepts/logging-control/#setting-the-message-structure","title":"Setting the message structure","text":"<p>The message structure can be easily customized through the <code>caliper.logging.template</code> property. It is a simple string that contains predefined placeholders for some special values. Some placeholders are only available, when a corresponding format is also applied.</p> <p>Let\u2019s start with examining the default structure:</p> <pre><code>caliper:\n  logging:\n    template: '%timestamp% %level% [%label%] [%module%] %message% (%metadata%)'\n</code></pre> <p>The following placeholders are available at the moment.</p> Placeholder Required format Description <code>%timestamp%</code> timestamp Will be replaced with the timestamp of the log message. <code>%level%</code> - Will be replaced with the severity level (e.g., info, warn, error) of the log message. <code>%label%</code> label Will be replaced with the configured label of the process. <code>%module%</code> - Will be replaced with the module name that logged the message. <code>%message%</code> - Will be replaced with the actual message. <code>%metadata%</code> - Will be replaced with the string representation of additional logging arguments. <p>You can override this template by changing the caliper-logging-template setting key, for example, from the command line: <code>--caliper-logging-template=\"%time%: %message%\"</code></p> Note: <ol> <li>     Do not forget the two enclosing quotes, since the template can contain spaces!     </li> <li>     This template if applied after every format has been applied!     </li> <li>     Adding spaces and different brackets this way is fine for simple coloring scenarios (or when coloring is disabled). However, when coloring the entire log message (or just parts that should be surrounded with additional characters), the result looks inconsistent when formatted this way. See the Tips &amp; Tricks section for advanced message formatting scenarios.     </li> </ol>"},{"location":"concepts/logging-control/#applying-formats","title":"Applying formats","text":"<p>The logging subsystem relies on winston\u2019s format mechanism to further modify the log messages. The corresponding settings are under the <code>caliper.logging.formats</code> property.</p> <p>Each of these formats can be easily disabled by setting its property to <code>false</code>. For example, to disable the <code>colorize</code> format, set its corresponding <code>caliper.logging.formats.colorize</code> property to false, for example, from the command line: <code>--caliper-logging-formats-colorize=false</code></p> <p>Similarly, any sub-property of a format can be easily overridden. For example, changing the <code>caliper.logging.formats.colorize.colors.info</code> property from the command line: <code>--caliper-logging-formats-colorize-colors-info=blue</code></p> <p>The following formats and their options (sub-properties) are supported.</p> <p>Note</p> <p>the different formats are applied in the order they are presented, which is important (see the Tips &amp; Tricks section for the reason).</p>"},{"location":"concepts/logging-control/#timestamp","title":"Timestamp","text":"<p>Adds the timestamp to the message in the specified format. The format string must conform to the rules of the fecha package.</p> <p>For example: <code>--caliper-logging-formats-timestamp=\"YYYY.MM.DD-HH:mm:ss.SSS\"</code></p> <p>Note</p> <p>the format makes the <code>timestamp</code> attribute available in the message, thus it can be referenced in the message template, or in other formats that can access message attributes.</p>"},{"location":"concepts/logging-control/#label","title":"Label","text":"<p>Adds a custom label to the message. This is useful for differentiating multiple Caliper instances (or the distributed client instances) after collecting their logs.</p> <p>For example: <code>--caliper-logging-formats-label=\"caliper-test-1\"</code></p> <p>Note</p> <p>the format makes the <code>label</code> attribute available in the message, thus it can be referenced in the message template, or in other formats that can access message attributes.</p>"},{"location":"concepts/logging-control/#json","title":"JSON","text":"<p>Outputs the messages as JSON strings. Useful for file-based logs that will be processed automatically by another tool. The format accepts a <code>space</code> sub-property as an options, which corresponds to the <code>space</code> parameter of the JSON.stringify function.</p> <p>For example: <code>--caliper-logging-formats-json=\"{space:0}\"</code></p> Note: <ol> <li>     Enabling this format is easier from a configuration file. See the Tips &amp; Tricks section.     </li> <li>     Setting <code>space</code> to a non-zero number will effectively format the JSON output with indentations on multiple lines. This could \u201cspam\u201d the console a bit (not a problem for log files, unless you care about the extra newlines).     </li> <li>     If this format is enabled, the rest of the formats won\u2019t be applied, since their purpose is mainly to make console logs more readable.     </li> </ol>"},{"location":"concepts/logging-control/#padding","title":"Padding","text":"<p>Makes every log level string the same length, i.e., adds an extra space after <code>\"info\"</code> and <code>\"warn\"</code> make them the same length as <code>\"error\"</code> and <code>\"debug\"</code>.</p> <p>For example: <code>--caliper-logging-formats-pad=true</code></p>"},{"location":"concepts/logging-control/#align","title":"Align","text":"<p>Prepends the message part of the log with a tabulator (<code>\"\\t\"</code>) to align the messages of different logs in the same place.</p> <p>For example: <code>--caliper-logging-formats-align=true</code></p> <p>Note</p> <p>if the message format contains other information with variable lengths (e.g., the module name), it can cause misaligned messages. So this is just a \u201cbest effort\u201d format to make console messages more readable.</p>"},{"location":"concepts/logging-control/#attribute-format","title":"Attribute format","text":"<p>Defines string formatting options for the different attributes of a message. A \u201cformat string\u201d can be provided for each message attribute that will \u201creformat\u201d its value. The format string can use the <code>%attribute%</code> placeholder to reference the original value.</p> <p>A format string can be specified for the following message attributes:</p> <ul> <li>timestamp</li> <li>level</li> <li>label</li> <li>module</li> <li>message</li> <li>metadata</li> </ul> <p>For example, to customize the level information of the log (enclose it in the <code>LEVEL[&lt;level&gt;]</code> string):</p> <p><code>--caliper-logging-formats-attributeformat-level=\"LEVEL[%attribute%]\"</code></p> <p>Note</p> <p>if the attribute is not a string (which can be the case for the \u201cmetadata\u201d attribute), then first the attribute value is converted to string, using <code>JSON.stringify</code>, and then it\u2019s inserted into the format string.</p>"},{"location":"concepts/logging-control/#colorize","title":"Colorize","text":"<p>Applies color coding for the different attributes of a message. Enabling/disabling coloring is specified on an attribute basis. The following sub-properties can be set to <code>true/false</code> to enable/disable coloring for the corresponding attribute:</p> <ul> <li>timestamp</li> <li>level</li> <li>label</li> <li>module</li> <li>message</li> <li>metadata</li> <li>all: setting it to true enables coloring for every attribute</li> </ul> <p>For example, to colorize every part of the message: <code>--caliper-logging-formats-colorize-all=true</code></p> <p>Additionally, the format exposes a <code>colors</code> attribute, which contains coloring information for the <code>info</code>, <code>error</code>, <code>warn</code> and <code>debug</code> levels. The value of a level can be set to colors and styles provided by the colors package. To apply multiple styles, separate the values with a space.</p> <p>For example, to really highlight error-level logs: <code>--caliper-logging-formats-colorize-colors-error=\"white bgRed bold italic\"</code></p> <p>Note</p> <p>the <code>colors</code> package offers some exotic styles which seem tempting at first, but don\u2019t overdo it, for the sake of your eyes. Keep it simple.</p>"},{"location":"concepts/logging-control/#configuring-logging-targets","title":"Configuring logging targets","text":"<p>The source and target(s) of log messages are decoupled, thanks to the transport mechanism of winston. This means that a log message can be easily logged to multiple places, like the console, or different log files. Moreover, this is completely transparent to the module generating the log message!</p> <p>The different targets are specified under the <code>caliper.logging.targets</code> property. The <code>caliper.logging.targets</code> section takes the following general form:</p> <pre><code>caliper:\n  logging:\n    targets:\n      mylogger1:\n        target: console\n        enabled: true\n        options:\n          # console target-specific options\n      mylogger2:\n        target: file\n        enabled: true\n        options:\n          # file target-specific options\n</code></pre> <p>Each subproperty of <code>caliper.logging.targets</code> is an arbitrary name for the given logging target (e.g., <code>mylogger1</code>, <code>mylogger2</code>, etc.).</p> <p>Each target must specify the following properties:</p> <ul> <li><code>target</code>: the identifier of a supported target. See the table below.</li> <li><code>enabled</code>: indicates whether the target is enabled. Defaults to <code>true</code> if omitted.</li> <li><code>options</code>: this object will be given as-is to the specific winston transport as options. See the table below for the supported options of each transport.</li> </ul> <p>The following <code>target</code> values (i.e., transports) are supported. Click on the links for the official documentation of each transport.</p> Target Available options console Console Transport file File Transport daily-rotate-file Daily Rotating File Transport"},{"location":"concepts/logging-control/#disabling-loggers","title":"Disabling loggers","text":"<p>Even though the setting keys/properties of the <code>caliper.logging.targets</code> section cannot be overridden one-by-one (like the properties in the <code>caliper.logging.formats</code> section), the <code>enabled</code> property is an exception. To easily disable a logger, set its <code>enabled</code> property to <code>false</code> (using the target\u2019s name in the property hierarchy).</p> <p>For example, to disable the <code>mylogger1</code> target, the following approaches are available:</p> <ul> <li>From the command line: <code>--caliper-logging-targets-mylogger1-enabled=false</code></li> <li>From an environment variable: <code>export CALIPER_LOGGING_TARGETS_MYLOGGER1_ENABLED=false</code></li> </ul> <p>Note</p> <p>you must use lower-case letters (and/or digits) in your target name for this to work!</p>"},{"location":"concepts/logging-control/#overriding-logger-target-settings","title":"Overriding logger target settings","text":"<p>But what if you would like to modify one of the options of a transport? You can use a configuration file for that!</p> <p>For the next example, we will disable the default file logger, modify the logging level of the console target, and also add a new daily rotating file logger. We can do all of this with a single configuration file.</p> <pre><code>caliper:\n  logging:\n    targets:\n      console:\n        options:\n          # we don't care about info level messages anymore\n          level: warn\n      file:\n        # we disable this\n        enabled: false\n      rotatingfile:\n        target: daily-rotate-file\n        # enabled by default\n        options:\n          # we log every message this way\n          level: debug\n          # start a new log file every hour\n          datePattern: 'YYYY-MM-DD-HH'\n          # compress old log files after rotating\n          zippedArchive: true\n          # include the hour-precision date in the file names\n          filename: 'caliper-%DATE%.log'\n          # options for opening the file for writing\n          options:\n            # append mode\n            flags: a\n            # make the file readable/writable by anyone\n            mode: 0666\n</code></pre> <p>If you save the above content as <code>caliper.yaml</code> in your workspace directory, then Caliper will pick it up automatically.</p> <p>Note</p> <p>Some remarks about the above file content:</p> <ol> <li>We only set the properties we wanted to override. The default configuration file will be merged with the above configuration file, the values in the latter taking precedence.</li> <li>The provided options for a transport are not verified by Caliper. It is simple passed to the specific transport. It is your responsibility to configure the transport the right way.</li> <li>We could have disabled the file logger also from the command line, or from an environment variable. The reason we did it from a config file is explained in the Tips &amp; tricks section.</li> </ol>"},{"location":"concepts/logging-control/#creating-your-own-loggers","title":"Creating your own loggers","text":"<p>The different modules of Caliper will automatically use the configured targets for logging. Moreover, your user test modules can also create logger instances to log runtime events related to your business logic.</p> <p>To create your own logger instance, use the following API:</p> <pre><code>const logger = require('@hyperledger/caliper-core').CaliperUtils.getLogger('my-module');\n\n// ...\n\nlogger.debug('My custom debug message', metadataObject1, metadataObject2);\n</code></pre> <p>Once a logger instance is created, it exposes the usual <code>info</code>, <code>warn</code>, <code>debug</code> and <code>error</code> functions that each take as parameter a log message and optional objects, considered as \u201cmetadata\u201d.</p> <p>This \u201cmetadata\u201d is especially useful for debug level logs. When you perform an operation based on a complex input parameter/object, you can log the following at the beginning of your function:</p> <pre><code>function complexCalculation(complexInput) {\n    logger.debug('Starting complex calculation. Input: ', complexInput);\n    // complex calculation\n}\n</code></pre> <p>The \u201cmetadata\u201d will appear at the place of the <code>%metadata%</code> placeholder, as discussed in the message template section.</p> <p>Note</p> <p>pPassing large metadata objects can hurt the performance of logging if done in a loop/hot path. Only use \u201cmetadata\u201d logging for debug messages, since the debug level is usually switched off in production code.</p>"},{"location":"concepts/logging-control/#tips-tricks","title":"Tips &amp; tricks","text":""},{"location":"concepts/logging-control/#the-format-pipeline","title":"The format pipeline","text":"<p>Winston formats are a powerful feature that allow the arbitrary manipulation of log messages. From the user\u2019s perspective, a log message is a simple string displayed on the console, or saved in a file. However, to fully utilize the logging styles described in this documentation, it might help knowing what really happens under the hood.</p> <p>Note</p> <p>in the remainder of this section, we\u2019ll refer to log messages as LOG.</p> <p>LOG can be considered an item/object, that is generated when issuing a call to <code>logger.info(...)</code> or similar functions. A LOG can have several attributes attached to it. Every LOG has the <code>level</code> and <code>message</code> attributes, containing the severity and the \u201cdescription\u201d of LOG. Additionally, Caliper automatically adds the <code>module</code> attribute to LOGs of every logger created through the Caliper API, denoting the name of the module who issued the log.</p> <p>Let\u2019s introduce the format pipeline through an example.</p>"},{"location":"concepts/logging-control/#assumptions","title":"Assumptions","text":"<p>Let\u2019s assume that the following <code>caliper.logging</code> configuration is used:</p> <p><pre><code>template: '%timestamp%%level%%label%%module%%message%%metadata%'\nformats:\n    timestamp: 'YYYY.MM.DD-HH:mm:ss.SSS'\n    label: caliper\n    json: false\n    pad: true\n    align: false\n    attributeformat:\n        level: ' %attribute%'\n        label: ' [%attribute%]'\n        module: ' [%attribute%] '\n        metadata: ' (%attribute%)'\n    colorize:\n        all: true\n        colors:\n            info: green\n            error: red\n            warn: yellow\n            debug: grey\n</code></pre> This means that the following formats will be applied to every LOG:</p> <ul> <li>module (automatically added by Caliper)</li> <li>timestamp</li> <li>label</li> <li>padding</li> <li>attribute formats</li> <li>colorizing</li> <li>template substitution</li> </ul> <p>Furthermore, let\u2019s assume that the following code initiates the LOG:</p> <pre><code>const logger = require('@hyperledger/caliper-core').CaliperUtils.getLogger('my-module');\n\n// ...\n\nlogger.info('Doing operation X with:', 'someSetting', 'anotherSetting');\n</code></pre>"},{"location":"concepts/logging-control/#the-life-of-a-log","title":"The life of a LOG","text":"<p>The <code>logger.info</code> call generates the initial LOG with the following attributes:</p> <pre><code>level: 'info'\nmessage: 'Doing operation X with:'\n</code></pre> <p>Before LOG enters the format pipeline, Caliper also adds the module name, and collects the additional parameters as metadata. Now LOG has the following attributes:</p> <pre><code>level: 'info'\nmessage: 'Doing operation X with:'\nmodule: 'my-module'\nmetadata: ['someSetting', 'anotherSetting']\n</code></pre> <p>This is the initial LOG entity that enters the format pipeline. Every enabled format is \u201cjust\u201d a transformation on the attributes of LOG. A format can manipulate the value of an existing attribute or/and add/remove arbitrary attributes.</p> <p>The first step of the pipeline is the timestamp format. This adds the <code>timestamp</code> attribute containing the current time, in the specified format. After this step, LOG looks like this:</p> <pre><code>level: 'info'\nmessage: 'Doing operation X with:'\nmodule: 'my-module'\nmetadata: ['someSetting', 'anotherSetting']\ntimestamp: '2019.10.07-12:45:47.962'\n</code></pre> <p>The next step if the label format, which adds the <code>label</code> attribute with the specified value (<code>caliper</code>, in this case):</p> <pre><code>level: 'info'\nmessage: 'Doing operation X with:'\nmodule: 'my-module'\nmetadata: ['someSetting', 'anotherSetting']\ntimestamp: '2019.10.07-12:45:47.962'\nlabel: 'caliper'\n</code></pre> <p>The next step is the padding format, which ensure that every logging level string has the same length. This means, that an extra space is appended at the end of the <code>level</code> attribute:</p> <pre><code>level: 'info '\nmessage: 'Doing operation X with:'\nmodule: 'my-module'\nmetadata: ['someSetting', 'anotherSetting']\ntimestamp: '2019.10.07-12:45:47.962'\nlabel: 'caliper'\n</code></pre> <p>The next step is the attribute formatter. This formatter is configured to modify multiple attributes of LOG, based on a string template:</p> <ul> <li>level: add a space before it</li> <li>label: enclose in <code>[]</code> and add a space before it</li> <li>module: enclose in <code>[]</code> and add a space before and after it</li> <li>metadata: enclose in <code>()</code> and add a space before it</li> </ul> <p>After these transformation, LOG looks like the following:</p> <pre><code>level: ' info '\nmessage: 'Doing operation X with:'\nmodule: ' [my-module] '\nmetadata: ' ([\"someSetting\", \"anotherSetting\"])'\ntimestamp: '2019.10.07-12:45:47.962'\nlabel: ' [caliper]'\n</code></pre> <p>Note</p> <p>some remarks: 1. <code>metadata</code> was an Array, not a string, so it was stringified before the formatting was applied. 2. <code>message</code> and <code>timestamp</code> is unchanged.</p> <p>The next step is the colorizing format, which adds certain color/style codes to the configured values. Since <code>all</code> is set true, and the <code>level</code> of LOG is info, every attribute is surrounded with the color code for green (denoted by <code>&lt;green&gt;</code> for sake of  readability):</p> <pre><code>level: '&lt;green&gt; info &lt;green&gt;'\nmessage: '&lt;green&gt;Doing operation X with:&lt;green&gt;'\nmodule: '&lt;green&gt; [my-module] &lt;green&gt;'\nmetadata: '&lt;green&gt; ([\"someSetting\", \"anotherSetting\"])&lt;green&gt;'\ntimestamp: '&lt;green&gt;2019.10.07-12:45:47.962&lt;green&gt;'\nlabel: '&lt;green&gt; [caliper]&lt;green&gt;'\n</code></pre> <p>The last step in the pipeline (since the JSON format is disabled) is substituting the attributes into the logging template, to create the final message, that will appear in the console and in the file. The result is the concatenation of LOG\u2019s attributes in the following order:</p> <ol> <li>timestamp</li> <li>level</li> <li>label</li> <li>module</li> <li>message</li> <li>metadata</li> </ol> <p>Omitting the color code for the sake of readability, this results in:</p> <pre><code>2019.10.07-12:45:47.962 info  [caliper] [my-module] Doing operation X with: ([\"someSetting\", \"anotherSetting\"])\n</code></pre> <p>Note</p> <p>try adding other characters to the template string. And then be surprised that they are not colorized with the rest of the line. Actually, this is not surprising at all. The template string is \u201cevaluated\u201d after the colorizing format. Since these extra characters are not part of any attributes of LOG, they won\u2019t be colorized.</p>"},{"location":"concepts/logging-control/#use-a-configuration-file","title":"Use a configuration file","text":"<p>Logging settings are usually determined by your log analysis requirements. This means that once you settle on some logging style and targets, those settings will rarely change.</p> <p>To this end, the ability to override the logging style settings from the command line or from environment variables is really just a convenience feature. Once you found your ideal settings, it\u2019s worth to record them in a configuration file.</p> <p>The easiest way to do that is with a project-level configuration file. If you name the following file <code>caliper.yaml</code> and place it in your workspace root, then Caliper will automatically apply the settings.</p> <p>Note</p> <p>there are other ways to load a configuration file, as discussed in the runtime configuration page.</p> <pre><code>caliper:\n  logging:\n    # no need for timestamp and label\n    template: '%level% [%module%]: %message% %meta%'\n    formats:\n      # color codes look ugly in log files\n      colorize: false\n      # don't need these, since won't appear in the template\n      label: false\n      timestamp: false\n    targets:\n      file:\n        options:\n          # bump the log level from debug to warn, only log the critical stuff in this file\n          level: warn\n          filename: 'critical.log'\n      rotatingfile:\n        target: daily-rotate-file\n        enabled: true\n        options:\n          level: debug\n          datePattern: 'YYYY-MM-DD-HH'\n          zippedArchive: true\n          filename: 'debug-%DATE%.log'\n          options:\n            flags: a\n            mode: 0666\n</code></pre>"},{"location":"concepts/logging-control/#license","title":"License","text":"<p>The Caliper codebase is released under the Apache 2.0 license. Any documentation developed by the Caliper Project is licensed under the Creative Commons Attribution 4.0 International License. You may obtain a copy of the license, titled CC-BY-4.0, at http://creativecommons.org/licenses/by/4.0/.</p>"},{"location":"concepts/rate-controllers/","title":"Rate Controllers","text":"<p>The rate at which transactions are input to the blockchain system is a key factor within performance tests. It may be desired to send transactions at a specified rate or follow a specified profile. Caliper permits the specification of custom rate controllers to enable a user to perform testing under a custom loading mechanism. A user may specify their own rate controller or use one of the default options:</p> <ul> <li>Fixed rate</li> <li>Fixed feedback rate</li> <li>Fixed load</li> <li>Maximum rate</li> <li>Linear rate</li> <li>Composite rate</li> <li>Zero rate</li> <li>Record rate</li> <li>Replay rate</li> </ul> <p>For implementing your own rate controller, refer to the Adding Custom Controllers section.</p>"},{"location":"concepts/rate-controllers/#fixed-rate","title":"Fixed rate","text":"<p>The fixed rate controller is the most basic controller, and also the default option if no controller is specified. It will send input transactions at a fixed interval that is specified as TPS (transactions per second).</p>"},{"location":"concepts/rate-controllers/#options-and-use","title":"Options and use","text":"<p>The fixed-rate controller can be specified by setting the rate controller <code>type</code> to the <code>fixed-rate</code> string.</p> <p>Controller options include:</p> <ul> <li><code>tps</code>: the rate at which transactions are cumulatively sent to the SUT by all workers</li> </ul> <p>The fixed rate controller, driving at 10 TPS, is specified through the following controller option:</p> <pre><code>{\n  \"type\": \"fixed-rate\",\n  \"opts\": {\n    \"tps\" : 10\n  }\n}\n</code></pre>"},{"location":"concepts/rate-controllers/#fixed-feedback-rate","title":"Fixed feedback rate","text":"<p>The fixed feedback rate controller which is the extension of fixed rate also will originally send input transactions at a fixed interval. When the unfinished transactions exceeds times of the defined unfinished transactions for each client,it will stop sending input transactions temporally by sleeping a long period of time.</p> <p>Controller options include:</p> <ul> <li><code>tps</code>: the rate at which transactions are cumulatively sent to the SUT by all workers</li> <li><code>transactionLoad</code>: the maximum transaction load on the SUT at which workers will pause sending further transactions</li> </ul> <p>The fixed feedback rate controller, driving at 100 TPS, 100 unfinished transactions for each client, is specified through the following controller option:</p> <pre><code>{\n  \"type\": \"fixed-feedback-rate\",\n  \"opts\": {\n      \"tps\" : 100,\n      \"transactionLoad\": 100\n  }\n}\n</code></pre>"},{"location":"concepts/rate-controllers/#fixed-load","title":"Fixed Load","text":"<p>The fixed load rate controller is a controller for driving the tests at a target loading (backlog transactions). This controller will aim to maintain a defined backlog of transactions within the system by modifying the driven TPS. The result is the maximum possible TPS for the system whilst maintaining the pending transaction load.</p>"},{"location":"concepts/rate-controllers/#options-and-use_1","title":"Options and use","text":"<p>The fixed-load controller can be specified by setting the rate controller <code>type</code> to the <code>fixed-load</code> string.</p> <p>Controller options include:</p> <ul> <li><code>startTps</code>: the initial rate at which transactions are cumulatively sent to the SUT by all workers</li> <li><code>transactionLoad</code>: the number of transactions being processed by the SUT that is to be maintained</li> </ul> <p>The fixed load controller, aiming to maintain a SUT transaction load of 5, with a starting TPS of 100, is specified through the following controller option:</p> <pre><code>{\n  \"type\": \"fixed-load\",\n  \"opts\": {\n    \"transactionLoad\": 5,\n    \"startTps\": 100\n  }\n}\n</code></pre>"},{"location":"concepts/rate-controllers/#maximum-rate","title":"Maximum rate","text":"<p>The maximum rate controller is a controller for driving the workers to their maximum achievable rate without overloading the SUT. This controller will aim to maximize the driven TPS for the worker by ramping up the driven TPS and backing off again when a drop in TPS is witnessed; such drops are indicative of an overloaded system.</p> <p>The achieved TPS is evaluated between txUpdate cycles, since this is the point at which TPS results are made available. A minimum sample interval that ensures settling of TPS rates should be considered for enhanced controller stability.</p> <p>Please note that the action of the controller is to slowly ramp to the maximum achievable rate for each worker until a threshold is reached, meaning that there will be a significant warm up phase that may skew averaged results for the round. It is recommended to investigate achievable results using Prometheus queries and/or Grafana visualization.</p>"},{"location":"concepts/rate-controllers/#options-and-use_2","title":"Options and use","text":"<p>The maximum rate controller can be specified by setting the rate controller <code>type</code> to the <code>maximum-rate</code> string.</p> <p>Controller options include:</p> <ul> <li><code>tps</code>: the starting TPS</li> <li><code>step</code>: the TPS increase for each interval. Note that on \u201cback-off\u201d this step size will automatically be reduced before re-attempting a TPS increase.</li> <li><code>sampleInterval</code>: the minimum time between steps to ensure settling of achieved TPS rates</li> <li><code>includeFailed</code>: boolean flag to indicate if the achieved TPS analysis within the controller is to include failed transactions (default true)</li> </ul> <p>The maximum rate controller, with a starting TPS of 100, a TPS step size of 5, and a minimum sample interval of 20seconds, is specified through the following controller option:</p> <pre><code>{\n  \"type\": \"maximum-rate\",\n  \"opts\": {\n    \"tps\": 100,\n    \"step\": 5,\n    \"sampleInterval\": 20,\n    \"includeFailed\": true\n  }\n}\n</code></pre>"},{"location":"concepts/rate-controllers/#linear-rate","title":"Linear rate","text":"<p>Exploring the performance limits of a system usually consists of performing multiple measurements with increasing load intensity. However, finding the tipping point of the system this way is not easy, it is more like a trial-and-error method.</p> <p>The linear rate controller can gradually (linearly) change the TPS rate between a starting and finishing TPS value (both in increasing and decreasing manner). This makes it easier to find the workload rates that affect the system performance in an interesting way.</p> <p>The linear rate controller can be used in both duration-based and transaction number-based rounds. </p>"},{"location":"concepts/rate-controllers/#options-and-use_3","title":"Options and use","text":"<p>The linear rate controller can be specified by setting the rate controller <code>type</code> to the <code>linear-rate</code> string.</p> <p>Controller options include:</p> <ul> <li><code>startingTps</code>: the rate at which transactions are cumulatively sent to the SUT by all workers at the start of the round</li> <li><code>finishingTps</code>: the rate at which transactions are cumulatively sent to the SUT by all workers at the end of the round</li> </ul> <p>The following example specifies a rate controller that gradually changes the transaction load from 25 TPS to 75 TPS during the benchmark round.</p> <pre><code>{\n  \"type\": \"linear-rate\",\n  \"opts\": {\n    \"startingTps\": 25,\n    \"finishingTps\": 75\n    }\n}\n</code></pre> <p>Note</p> <p>similarly to the fixed rate controller, this controller also divides the workload between the available client, so the specified rates in the configuration are cumulative rates, and not the rates of individual clients. Using the above configuration with 5 clients results in clients that start at 5 TPS and finish at 15 TPS. Together they generate a [25-75] TPS load.</p>"},{"location":"concepts/rate-controllers/#composite-rate","title":"Composite rate","text":"<p>A benchmark round in Caliper is associated with a single rate controller. However, a single rate controller is rarely sufficient to model advanced client behaviors. Moreover, implementing new rate controllers for such behaviors can be cumbersome and error-prone. Most of the time a complex client behavior can be split into several, simpler phases.</p> <p>Accordingly, the composite rate controller enables the configuration of multiple \u201csimpler\u201d rate controllers in a single round, promoting the reusability of existing rate controller implementations. The composite rate controller will automatically switch between the given controllers according to the specified weights (see the configuration details after the example).</p>"},{"location":"concepts/rate-controllers/#options-and-use_4","title":"Options and use","text":"<p>The composite rate controller can be specified by setting the rate controller <code>type</code> to the <code>composite-rate string</code>.</p> <p>Controller options include:</p> <ul> <li><code>weights</code>: an array of \u201cnumber-like\u201d values (explicit numbers or numbers as strings) specifying the weights associated with the rate controllers defined in the <code>rateControllers</code> property.</li> </ul> <p>The weights do not necessarily have to sum to <code>1</code>, since they will eventually be normalized to a vector of unit length. This means, that the weights can be specified in a manner that is the most intuitive for the given configuration. For example, the weights can correspond to durations, numbers of transactions or ratios.</p> <p>In the above example, the weights are corresponding to ratios (2:1:2). The exact meaning of the weights is determined by whether the benchmark round is duration-based or transaction number-based. If the above controller definition is used in a round with a duration of 5 minutes, then in the first 2 minutes the transactions will be submitted at 100 TPS, then at 300 TPS for the next minute, and at 200 TPS for the last 2 minutes of the round.</p> <p>Note, that 0 weights are also allowed in the array. Setting the weight of one or more controllers to 0 is a convenient way to \u201cremove/disable\u201d those controllers without actually removing them from the configuration file.</p> <ul> <li><code>rateControllers</code>: an array of arbitrary rate controller specifications. See the documentation of the individual rate controllers on how to configure them. The number of specified rate controllers must equal to the number of specified weights.</li> </ul> <p>Note, that technically, composite rate controllers can be nested to form a hierarchy. However, using a composite rate controller incurs an additional execution overhead in the rate control logic. Keep this in mind before specifying a deep hierarchy of composite rate controllers, or just flatten the hierarchy to a single level.</p> <ul> <li><code>logChange</code>: a <code>boolean</code> value indicating whether the switches between the specified rate controllers should be logged or not.</li> </ul> <p>For example, the definition of a square wave function (with varying amplitude) as the transaction submission rate is as easy as switching between fixed rate controllers with different TPS settings:</p> <pre><code>{\n  \"type\": \"composite-rate\",\n  \"opts\": {\n    \"weights\": [2, 1, 2],\n    \"rateControllers\": [\n      {\n        \"type\": \"fixed-rate\",\n        \"opts\": {\"tps\" : 100}\n      },\n      {\n        \"type\": \"fixed-rate\",\n        \"opts\": {\"tps\" : 300}\n      },\n      {\n        \"type\": \"fixed-rate\",\n        \"opts\": {\"tps\" : 200}\n      }\n    ],  \n    \"logChange\": true\n  }\n}\n</code></pre> <p>Important! The existence of the composite rate controller is almost transparent to the specified \u201csub-controllers.\u201d This is achieved by essentially placing the controllers in a \u201cvirtualized\u201d round, i.e., \u201clying\u201d to them about:</p> <ul> <li>the duration of the round (for duration-based rounds),</li> <li>the total number of transactions to submit (for transaction number-based rounds),</li> <li>the starting time of the round, and</li> <li>the index of the next transaction to submit.</li> </ul> <p>The results of recently finished transactions are propagated to the sub-controllers as-is, so for the first few call of a newly activated sub-controller it can receive recent results that don\u2019t belong to its virtualized round.</p> <p>This virtualization does not affect the memoryless controllers, i.e., the controllers whose control logic does not depend on global round properties or past transaction results. However, other controllers might exhibit some strange (but hopefully transient) behavior due to this \u201cvirtualized\u201d round approach. For example, the logic of the PID controller for example depends on the transaction backlog.</p>"},{"location":"concepts/rate-controllers/#zero-rate","title":"Zero rate","text":"<p>This controller stops the workload generation for the duration of the round. </p>"},{"location":"concepts/rate-controllers/#options-and-use_5","title":"Options and use","text":"<p>Using the controller on its own for a round is meaningless. However, it can be used as a building block inside a composite rate controller. The zero rate controller can be used only in duration-based rounds!</p> <pre><code>{\n  \"type\": \"composite-rate\",\n  \"opts\": {\n    \"weights\": [30, 10, 10, 30],\n    \"rateControllers\": [\n      {\n        \"type\": \"fixed-rate\",\n        \"opts\": {\"tps\" : 100}\n      },\n      {\n        \"type\": \"fixed-rate\",\n        \"opts\": {\"tps\" : 500}\n      },\n      {\n        \"type\": \"zero-rate\",\n        \"opts\": { }\n      },\n      {\n        \"type\": \"fixed-rate\",\n        \"opts\": {\"tps\" : 100}\n      }\n    ],  \n    \"logChange\": true\n  }\n}\n</code></pre> <p>Let\u2019s assume, that the above example is placed in a round definition with an 80 seconds duration (note the intuitive specification of the weights). In this case, an initial 30 seconds normal workload is followed by a 10 seconds intensive workload, which is followed by a 10 seconds cooldown period, etc.</p> <p>The controller is identified by the <code>zero-rate</code> string as the value of the <code>type</code> property and requires no additional configuration.</p>"},{"location":"concepts/rate-controllers/#record-rate","title":"Record rate","text":"<p>This rate controller serves as a decorator around an other (arbitrary) controller. Its purpose is to record the times (relative to the start of the round) when each transaction was submitted, i.e., when the transaction was \u201cenabled\u201d by the \u201csub-controller.\u201d</p> <p>The following example records the times when the underlying fixed rate controller enabled the transactions (for details, see the available options below the example):</p> <pre><code>{\n  \"type\": \"record-rate\",\n  \"opts\": {\n    \"rateController\": {\n      \"type\": \"fixed-rate\",\n      \"opts\": {\"tps\" : 100}\n    },\n    \"pathTemplate\": \"../tx_records_client&lt;C&gt;_round&lt;R&gt;.txt\",\n    \"outputFormat\": \"TEXT\",\n    \"logEnd\": true\n  }\n}\n</code></pre> <p>The record rate controller can be specified by setting the rate controller <code>type</code> to the <code>record-rate</code> string. The available options (<code>opts</code> property) are the following:</p> <ul> <li><code>rateController</code>: the specification of an arbitrary rate controller.</li> <li><code>pathTemplate</code>: the template for the file path where the recorded times will be saved. The path can be either an absolute path or relative to the root Caliper directory.</li> </ul> <p>The template can (and should) contain special \u201cvariables/placeholders\u201d that can refer to special environment properties (see the remarks below). The available placeholders are the following:     - <code>&lt;C&gt;</code>: placeholder for the 1-based index of the current client that uses this rate controller.     - <code>&lt;R&gt;</code>: placeholder for the 1-based index of the current round that uses this rate controller.</p> <ul> <li><code>outputFormat</code>: optional. Determines the format in which the recording will be saved. Defaults to <code>\"TEXT\"</code>. The currently supported formats are the following:<ul> <li><code>\"TEXT\"</code>: each recorded timing is encoded as text on separate lines.</li> <li><code>\"BIN_BE\"</code>: binary format with Big Endian encoding.</li> <li><code>\"BIN_LE\"</code>: binary format with Little Endian encoding.</li> </ul> </li> <li><code>logEnd</code>: optional. Indicates whether to log that the recordings are written to the file(s). Defaults to <code>false</code>.</li> </ul> <p>Template placeholders: since Caliper provides a concise way to define multiple rounds and multiple workers with the same behavior, it is essential to differentiate between the recordings of the workers and rounds. Accordingly, the output file paths can contain placeholders for the round and worker indices that will be resolved automatically at each worker in each round. Otherwise, every worker would write the same file, resulting in a serious conflict between timings and transaction IDs.</p> <p>Text format: the rate controller saves the recordings in the following format (assuming a constant 10 TPS rate and ignoring the noise in the actual timings), row <code>i</code> corresponding to the <code>i</code>th transaction:  </p> <pre><code>100\n200\n300\n...\n</code></pre> <p>The value of <code>i</code> starts at 0, so the first line represents 0 transactions submitted. Each value in a line represents time in milliseconds from the start of the round. </p> <p>Binary format: Both binary representations encode the <code>X</code> number of recordings as a series of <code>X+1</code> UInt32 numbers (1 number for the array length, the rest for the array elements), either in Little Endian or Big Endian encoding:</p> <pre><code>Offset: |0      |4      |8      |12      |16      |...     \nData:   |length |1st    |2nd    |3rd     |4th     |...      \n</code></pre> <ul> <li>The first entry (length) indicates the number of transactions submitted.</li> <li>Each subsequent entry in the array represents a timestamp of when that number of transactions were submitted from the start of the round.</li> <li>The subsequent values (Uint32 values in Big Endian or Little Endian format) represent time in milliseconds from the start of the round. Each entry corresponds to the number of transactions submitted starting from 0</li> </ul> <p>For example, if there are 3 transactions enabled, the binary format would look like:</p> <pre><code>Offset: |0      |4      |8      |12     |16      \nData:   |length |0 tx   |1 tx   |2 tx   |3 tx \n        |4      |100    |200    |300    |400\n</code></pre>"},{"location":"concepts/rate-controllers/#replay-rate","title":"Replay rate","text":"<p>One of the most important aspect of a good benchmark is its repeatability, i.e., it can be re-executed in a deterministic way whenever necessary. However, some benchmarks define the workload (e.g., user behavior) as a function of probabilistic distribution(s). This presents two problems from a practical point of view:</p> <ol> <li>Repeatability: The random sampling of the given probability distribution(s) can differ between benchmark (re-)executions. This makes the comparison of different platforms questionable.</li> <li>Efficiency: Sampling a complex probability distribution incurs an additional runtime overhead, which can limit the rate of the load, distorting the originally specified workload.</li> </ol> <p>This rate controller aims to mitigate these problems by replaying a fix transaction load profile that was created \u201coffline.\u201d This way the profile is generated once, outside of the benchmark execution, and can be replayed any time with the same timing constraints with minimal overhead.</p> <p>A trivial use case of this controller is to play back a transaction recording created by the record controller. However, a well-formed trace file is the only requirement for this controller, hence any tool/method can be used to generate the transaction load profile.</p> <p>The following example specifies a rate controller that replays some client-dependent workload profiles (for details, see the available options below the example):</p> <pre><code>{\n  \"type\": \"replay-rate\",\n  \"opts\": {\n    \"pathTemplate\": \"../tx_records_client&lt;C&gt;.txt\",\n    \"inputFormat\": \"TEXT\",\n    \"logWarnings\": true,\n    \"defaultSleepTime\": 50\n    }\n}\n</code></pre> <p>The replay rate controller can be specified by setting the rate controller type to the <code>replay-rate</code> string. The available options (<code>opts</code> property) are the following:</p> <ul> <li><code>pathTemplate</code>: the template for the file path where the transaction timings will be replayed from. The path can be either an absolute path or relative to the root Caliper directory.</li> </ul> <p>The template can (and should) contain special \u201cvariables/placeholders\u201d that can refer to special environment properties (see the remarks at the record rate controller). The available placeholders are the following:     - <code>&lt;C&gt;</code>: placeholder for the 1-based index of the current client that uses this rate controller.     - <code>&lt;R&gt;</code>: placeholder for the 1-based index of the current round that uses this rate controller.</p> <ul> <li><code>inputFormat</code>: optional. Determines the format in which the transaction timings are stored (see the details at the  record rate controller). Defaults to <code>\"TEXT\"</code>. The currently supported formats are the following:<ul> <li><code>\"TEXT\"</code>: each recorded timing is encoded as text on separate lines.</li> <li><code>\"BIN_BE\"</code>: binary format with Big Endian encoding.</li> <li><code>\"BIN_LE\"</code>: binary format with Little Endian encoding.</li> </ul> </li> <li><code>logWarnings</code>: optional. Indicates whether to log that there are no more recordings to replay, so the <code>defaultSleepTime</code> is used between consecutive transactions. Defaults to <code>false</code>.</li> <li><code>defaultSleepTime</code>: optional. Determines the sleep time between transactions for the case when the benchmark execution is longer than the specified recording. Defaults to <code>20</code> ms.</li> </ul>"},{"location":"concepts/rate-controllers/#about-the-recordings","title":"About the recordings:","text":"<p>Special care must be taken, when using duration-based benchmark execution, as it is possible to issue more transactions than specified in the recording. A safety measure for this case is the <code>defaultSleepTime</code> option. This should only occur in the last few moments of the execution, affecting only a few transactions, that can be discarded before performing additional performance analyses on the results.</p> <p>The recommended approach is to use transaction number-based round configurations, since the number of transactions to replay is known beforehand. Note, that the number of workers affects the actual number of transactions submitted by a worker.</p>"},{"location":"concepts/rate-controllers/#adding-custom-controllers","title":"Adding Custom Controllers","text":"<p>It is possible to use rate controllers that are not built-in controllers of Caliper. When you specify the rate controller in the test configuration file (see the architecture documentation), you must set the <code>type</code> and <code>opts</code> attributes.</p> <p>You can set the <code>type</code> attribute so that it points to your custom JS file that satisfies the following criteria:</p> <ol> <li> <p>The file/module exports a <code>createRateController</code> function that takes the following parameters:</p> <ol> <li>An <code>TestMessage</code> parameter that is the <code>object</code> representation of the <code>opts</code> attribute set in the configuration file, and contains the custom settings of your rate controller.</li> <li>A <code>TransactionStatisticsCollector</code> object that gives the rate controller access to the current worker transaction statistics</li> <li>A <code>workerIndex</code> parameter of type number that is the 0-based index of the worker process using this rate controller.   The function must return an object (i.e., your rate controller instance) that satisfies the next criteria.</li> </ol> </li> <li> <p>The object returned by <code>createRateController</code> must implement the <code>/packages/caliper-core/lib/rate-control/rateInterface.js</code> interface, i.e., must provide the following async functions:</p> </li> <li>applyRateControl  , for performing the actual rate control by \u201cblocking\u201d the execution (in an async manner) for the desired time.</li> <li><code>end</code>, for disposing any acquired resources at the end of a round.</li> </ol> <p>The following example is a complete implementation of a rate control that doesn\u2019t perform any control, thus allowing the submitting of transactions as fast as the program execution allows it (warning, this implementation run with many client processes could easily over-load a backend network, so use it with caution).</p> <pre><code>/*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n* http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\nconst RateInterface = require('path-to-caliper/caliper-core/lib/rate-control/rateInterface.js');\n\n/**\n * Rate controller for allowing uninterrupted workloadload generation.\n *\n * @property {object} options The user-supplied options for the controller. Empty.\n */\nclass MyRateController  extends RateInterface{\n    /**\n     * Initializes the rate controller instance.\n     * @param {TestMessage} testMessage The testMessage passed for the round execution\n     * @param {TransactionStatisticsCollector} stats The TX stats collector instance.\n     * @param {number} workerIndex The 0-based index of the worker node.\n     * @param {number} roundIndex The 0-based index of the current round.\n     * @param {number} numberOfWorkers The total number of worker nodes.\n     * @param {object} roundConfig The round configuration object.\n     */\n     constructor(testMessage, stats, workerIndex) {\n        super(testMessage, stats, workerIndex);\n    }\n\n    /**\n     * Doesn't perform any rate control.\n     * @async\n     */\n    async applyRateControl() {\n        // no sleeping is needed, allow the transaction invocation immediately\n    }\n\n    /**\n     * Notify the rate controller about the end of the round.\n     * @async\n     */\n    async end() { \n        // nothing to dispose of\n    }\n}\n\n/**\n * Factory for creating a new rate controller instance.\n * @param {TestMessage} testMessage start test message\n * @param {TransactionStatisticsCollector} stats The TX stats collector instance.\n * @param {number} workerIndex The 0-based index of the worker node.\n *\n * @return {RateInterface} The new rate controller instance.\n */\nfunction createRateController(testMessage, stats, workerIndex) {\n    return new MyRate(testMessage, stats, workerIndex);\n}\n\nmodule.exports.createRateController = createRateController;\n</code></pre> <p>Let\u2019s say you save this implementation into a file called <code>maxRateController.js</code> next to your Caliper directory (so they\u2019re on the same level). In the test configuration file you can set this rate controller (at its required place in the configuration hierarchy) the following way:</p> <pre><code>rateControl:\n  # relative path from the Caliper directory\n- type: ../maxRateController.js\n  # empty options\n  opts: \n</code></pre>"},{"location":"concepts/rate-controllers/#license","title":"License","text":"<p>The Caliper codebase is released under the Apache 2.0 license. Any documentation developed by the Caliper Project is licensed under the Creative Commons Attribution 4.0 International License. You may obtain a copy of the license, titled CC-BY-4.0, at http://creativecommons.org/licenses/by/4.0/.</p>"},{"location":"concepts/runtime-config/","title":"Runtime Configuration","text":""},{"location":"concepts/runtime-config/#overview","title":"Overview","text":"<p>Caliper relies on the nconf package to provide a flexible and hierarchical configuration mechanism for runtime-related settings. Hierarchical configuration means that a runtime setting can be set or overridden from multiple sources/locations, and there is a priority order among them.</p> <p>In general, a setting is a simple <code>string</code> key associated with some <code>value</code>. However, it is highly recommended to compose the keys in a way that follows the place of the module in the hierarchy that uses the setting. Consider the following key, for example:</p> <p><code>caliper-fabric-timeout-invokeorquery</code></p> <p>The key consists of several parts that makes it easy to identify the purpose of the setting: it is used in Caliper, by the Fabric connector, it is a timeout-related setting that specifies the timeout to use for transaction invocations or queries. Every setting key in Caliper follows the same convention.</p> <p>The rule of thumb is to use lowercase letters (maybe numbers), and the hierarchy should be denoted by dashes (<code>-</code>) as separator.</p> <p>Every setting used by Caliper is prefixed with the <code>caliper-</code> string. The prefix serves as a namespace for the internal settings of Caliper modules. It also prevents name collisions since the configuration mechanism parses every setting available from the various sources, some intended, for example, to the underlying SDK modules or the workload modules.</p> <p>Note</p> <p>For every available runtime setting, refer to the last section.</p>"},{"location":"concepts/runtime-config/#setting-sources","title":"Setting sources","text":"<p>Caliper supports the following sources/locations where runtime settings can be set/overridden, in priority order, starting with the highest priority:</p> <ol> <li>Memory</li> <li>Command line arguments</li> <li>Environment variables</li> <li>Project-level configuration file</li> <li>User-level configuration file</li> <li>Machine-level configuration file</li> <li>Fallback/default configuration file</li> </ol> <p>For simplicity, you can think of the above order as the following: the \u201ccloser\u201d the setting is set to its point of use, the higher the priority of the set value.</p>"},{"location":"concepts/runtime-config/#in-memory-settings","title":"In-memory settings","text":"<p>If some component (Caliper-related, or user provided) sets a setting during runtime (using the configuration API), then that value will have priority over any other source/location that might have also set the same setting.</p> <p>The simple configuration API is provided by the <code>ConfigUtil</code> module of the <code>caliper-core</code> package. It exports a simple <code>get</code> and <code>set</code> method:</p> <ul> <li> <p><code>get(key:string, fallbackValue:any) =&gt; any</code></p> <p>Returns the value of the setting associated with the given <code>key</code>. If the setting is not set from any sources, then the <code>fallbackValue</code> is returned.</p> </li> <li> <p><code>set(key:string, value:any)</code></p> <p>Sets the <code>value</code> for the settings associated with the given <code>key</code>. It will overwrite any other value set by other sources.</p> </li> </ul> <p>For example:</p> <pre><code>const { ConfigUtil } = require('@hyperledger/caliper-core');\n\n// retrieves a setting for your module, if not set, use some default\nconst shouldBeFast = ConfigUtil.get('mymodule-performance-shoudbefast', /*default:*/ true);\n\nif (shouldBeFast) { /* ... */ } else { /* ... */ }\n</code></pre> <p>The above code also shows how a plugin module can easily leverage Caliper\u2019s configuration mechanism. Since the <code>mymodule-performance-shoudbefast</code> setting is queried through the configuration API, setting it from various sources automatically became possible (see the next sections for details).</p> <p>Note</p> <p>Thus adding a flexible runtime setting to any module requires only to query that setting through the configuration API when you need it (with the desired default/fallback value).</p>"},{"location":"concepts/runtime-config/#command-line-arguments","title":"Command line arguments","text":"<p>If we wish to influence the behavior of a third-party code (e.g., Caliper or a user callback module), we usually can\u2019t (or don\u2019t want to) overwrite the setting in the source code. A standard way of modifying the behavior of third-party/pre-packaged applications is to provide the settings as commandline arguments.</p> <p>Starting Caliper through the CLI, you can override runtime settings the following way:</p> <pre><code>caliper launch manager \\\n    --caliper-workspace yourworkspace/ \\\n    --caliper-benchconfig yourconfig.yaml \\\n    --caliper-networkconfig yournetwork.yaml \\\n    --mymodule-performance-shoudbefast=true\n</code></pre> <p>The arguments will be converted to lower-case letters and every <code>_</code> character will be replaced with <code>-</code>. So the above command can be written in a more user friendly way:</p> <pre><code>caliper launch manager \\\n    --caliper-workspace yourworkspace/ \\\n    --caliper-benchconfig yourconfig.yaml \\\n    --caliper-networkconfig yournetwork.yaml \\\n    --MyModule_Performance_ShoudBeFast=true\n</code></pre> <p>Both ways will result in the setting key <code>mymodule-performance-shoudbefast</code> associated with the <code>boolean</code> value <code>true</code>.</p> <p>Note, that <code>nconf</code> will automatically parse values of common types, so the <code>true</code> and <code>false</code> values will be parsed (and returned by <code>get</code>) as <code>boolean</code> values. This also holds for (both integer and floating point) numbers.</p> <p>Moreover, <code>boolean</code> values can be specified as flags, without explicitly setting the <code>true</code> or <code>false</code> value (note the <code>no-</code> prefix for the second case):</p> <ul> <li> <p>Setting a key to <code>true</code>: <pre><code>  caliper launch manager \\\n      --caliper-workspace yourworkspace/ \\\n      --caliper-benchconfig yourconfig.yaml \\\n      --caliper-networkconfig yournetwork.yaml \\\n      --mymodule-performance-shoudbefast\n</code></pre></p> </li> <li> <p>Setting a key to <code>false</code> (note the <code>no-</code> prefix): <pre><code>  caliper launch manager \\\n      --caliper-workspace yourworkspace/ \\\n      --caliper-benchconfig yourconfig.yaml \\\n      --caliper-networkconfig yournetwork.yaml \\\n      --no-mymodule-performance-shoudbefast\n</code></pre> Command line arguments overwrite the settings set in locations of the next sections.</p> </li> </ul>"},{"location":"concepts/runtime-config/#environment-variables","title":"Environment variables","text":"<p>If Caliper is part of a scripted environment, then it would be cumbersome to modify the script to pass command line arguments to Caliper. The standard approach in these scenarios is to use environment variables.</p> <p>The example setting can be set the following way using an environment variable:</p> <pre><code>export MYMODULE_PERFORMANCE_SHOULDBEFAST=true\n\n# calling some script containing the following command\ncaliper launch manager \\\n    --caliper-workspace yourworkspace/ \\\n    --caliper-benchconfig yourconfig.yaml \\\n    --caliper-networkconfig yournetwork.yaml\n</code></pre> <p>Note the standard notation of environment variable setting: upper-case letters separated by <code>_</code> characters. Caliper performs the same transformation as with command line arguments: the variable names will be converted to lower-case letters and every <code>_</code> character will be replaced with <code>-</code>. So the above setting will also result in the setting key <code>mymodule-performance-shoudbefast</code> associated with the <code>boolean</code> value <code>true</code>.</p>"},{"location":"concepts/runtime-config/#configuration-files","title":"Configuration files","text":"<p>Depending on the scenario, users may want to change multiple runtime settings. Using command line arguments and environment variables to change multiple settings can become cumbersome.</p> <p>Using configuration files is a standard way of overriding multiple settings in a manageable way. Caliper provides multiple configuration \u201clocations\u201d where you can insert configuration files into the settings hierarchy. These locations also follow the \u201ccloser one wins\u201d semantic of the hierarchical configuration mechanism.</p> <p>Moreover, YAML-based configuration files allow comments that make your configuration choices self-documenting and self-contained.</p> <p>Note, that no additional transformation is performed on the key names of a YAML file, they are simply concatenated with <code>-</code> to get a flat string key from the object hierarchy.</p> <p>So the hierarchical setting</p> <pre><code>mymodule:\n  performance:\n    shouldbefast: true\n</code></pre> <p>will be parsed as the <code>mymodule-performance-shouldbefast</code> string key associated with the <code>true</code> Boolean values.</p>"},{"location":"concepts/runtime-config/#project-level","title":"Project-level","text":"<p>If you have a group of settings that are always overridden in your Caliper benchmark project, then it is recommended to define them as a project-level configuration file. This file will usually consist of a subset of settings defined in the default configuration file (and probably your custom settings associated with your custom user module).</p> <p>The project-level configuration file can be included into the hierarchy in two ways:</p> <ul> <li>Define the overridden settings in the <code>caliper.yaml</code> file in the workspace directory</li> <li>Or set the path of the configuration file explicitly through the <code>caliper-projectconfig</code> setting key using one of the higher priority locations above (i.e., in-memory, command line argument or environment variable):<ul> <li>The command line approach: <pre><code>caliper launch manager \\\n    --caliper-workspace yourworkspace/ \\\n    --caliper-benchconfig yourconfig.yaml \\\n    --caliper-networkconfig yournetwork.yaml \\\n    --Caliper-ProjectConfig mypath/project1-config.yaml\n</code></pre></li> <li>The environment variable approach: <pre><code>export CALIPER_PROJECTCONFIG=mypath/project1-config.yaml\ncaliper launch manager \\\n    --caliper-workspace yourworkspace/ \\\n    --caliper-benchconfig yourconfig.yaml \\\n    --caliper-networkconfig yournetwork.yaml\n</code></pre></li> </ul> </li> </ul> <p>Note that project-level settings will override the settings defined by the locations of the next sections.</p>"},{"location":"concepts/runtime-config/#user-level","title":"User-level","text":"<p>If you find yourself overriding the same settings for multiple Caliper benchmark projects, then it is recommended to extract the common settings into a user-level configuration file. To include a user-level configuration file into the hierarchy, specify its path through the <code>caliper-userconfig</code> settings key using one of the higher priority locations above (i.e., in-memory, command line argument, environment variable or the project-level configuration file):</p> <pre><code>- The command line approach:\n```sh\ncaliper launch manager \\\n    --caliper-workspace yourworkspace/ \\\n    --caliper-benchconfig yourconfig.yaml \\\n    --caliper-networkconfig yournetwork.yaml \\\n    --Caliper-UserConfig ~/.config/my-caliper-config.yaml\n```\n- The environment variable approach:\n```sh\n    export CALIPER_USERCONFIG=~/.config/my-caliper-config.yaml\n    caliper launch manager \\\n        --caliper-workspace yourworkspace/ \\\n        --caliper-benchconfig yourconfig.yaml \\\n        --caliper-networkconfig yournetwork.yaml\n```\n- The configuration file approach (excerpt from the project-level configuration file):\n```sh\n      caliper:\nuserconfig: ~/.config/my-caliper-config.yaml\n# additional settings\n```\n</code></pre>"},{"location":"concepts/runtime-config/#machine-level","title":"Machine-level","text":"<p>If multiple users use the same workstation and want to share common settings across Caliper projects and users, then a machine-level configuration file can be included into the hierarchy by specifying its path through the <code>caliper-machineconfig</code> settings key using one of the higher priority locations above (i.e., command line argument, environment variable, project- or user-level configuration files):     - The command line approach:     <pre><code>    caliper launch manager \\\n        --caliper-workspace yourworkspace/ \\\n        --caliper-benchconfig yourconfig.yaml \\\n        --caliper-networkconfig yournetwork.yaml \\\n        --Caliper-MachineConfig /etc/config/caliper.yaml\n</code></pre>     - The environment variable approach:     <pre><code>    export CALIPER_MACHINECONFIG=/etc/config/caliper.yaml\n    caliper launch manager \\\n        --caliper-workspace yourworkspace/ \\\n        --caliper-benchconfig yourconfig.yaml \\\n        --caliper-networkconfig yournetwork.yaml\n</code></pre>     - The configuration file approach (excerpt from the project- or user-level configuration file):     <pre><code>    caliper:\n        machineconfig: /etc/config/caliper.yaml\n    # additional settings\n</code></pre></p>"},{"location":"concepts/runtime-config/#default-configuration","title":"Default configuration","text":"<p>A default/fallback configuration file is shipped with the Caliper-related packages that defines sensible fallback values and documentation for each available setting used by the Caliper modules. This configuration file has the lowest priority among the supported setting locations.</p>"},{"location":"concepts/runtime-config/#available-settings","title":"Available settings","text":"<p>Note</p> <p>Always refer to the self-documenting default configuration file for the currently supported runtime configuration settings.</p>"},{"location":"concepts/runtime-config/#basic-settings","title":"Basic settings","text":"Key Description caliper-benchconfig Path to the benchmark configuration file that describes the test worker(s), test rounds and monitors. caliper-networkconfig Path to the network configuration file that contains information required to interact with the SUT. caliper-machineconfig The file path for the machine-level configuration file. Can be relative to the workspace. caliper-projectconfig The file path for the project-level configuration file. Can be relative to the workspace. caliper-userconfig The file path for the user-level configuration file. Can be relative to the workspace. caliper-workspace Workspace directory that contains all configuration information caliper-progress-reporting-enabled Boolean value for enabling transaction completion progress display by the Caliper manager process caliper-progress-reporting-interval Numeric value used to specify the caliper progress update frequency, in milliseconds"},{"location":"concepts/runtime-config/#binding-settings","title":"Binding settings","text":"Key Description caliper-bind-args The additional args to pass to the binding (i.e., npm install) command. caliper-bind-cwd The CWD to use for the binding (i.e., npm install) command. caliper-bind-file The path of a custom binding configuration file that will override the default one. caliper-bind-sut The binding specification of the SUT in the <code>&lt;SUT type&gt;:&lt;SDK version&gt;</code> format."},{"location":"concepts/runtime-config/#reporting-settings","title":"Reporting settings","text":"Key Description caliper-report-charting-hue The HUE value to construct the chart color scheme from. caliper-report-charting-scheme The color scheme method to use for producing chart colors. caliper-report-charting-transparency The transparency value [0..1] to use for the charts. caliper-report-options The options object to pass to fs.writeFile. caliper-report-path The absolute or workspace-relative path of the generated report file. caliper-report-precision Precision (significant digits) for the numbers in the report."},{"location":"concepts/runtime-config/#logging-settings","title":"Logging settings","text":"Key Description caliper-logging-formats-align Adds a tab delimiter before the messages to align them in the same place. caliper-logging-formats-attributeformat-\\ Specifies the formatting string for the log message attribute <code>&lt;attribute&gt;</code>. caliper-logging-formats-json Indicates that the logs should be serialized in JSON format. caliper-logging-formats-label Adds a specified label to every message. Useful for distributed worker scenario. caliper-logging-formats-pad Pads the log level strings to be the same length. caliper-logging-formats-timestamp Adds a timestamp to the messages with the specified format. caliper-logging-formats-colorize-all Indicates that all log message attributes must be colorized. caliper-logging-formats-colorize-\\ Indicates that log message attribute <code>&lt;attribute&gt;</code> must be colorized. caliper-logging-formats-colorize-colors-\\ Sets the color for the log messages with level <code>&lt;level&gt;</code>. caliper-logging-targets-\\-enabled Sets whether the target transport <code>&lt;target&gt;</code> is enabled or disabled. caliper-logging-template Specifies the message structure through placeholders."},{"location":"concepts/runtime-config/#worker-management-settings","title":"Worker management settings","text":"Key Description caliper-worker-communication-method Indicates the type of the communication between the manager and workers. caliper-worker-communication-address The address of the MQTT broker used for distributed worker management. caliper-worker-pollinterval The interval for polling for new available workers, in milliseconds. caliper-worker-remote Indicates whether the workers operate in distributed mode."},{"location":"concepts/runtime-config/#benchmark-phase-settings","title":"Benchmark phase settings","text":"Key Description caliper-flow-only-end Indicates whether to only perform the end command script in the network configuration file. caliper-flow-only-init Indicates whether to only perform the init phase of the benchmark. caliper-flow-only-install Indicates whether to only perform the smart contract install phase of the benchmark. caliper-flow-only-start Indicates whether to only perform the start command script in the network configuration file. caliper-flow-only-test Indicates whether to only perform the test phase of the benchmark. caliper-flow-skip-end Indicates whether to skip the end command script in the network configuration file. caliper-flow-skip-init Indicates whether to skip the init phase of the benchmark. caliper-flow-skip-install Indicates whether to skip the smart contract install phase of the benchmark. caliper-flow-skip-start Indicates whether to skip the start command script in the network configuration file. caliper-flow-skip-test Indicates whether to skip the test phase of the benchmark."},{"location":"concepts/runtime-config/#authentication-settings","title":"Authentication settings","text":"Key Description caliper-auth-prometheus-username Basic authentication username to use authenticate with an existing Prometheus server. caliper-auth-prometheus-password Basic authentication password to use authenticate with an existing Prometheus server. caliper-auth-prometheuspush-username Basic authentication username to use authenticate with an existing Prometheus Push Gateway. caliper-auth-prometheuspush-password Basic authentication password to use authenticate with an existing Prometheus Push Gateway."},{"location":"concepts/runtime-config/#fabric-connector-settings","title":"Fabric Connector settings","text":"<p>In the following table, The 1.4 Refers to <code>1.4</code> SUT without the caliper-fabric-gateway-enabled specified and <code>1.4Gateway</code> Refers to 1.4 SUT with the caliper-fabric-gateway-enabled specified. <code>All</code> means that all the SUT versions support this option</p> Key SUT Version Description caliper-fabric-timeout-invokeorquery All The default timeout in seconds to use for invoking or querying transactions. Default is 60 seconds. caliper-fabric-gateway-enabled 1.4 Indicates whether to use the Fabric gateway-based SDK API for the 1.4 Fabric SUT. Default is false. caliper-fabric-gateway-localhost 1.4Gateway, 2.2 Indicates whether to convert discovered endpoints to localhost. Does not apply if discover is set to false in network config. Default is true. caliper-fabric-gateway-querystrategy 1.4Gateway, 2.2 Sets the query strategy to use for 2.2 and 1.4 when gateway is enabled. Default is Round Robin. caliper-fabric-gateway-eventstrategy 1.4Gateway, 2.2 Sets the event strategy to use for 2.2 and 1.4 when gateway is enabled. Default is any in Invoker Organisation. caliper-fabric-latencythreshold 1.4 Determines the reported commit time of a transaction based on the given percentage of event sources. caliper-fabric-loadbalancing 1.4 Determines how automatic load balancing is applied. caliper-fabric-verify-proposalresponse 1.4 Indicates whether to verify the received proposal responses. caliper-fabric-verify-readwritesets 1.4 Indicates whether to verify that the read-write sets returned by the endorsers match."},{"location":"concepts/runtime-config/#supported-event-strategies","title":"Supported Event Strategies","text":"<p>A description of the different types of event strategy for both the 1.4 and 2.2 SUT can be found here</p> <p>To select an event strategy set the property <code>caliper-fabric-gateway-eventstrategy</code> to one of the following</p> Strategy Corresponds to msp_all MSPID_SCOPE_ALLFORTX msp_any MSPID_SCOPE_ANYFORTX network_all NETWORK_SCOPE_ALLFORTX network_any NETWORK_SCOPE_ANYFORTX <p>for example using a flag on the cli to set to have all peers in the network report that the transaction was committed you would specify</p> <pre><code>--caliper-fabric-gateway-eventstrategy network_all\n</code></pre> <p>The default is <code>msp_any</code></p>"},{"location":"concepts/runtime-config/#supported-query-strategies","title":"Supported Query Strategies","text":"<p>A description of the different types of query strategy for both the 1.4 and 2.2 SUT can be found here</p> <p>To select a query strategy set the property <code>caliper-fabric-gateway-querystrategy</code> to one of the following</p> Strategy Corresponds to msp_single MSPID_SCOPE_SINGLE msp_round_robin MSPID_SCOPE_ROUND_ROBIN <p>for example using a flag on the cli to set to have all peers in the network report that the transaction was committed you would specify</p> <pre><code>--caliper-fabric-gateway-querystrategy msp_single\n</code></pre> <p>The default is <code>msp_round_robin</code></p>"},{"location":"concepts/runtime-config/#license","title":"License","text":"<p>The Caliper codebase is released under the Apache 2.0 license. Any documentation developed by the Caliper Project is licensed under the Creative Commons Attribution 4.0 International License. You may obtain a copy of the license, titled CC-BY-4.0, at http://creativecommons.org/licenses/by/4.0/.</p>"},{"location":"concepts/workload-module/","title":"Workload modules","text":""},{"location":"concepts/workload-module/#overview","title":"Overview","text":"<p>Workload modules are the essence of a Caliper benchmark since it is their responsibility to construct and submit TXs. Accordingly, workload modules implement the logic pertaining to your business, benchmark or user behavior. Think of the workload modules as the brain of an emulated SUT client, deciding what kind of TX to submit at the given moment.</p>"},{"location":"concepts/workload-module/#implementing-the-workload-module","title":"Implementing the workload module","text":"<p>Workload modules are Node.JS modules that expose a certain API. There are no further restrictions on the implementation, thus arbitrary logic (using further arbitrary components) can be implemented.</p>"},{"location":"concepts/workload-module/#the-api","title":"The API","text":"<p>Workload modules are loaded through factory functions, just like other pluggable modules in Caliper. Accordingly, a workload module implementation must export a single factory function, named <code>createWorkloadModule</code>:</p> <pre><code>/**\n * Create a new instance of the workload module.\n * @return {WorkloadModuleInterface}\n */\nfunction createWorkloadModule() {\n    return new MyWorkload();\n}\n\nmodule.exports.createWorkloadModule = createWorkloadModule;\n</code></pre> <p>The factory function must return an instance that implements the <code>[WorkloadModuleInterface](https://github.com/hyperledger-caliper/caliper/blob/main/packages/caliper-core/lib/worker/workload/workloadModuleInterface.js)</code> class. See the example for a complete implementation.</p> <p>The interface contains the following three asynchronous functions:</p>"},{"location":"concepts/workload-module/#initializeworkloadmodule","title":"initializeWorkloadModule","text":"<p>The <code>initializeWorkloadModule</code> function is called by the worker processes before each round, providing contextual arguments to the module:</p> <ol> <li><code>workerIndex (Number)</code>: The 0-based index of the worker instantiating the workload module.</li> <li><code>totalWorkers (Number)</code>: The total number of workers participating in the round.</li> <li><code>roundIndex (Number)</code>: The 0-based index of the currently executing round.</li> <li><code>roundArguments (Object)</code>: The user-provided arguments for the round from the benchmark configuration file.</li> <li><code>sutAdapter (BlockchainConnector)</code>: The connector of the underlying SUT (System Under Test).</li> <li><code>sutContext (Object)</code>: The custom context object provided by the SUT connector.</li> </ol> <p>This function is a good place to validate your workload module arguments provided by the benchmark configuration file. It\u2019s also a good practice to perform here any preprocessing needed to ensure the fast assembling of TX contents later in the <code>submitTransaction</code> function.</p>"},{"location":"concepts/workload-module/#submittransaction","title":"submitTransaction","text":"<p>The <code>submitTransaction</code> function is the backbone of the workload generation. The worker process calls this function every time the rate controller enables the next TX. So it is vital to keep this function implementation as efficient as possible in order to be able to keep up with high frequency scheduling settings.</p> <p>The function requires no parameters, but it is its responsibility to submit the TX through the connector API.</p>"},{"location":"concepts/workload-module/#cleanupworkloadmodule","title":"cleanupWorkloadModule","text":"<p>The <code>cleanupWorkloadModule</code> function is called at the end of the round, and can be used to perform any resource cleanup required by your workload implementation.</p>"},{"location":"concepts/workload-module/#simple-base-class","title":"Simple base class","text":"<p>Although directly implementing the interface is possible, Caliper provides a simple utility base class that implements the required interface and also performs some common housekeeping operation. Thus inheriting from the <code>WorkloadModuleBase</code> class can result in simpler implementations.</p> <p>The base class provides the following utilities:</p> <ul> <li>Creates instance variables in the constructor that match the parameters of the <code>initializeWorkloadModule</code> function.</li> <li>Provides an implementation for the <code>initializeWorkloadModule</code> function, where it saves the received arguments into the instance variables.</li> <li>Provides a no-op implementation for the <code>cleanupWorkloadModule</code> function.</li> </ul> <p>Inheriting from this base class only requires the implementation of the submitTransaction function by the user. Additionally, the initialization logic can be extended/overridden if necessary.</p>"},{"location":"concepts/workload-module/#example","title":"Example","text":"<p>A complete (albeit simple) example of a workload module implementation (mostly identical with the <code>WorkloadModuleBase</code> implementation):</p> <pre><code>'use strict';\n\nconst { WorkloadModuleInterface } = require('@hyperledger/caliper-core');\n\nclass MyWorkload extends WorkloadModuleInterface {\n    constructor() {\n        super();\n        this.workerIndex = -1;\n        this.totalWorkers = -1;\n        this.roundIndex = -1;\n        this.roundArguments = undefined;\n        this.sutAdapter = undefined;\n        this.sutContext = undefined;\n    }\n\n    async initializeWorkloadModule(workerIndex, totalWorkers, roundIndex, roundArguments, sutAdapter, sutContext) {\n        this.workerIndex = workerIndex;\n        this.totalWorkers = totalWorkers;\n        this.roundIndex = roundIndex;\n        this.roundArguments = roundArguments;\n        this.sutAdapter = sutAdapter;\n        this.sutContext = sutContext;\n    }\n\n    async submitTransaction() {\n        let txArgs = {\n            // TX arguments for \"mycontract\"\n        };\n\n        return this.sutAdapter.invokeSmartContract('mycontract', 'v1', txArgs, 30);\n    }\n\n    async cleanupWorkloadModule() {\n        // NOOP\n    }\n}\n\nfunction createWorkloadModule() {\n    return new MyWorkload();\n}\n\nmodule.exports.createWorkloadModule = createWorkloadModule;\n</code></pre> <p>The simpler implementation using the utility base class is the following:</p> <pre><code>'use strict';\n\nconst { WorkloadModuleBase } = require('@hyperledger/caliper-core');\n\nclass MyWorkload extends WorkloadModuleBase {\n    async submitTransaction() {\n        let txArgs = {\n            // TX arguments for \"mycontract\"\n        };\n\n        return this.sutAdapter.invokeSmartContract('mycontract', 'v1', txArgs, 30);\n    }\n}\n\nfunction createWorkloadModule() {\n    return new MyWorkload();\n}\n\nmodule.exports.createWorkloadModule = createWorkloadModule;\n</code></pre>"},{"location":"concepts/workload-module/#configuring-the-workload-module","title":"Configuring the workload module","text":"<p>To use your workload module for a given round, you only need to reference it in the benchmark configuration file:</p> <ol> <li>Set the <code>test.rounds[i].workload.module</code> attribute to the path of your workload module file. The path can be either an absolute path, or a relative path to the configured workspace path. You can also set the attribute to the package name of your published workload module, but in that case you need to install it beforehand.</li> <li>If your module supports different settings, set the <code>test.rounds[i].workload.arguments</code> attribute object accordingly. It will be passed to your module upon initialization.</li> </ol>"},{"location":"concepts/workload-module/#tips-tricks","title":"Tips &amp; Tricks","text":"<p>The following advices might help you to improve your workload module implementation.</p> <ol> <li>You can use (<code>require</code>) any Node.JS module in your code (including the core Caliper module). Modularization is important for keeping your implementation clean and manageable.</li> <li>If you use third-party modules, then it is your responsibility to make them available to your workload module. This usually requires an <code>npm install</code> call in your module directory before you start Caliper.</li> <li>Caliper provides some core utilities that might make your life easier, such as logging and runtime configuration. Use them, don\u2019t reinvent the wheel!</li> <li>The <code>submitTransaction</code> function is on the hot path of the worker workload generation loop. Do computation-intensive tasks with care, it might hurt the scheduling precision of TXs! You can perform expensive pre-processing tasks in the <code>initializeWorkloadModule</code> function instead.</li> </ol>"},{"location":"concepts/workload-module/#license","title":"License","text":"<p>The Caliper codebase is released under the Apache 2.0 license. Any documentation developed by the Caliper Project is licensed under the Creative Commons Attribution 4.0 International License. You may obtain a copy of the license, titled CC-BY-4.0, at http://creativecommons.org/licenses/by/4.0/.</p>"},{"location":"connectors/ethereum-config/","title":"Ethereum","text":"<p>This page introduces the Ethereum adapter suitable for all the Ethereum clients that expose the web3 RPC interface over websockets.</p> <p>Note</p> <p>This adapter relies on web3js 1.2.x that is the stable version coming from 1.0.0-beta.37</p> <p>Note</p> <p>Hyperledger Besu and Geth are the current tested clients. The tests are driven via standard Ethereum JSON-RPC APIs so other clients should be compatible once docker configurations exist.</p> <p>Note</p> <p>Some highlights of the provided features:</p> <ul> <li>configurable confirmation blocks threshold</li> </ul> <p>The page covers the following aspects of using the Ethereum adapter:</p> <ul> <li>how to assemble a connection profile file, a.k.a., the blockchain network configuration file;</li> <li>how to use the adapter interface from the user callback module;</li> <li>transaction data gathered by the adapter;</li> <li>and a [complete example]../connectors/ethereum-config.md/#connection-profile-example) of a connection profile.</li> </ul>"},{"location":"connectors/ethereum-config/#assembling-the-network-configuration-file","title":"Assembling the Network Configuration File","text":"<p>The JSON network configuration file of the adapter essentially defines which contracts are expected to be on the network and which account the adapter should use to deploy the pointed contracts and which account use to invoke them.</p>"},{"location":"connectors/ethereum-config/#connection-profile-example","title":"Connection profile example","text":"<p>We will provide an example of the configuration and then we\u2019ll in deep key by key</p> <pre><code>{\n    \"caliper\": {\n        \"blockchain\": \"ethereum\",\n        \"command\" : {\n            \"start\": \"docker-compose -f network/ethereum/1node-clique/docker-compose.yml up -d &amp;&amp; sleep 3\",\n            \"end\" : \"docker-compose -f network/ethereum/1node-clique/docker-compose.yml down\"\n          }\n    },\n    \"ethereum\": {\n        \"url\": \"ws://localhost:8545\",\n        \"contractDeployerAddress\": \"0xc0A8e4D217eB85b812aeb1226fAb6F588943C2C2\",\n        \"contractDeployerAddressPassword\": \"password\",\n        \"fromAddress\": \"0xc0A8e4D217eB85b812aeb1226fAb6F588943C2C2\",\n        \"fromAddressPassword\": \"password\",\n        \"transactionConfirmationBlocks\": 12,\n        \"contracts\": {\n            \"simple\": {\n                \"path\": \"src/contract/ethereum/simple/simple.json\",\n                \"gas\": {\n                    \"open\": 45000,\n                    \"query\": 100000,\n                    \"transfer\": 70000\n                }\n            }\n        }\n    }\n}\n</code></pre> <p>The top-level <code>caliper</code> attribute specifies the type of the blockchain platform, so Caliper can instantiate the appropriate adapter when it starts. To use this adapter, specify the <code>ethereum</code> value for the <code>blockchain</code> attribute.</p> <p>Furthermore, it also contains two optional commands: a <code>start</code> command to execute once before the tests and an <code>end</code> command to execute once after the tests. Using these commands is an easy way, for example, to automatically start and stop a test network. When connecting to an already deployed network, you can omit these commands.</p> <p>These are the keys to provide inside the configuration file under the <code>ethereum</code> one:</p> <ul> <li>URL of the node to connect to. Only http is currently supported.</li> <li>Deployer address with which to deploy required contracts.</li> <li>Deployer address private key: the private key of the deployer address.</li> <li>Deployer address password: to unlock the deployer address.</li> <li>Address from which to invoke methods of the benchmark.</li> <li>Private Key: the private key of the benchmark address.</li> <li>Password: to unlock the benchmark address.</li> <li>Number of confirmation blocks to wait to consider a transaction as successfully accepted in the chain.</li> <li>Contracts configuration.</li> </ul> <p>The following sections detail each part separately. For a complete example, please refer to the example section or one of the example files in the <code>network/ethereum</code> directories</p>"},{"location":"connectors/ethereum-config/#url","title":"URL","text":"<p>The URL of the node to connect to. Any host and port can be used if it is reachable. Currently only websocket is supported.</p> <pre><code>\"url\": \"ws://localhost:8545\"\n</code></pre> <p>Unfortunately, HTTP connections are explicitly disallowed, as</p> <ol> <li>there is no efficient way to guarantee the order of transactions submitted over http, which leads to nonce errors, and</li> <li>this adapter relies on web3.js, and this library has deprecated its support for RPC over HTTP.</li> </ol>"},{"location":"connectors/ethereum-config/#deployer-address","title":"Deployer Address","text":"<p>The address to use to deploy contracts of the network. Without particular or specific needs it can be set to be equal to the benchmark address. Its private key must be hold by the node connected with URL and it must be provided in the checksum form (the one with both lowercase and uppercase letters).</p> <pre><code>\"contractDeployerAddress\": \"0xc0A8e4D217eB85b812aeb1226fAb6F588943C2C2\"\n</code></pre>"},{"location":"connectors/ethereum-config/#deployer-address-private-key","title":"Deployer Address Private Key","text":"<p>The private key for the deployer address. If present then transactions are signed inside caliper and sent \u201craw\u201d to the ethereum node.</p> <pre><code>\"contractDeployerAddressPrivateKey\": \"0x45a915e4d060149eb4365960e6a7a45f334393093061116b197e3240065ff2d8\"\n</code></pre>"},{"location":"connectors/ethereum-config/#deployer-address-password","title":"Deployer Address Password","text":"<p>The password to use to unlock deployer address. If there isn\u2019t an unlock password, this key must be present as empty string. If the deployer address private key is present this is not used.</p> <pre><code>\"contractDeployerAddressPassword\": \"gottacatchemall\"\n</code></pre> <p>Note</p> <p>Hyperledger Besu does not provide wallet services, so the <code>contractDeployerPassword</code> is not supported and the private key variant must be used.</p>"},{"location":"connectors/ethereum-config/#benchmark-address","title":"Benchmark Address","text":"<p>The address to use while invoking all the methods of the benchmark. Its private key must be hold by the node connected with URL and it must be provided in the checksum form (the one with both lowercase and uppercase letters).</p> <pre><code>\"fromAddress\": \"0xc0A8e4D217eB85b812aeb1226fAb6F588943C2C2\"\n</code></pre>"},{"location":"connectors/ethereum-config/#benchmark-address-seed","title":"Benchmark Address Seed","text":"<p>As an alternative to <code>fromAddress</code>, <code>fromAddressPrivateKey</code>, and <code>fromAddressPassword</code> the network configuration can use a fixed seed and derive needed addresses via BIP-44 key derivation. Each caliper test worker will generate an address for use as fromAddress and <code>fromAddressPrivateKey</code> using the derivation path <code>m/44'/60'/&lt;x&gt;'/0/0</code>, where is the <code>clientIdx</code> passed into <code>getContext</code>.</p> <p>This configuration does not override fromAddress, but it takes priority over <code>fromAddressPrivateKey</code> and <code>fromAddressPassword</code>.</p> <pre><code>\"fromAddressSeed\": \"0x3f841bf589fdf83a521e55d51afddc34fa65351161eead24f064855fc29c9580\"\n</code></pre> <p>Note</p> <p>The use of fromAddressSeed is mandatory if you want to use more than 1 worker in your benchmark. This is because each worker independently fetches the current transaction nonce for the address it is using. If they all use the same address, they will all get the same nonces, causing known transaction errors. By using a seed, each worker will generate a unique address and private key.</p>"},{"location":"connectors/ethereum-config/#benchmark-address-private-key","title":"Benchmark Address Private Key","text":"<p>The private key for the benchmark address. If present then transactions are signed inside caliper and sent \u201craw\u201d to the ethereum node.</p> <p>This configuration takes priority over <code>fromAddressPassword</code>.</p> <pre><code>\"fromAddressPassword\": \"0x45a915e4d060149eb4365960e6a7a45f334393093061116b197e3240065ff2d8\"\n</code></pre>"},{"location":"connectors/ethereum-config/#benchmark-address-password","title":"Benchmark Address Password","text":"<p>The password to use to unlock benchmark address. If there isn\u2019t an unlock password, this key must be present as empty string. If the benchmark address private key is present this is not used.</p> <pre><code>\"fromAddressPassword\": \"gottacatchemall\"\n</code></pre> <p>Note</p> <p>Hyperledger Besu does not provide wallet services, so the <code>fromAddressPassword</code> option is not supported and the private key variant must be used.</p>"},{"location":"connectors/ethereum-config/#confirmation-blocks","title":"Confirmation blocks","text":"<p>It is the number of blocks the adapter will wait before warn Caliper that a transaction has been successfully executed on the network. You can freely tune it from 1 to the desired confirmations. Keep in mind that in the Ethereum main net (PoW), 12 to 20 confirmations can be required to consider a transaction as accepted in the blockchain. If you\u2019re using different consensus algorithm (like clique in the example network provided) it can be safely brought to a lower value. In any case it is up to you.</p> <pre><code>\"transactionConfirmationBlocks\": 12\n</code></pre>"},{"location":"connectors/ethereum-config/#contract-configuration","title":"Contract configuration","text":"<p>It is the list, provided as a JSON object, of pre-deployed contracts or contracts to deploy on the network before running the benchmark. You should provide a JSON entry for each contract. The key will represent the contract identifier to invoke methods on that contract.</p> <p>Depending on whether you plan to use pre-deployed contracts or deploy them during the benchmark, the configuration will differ slightly.</p> <p>Note</p> <p>Defining configurations simultaneously for both pre-deployed contracts and contracts to be deployed by Caliper is currently not supported and may result in unexpected errors. This is because opting for pre-deployed contracts means the contract installation phase will be skipped.</p> <p>In both cases, it strongly recommended to specify a gas field, which is an object with one field per contract function that you will call in your test. The value of these fields should be set to the amount of gas that will be required to execute your transaction. There is no need for this number to be an exact match, as it\u2019s used to set the gas limit for the transaction, so if your transaction might have a variable gas cost, just set this value to the highest gas usage that you would expect to see for your transaction.</p> <p>Note: If you do not specify the gas for your contract functions, web3 will automatically call out to your node to estimate the gas requirement before submitting the transaction. This causes three problems. First, it means that your transaction will effectively execute twice, doubling the load on the node serving as your RPC endpoint. Second, the extra call will add significant additional latency to every transaction. Third, your transactions may be reordered, causing transaction failures due to out of order nonces.</p>"},{"location":"connectors/ethereum-config/#pre-deployed-contracts","title":"Pre-deployed contracts","text":"<p>To use pre-deployed contracts, you must launch caliper using the <code>--caliper-flow-skip-install</code> option, which skips the smart contract installation phase. For each key you must provide a JSON object containing the contract address and the contract ABI. The ABI is required to invoke methods on the contract.</p> <pre><code>\"contracts\": {\n    \"simple\": {\n        \"address\": \"0xc24f4561B8F1159E8D8661B282A2974cD48058C2\",\n        \"gas\": {\n            \"open\": 45000,\n            \"query\": 100000,\n            \"transfer\": 70000\n        },\n        \"abi\": [...]\n    }\n}\n</code></pre>"},{"location":"connectors/ethereum-config/#contracts-to-deploy","title":"Contracts to Deploy","text":"<p>Contracts to be deployed by Caliper require the specification of a contract definition file for each. In the contract configuration you must include a path field pointing to each contract definition file. It\u2019s in this new file that you will define the contract\u2019s ABI and bytecode, as well as the gas required to deploy it.</p> <pre><code>\"contracts\": {\n    \"simple\": {\n        \"path\": \"src/contract/ethereum/simple/simple.json\",\n        \"gas\": {\n            \"open\": 45000,\n            \"query\": 100000,\n            \"transfer\": 70000\n        }\n    },\n    \"second\": {\n        \"path\": \"src/contract/ethereum/second/second.json\",\n        \"gas\": {\n            \"function\": 12345\n        }\n    }\n}\n</code></pre>"},{"location":"connectors/ethereum-config/#contract-definition-file","title":"Contract definition file","text":"<p>Contract definition file is a simple JSON file containing basic information to deploy and use an Ethereum contract. Four keys are required:</p> <ul> <li>Name</li> <li>ABI</li> <li>Bytecode</li> <li>Gas</li> </ul> <p>Here is an example: <pre><code>{\n    \"name\": \"The simplest workload contract\",\n    \"abi\": [{\"constant\":true,\"inputs\":[{\"nam......ype\":\"function\"}],\n    \"bytecode\": \"0x608060405.........b0029\",\n    \"gas\": 259823\n}\n</code></pre></p>"},{"location":"connectors/ethereum-config/#name","title":"Name","text":"<p>It is a name to display in logs when the contract gets deployed. It is only a description name.</p>"},{"location":"connectors/ethereum-config/#abi","title":"ABI","text":"<p>It is the ABI generated when compiling the contract. It is required in order to invoke methods on a contract.</p>"},{"location":"connectors/ethereum-config/#bytecode","title":"Bytecode","text":"<p>It is the bytecode generated when compiling the contract. Note that since it is an hexadecimal it must start with the <code>0x</code>.</p>"},{"location":"connectors/ethereum-config/#gas","title":"Gas","text":"<p>It is the gas required to deploy the contract. It can be easily calculated with widely used solidity development kits or querying to a running Ethereum node.</p>"},{"location":"connectors/ethereum-config/#using-the-adapter-interface","title":"Using the Adapter Interface","text":"<p>The workload modules interact with the adapter at two phases of the tests: during the initialization of the workload module (the <code>initializeWorkloadModule</code> function), and when submitting invoke or query transactions (the <code>submitTransaction</code> function).</p>"},{"location":"connectors/ethereum-config/#the-initializeworkloadmodule-function","title":"The initializeWorkloadModule function","text":"<p>See the corresponding documentation of the function for the description of its parameters.</p> <p>The last argument of the function is a <code>sutContext</code> object, which is a platform-specific object provided by the backend blockchain\u2019s connector. The context object provided by this connector is the following:</p> <pre><code>{\n  fromAddress: \"0xA89....7G\"\n  web3: Web3\n}\n</code></pre> <p>The <code>fromAddress</code> property is the benchmark address while web3 is the configured instance of the Web3js client.</p>"},{"location":"connectors/ethereum-config/#the-submittransaction-function","title":"The submitTransaction function","text":"<p>The <code>sutAdapter</code> object received (and saved) in the <code>initializeWorkloadModule</code> function is of type <code>[ConnectorInterface](https://github.com/hyperledger-caliper/caliper/blob/v0.6.0/packages/caliper-core/lib/common/core/connector-interface.js)</code>. Its <code>getType()</code> function returns the <code>fabric</code> string value.</p> <p>The <code>sendRequests</code> method of the connector API allows the workload module to submit requests to the SUT. It takes a single parameter: an object or array of objects containing the settings of the requests.</p> <p>The settings object has the following structure:</p> <ul> <li><code>contract</code>: string. Required. The ID of the contract (that is the key specified here).</li> <li><code>readOnly</code>: boolean. Optional. Indicates whether the request is a TX or a query. Defaults to <code>false</code>.</li> <li><code>verb</code>: string. Required. The name of the function to call on the contract.</li> <li><code>value</code>: number. Optional. The value parameter in Wei to be passed to the payable function of the contract.</li> <li><code>args</code>: mixed[]. Optional. The list of arguments to pass to the method in the correct order as they appear in method signature. It must be an array.</li> </ul> <pre><code>let requestsSettings = [{\n    contract: 'simple',\n    verb: 'open',\n    value: 1000000000000000000000,\n    args: ['sfogliatella', 1000]\n},{\n    contract: 'simple',\n    verb: 'open',\n    value: 900000000000000000000,\n    args: ['baba', 900]\n}];\n\nawait this.sutAdapter.sendRequests(requestsSettings);\n</code></pre> <p>Currently each method call inside <code>sendRequests</code> is sent separately, that is, they are NOT sent as a batch of calls on RPC.</p> <p>To query a state on a contract state, set the <code>readOnly</code> attribute to <code>true</code>. The difference is that it can\u2019t produce any change on the blockchain and node will answer with its local view of data. Like for traditional requests, currently there is no support for batch queries.</p>"},{"location":"connectors/ethereum-config/#transaction-data-gathered-by-the-adapter","title":"Transaction Data Gathered by the Adapter","text":"<p>The previously discussed <code>sendRequests</code> method returns an array whose elements correspond to the result of the submitted request(s) with the type of TxStatus. The class provides some standard and platform-specific information about its corresponding transaction.</p> <p>The standard information provided by the type are the following:</p> <ul> <li><code>GetID():string</code> returns the transaction ID.</li> <li><code>GetStatus():string</code> returns the final status of the transaction, either <code>success</code> or <code>failed</code>.</li> <li><code>GetTimeCreate():number</code> returns the epoch when the transaction was submitted.</li> <li><code>GetTimeFinal():number</code> return the epoch when the transaction was finished.</li> <li><code>IsCommitted():boolean</code> indicates whether the transaction has been committed successfully.</li> <li><code>IsVerified():boolean</code> indicates whether we are sure about the final status of the transaction. Always true for successful transactions. False in all other cases.</li> <li><code>GetResult():any</code> returns the result of the transaction. Only requests with <code>readOnly</code> set to true will return the actual result of the call. Write operations, because they are asynchronous, will return the transaction hash.</li> </ul>"},{"location":"connectors/ethereum-config/#license","title":"License","text":"<p>The Caliper codebase is released under the Apache 2.0 license. Any documentation developed by the Caliper Project is licensed under the Creative Commons Attribution 4.0 International License. You may obtain a copy of the license, titled CC-BY-4.0, at http://creativecommons.org/licenses/by/4.0/.</p>"},{"location":"connectors/fabric-config/","title":"Fabric","text":""},{"location":"connectors/fabric-config/#overview","title":"Overview","text":"<p>This page introduces the Fabric adapter that utilizes the Common Connection Profile (CCP) feature of the Fabric SDK to provide compatibility and a unified programming model across different Fabric versions.</p> <p>Note</p> <p>The LTS versions of Hyperledger Fabric as well as the very latest 2.x release of Hyperledger Fabric are supported, all other versions are unsupported</p> <p>The adapter exposes many SDK features directly to the user callback modules, making it possible to implement complex scenarios.</p> <p>Note</p> <p>Some highlights of the provided features:</p> <ul> <li>supports multiple channels and chaincodes</li> <li>supports multiple organizations</li> <li>supports multiple identities</li> <li>private data collection support</li> <li>support for TLS and limited mutual TLS communication (identity certificates cannot have restrictions on them)</li> <li>option to select the identity for submitting a TX/query</li> </ul>"},{"location":"connectors/fabric-config/#installing-dependencies","title":"Installing dependencies","text":"<p>You must bind Caliper to a specific Fabric SDK to target the corresponding (or compatible) SUT version. Refer to the binding documentation for details. When you bind to an SUT, you are in fact selecting a specific Fabric SDK to use which could be used with different versions of Fabric SUTs.</p> <p>Note</p> <ul> <li>None of the Fabric bindings support administration actions. It it not possible to create/join channels nor deploy a chaincode. Consequently running caliper only facilitate operations using the <code>--caliper-flow-only-test</code> flag</li> </ul>"},{"location":"connectors/fabric-config/#binding-with-fabric-14-client-sdk","title":"Binding with Fabric 1.4 Client SDK","text":"<p>To bind with this client sdk, use <code>fabric:1.4</code>. Do not use this binding if using the BFT Concensus mechanism in Hyperledger Fabric that was introduced in version 3.0.0, use fabric:fabric-gateway instead.</p> <p>It is confirmed that a 1.4 Fabric SDK is compatible with a Fabric 2.2 and later Fabric 2.x SUTs, therefore this binding can be used with later Fabric SUTs</p> <p>Note that when using the binding target for the Fabric SDK 1.4 there are capability restrictions:</p> <p>Note</p> <ul> <li>Currently setting <code>discover</code> to <code>true</code> in the network configuration file is not supported if you don\u2019t enable the <code>gateway</code> option (eg specifying \u2013caliper-Fabric-gateway-enabled as a command line option)</li> <li>Detailed execution data for every transaction is only available if you don\u2019t enable the <code>gateway</code> option</li> </ul>"},{"location":"connectors/fabric-config/#binding-with-fabric-22-client-sdk","title":"Binding with Fabric 2.2 Client SDK","text":"<p>To bind with this client sdk, use <code>fabric:2.2</code>. Do not use this binding if using the BFT Concensus mechanism in Hyperledger Fabric that was introduced in version 3.0.0, use fabric:fabric-gateway instead.</p> <p>It is confirmed that a 2.2 Fabric SDK is compatible with 2.2 and later Fabric SUTs, therefore this binding can be used with 2.2 and later Fabric SUTs</p> <p>Note</p> <p>The following further restrictions exist for this binding:   - Detailed execution data for every transaction is not available.</p>"},{"location":"connectors/fabric-config/#binding-with-fabric-gateway-client-sdk","title":"Binding with Fabric Gateway Client SDK","text":"<p>To bind with this client sdk, use <code>fabric:fabric-gateway</code>. This is now the preferred SDK to use given that Fabric 2.2 and earlier are now not in LTS and as such the Fabric 1.4 and 2.2 SDKs are deprecated.</p> <p>Only Fabric 2.4 and later with the Peer Gateway capability enabled (which is the default setting for a Fabric peer) can be used so for older versions of Hyperledger Fabric you cannot bind with this client SDK.</p> <p>Note</p> <p>The following further restrictions exist for this binding - Detailed execution data for every transaction is not available. - mutual TLS is not supported - peer and organization targeting is not supported so the options <code>targetPeers</code> and <code>targetOrganizations</code> in a request will throw an error.</p>"},{"location":"connectors/fabric-config/#connection-profiles","title":"Connection Profiles","text":"<p>Connection Profiles are a Fabric standard that provides connectivity information for your Fabric network. In the past (Hyperledger Fabric 1.1) you needed to describe all your endpoints in a connection profile, ie all the orderers and all the peers in order to be able to connect a client application to the network. This is referred to as a <code>static</code> connection profile and when you use this connection profile with Caliper you should set the <code>discover</code> property to false. The problem with static connection profiles is that if a network topology changes (eg add/remove orderer, peer, organisation etc) then every client needs to have an updated connection profile.</p> <p>Hyperledger Fabric in 1.2 introduced the concept of discovery. This allowed you to ask a peer for the network topology. Your Fabric network has to be configured correctly for this to work (but all Fabric networks should be configured to allow for discovery now). Connection profiles that use this capability will only have a list of 1 or more peers for the specific organisation that connection profile applies to which will be used to discover the network. These connection profiles are referred to as <code>dynamic</code> connection profiles and when you use this connection profile with Caliper you should set the <code>discover</code> property to true.</p> <p>Network builders and providers should generate connection profiles (for example test-network in fabric-samples does this), however if you don\u2019t have a connection profile you will need to create one. Information about creating connection profiles can be found in Hyperledger Fabric documentation as well as the node-sdk documentation (the format changed between node sdks. The 1.4 version should work when binding to either Fabric 1.4 or 2.2 but the version documented by 2.2 may only work when binding to Fabric 2.2)</p> <ul> <li>node sdk 2.2 documentation for connection profiles</li> <li>node sdk 1.4 documentation for connection profiles</li> </ul> <p>Unfortunately the documentation provided by Hyperledger Fabric is more focused on static connection profiles rather than dynamic connection profiles and your aim should be to create the simpler and smaller dynamic connection profile.</p> <p>With the introduction of using the Peer Gateway rather than the traditional node sdks (1.4 and 2.2) caliper has introduced the concept of declaring peers in an organization within the network configuration file as an alternative to connection profiles. This provides a simple way to describe either peers to discover from (when binding to Fabric 1.4 or 2.2, for Fabric 1.4 you must enable the gateway option as it won\u2019t work otherwise as discovery is not supported with the Fabric 1.4 binding when the gateway option is not enabled) or the peer to be used as a gateway into the Fabric network (when binding to Fabric 2.4/fabric-gateway). An example of a peers section in the network configuration is</p> <pre><code>peers:\n      - endpoint: peer0.org3.example.com:7051\n        tlsCACerts:\n          pem: |-\n            -----BEGIN CERTIFICATE-----\n            ...\n            -----END CERTIFICATE-----\n        grpcOptions:\n          grpc.keepalive_timeout_ms: 20000\n          grpc.keepalive_time_ms: 120000\n          grpc.http2.min_time_between_pings_ms: 120000\n          grpc.http2.max_pings_without_data: 0\n          grpc.keepalive_permit_without_calls: 1\n</code></pre>"},{"location":"connectors/fabric-config/#runtime-settings","title":"Runtime settings","text":""},{"location":"connectors/fabric-config/#common-settings","title":"Common settings","text":"<p>Some runtime properties of the adapter can be set through Caliper\u2019s runtime configuration mechanism. For the available settings, see the <code>caliper.fabric</code> section of the default configuration file and its embedded documentation.</p> <p>The above settings are processed when starting Caliper. Modifying them during testing will have no effect. However, you can override the default values before Caliper starts from the usual configuration sources. In the following example the <code>localhost</code> property applies only when binding with Fabric 2.2 or Fabric 1.4 (and only if the <code>gateway</code> option is enabled)</p> <p>Note</p> <p>An object hierarchy in a configuration file generates a setting entry for every leaf property. Consider the following configuration file: <pre><code>caliper:\n    fabric:\n        gateway:\n          localhost: false\n</code></pre> After naming the project settings file <code>caliper.yaml</code> and placing it in the root of your workspace directory, it will override the following two setting keys with the following values:</p> <ul> <li>Setting <code>caliper-fabric-gateway-localhost</code> is set to false</li> </ul> <p>The other settings remain unchanged.</p> <p>Alternatively you can change this setting when you launch caliper with the CLI options of</p> <p><code>--caliper-fabric-gateway-localhost false</code></p>"},{"location":"connectors/fabric-config/#the-connector-api","title":"The connector API","text":"<p>The workload modules interact with the adapter at three phases of the tests: during the initialization of the user module (in the <code>initializeWorkloadModule</code> callback), when submitting invoke or query transactions (in the <code>submitTransaction</code> callback), and at the optional cleanup of the user module (in the <code>cleanupWorkloadModule</code> callback).</p>"},{"location":"connectors/fabric-config/#the-initializeworkloadmodule-function","title":"The <code>initializeWorkloadModule</code> function","text":"<p>See the corresponding documentation of the function for the description of its parameters.</p> <p>The last argument of the function is a <code>sutContext</code> object, which is a platform-specific object provided by the backend blockchain\u2019s connector. The context object provided by this connector is a <code>FabricConnectorContext</code> instance but this doesn\u2019t provide anything of use at this time.</p> <p>For the current details/documentation of the API, refer to the source code.</p>"},{"location":"connectors/fabric-config/#the-submittransaction-function","title":"The <code>submitTransaction</code> function","text":"<p>The <code>sutAdapter</code> object received (and saved) in the <code>initializeWorkloadModule</code> function is of type <code>[ConnectorInterface](https://github.com/hyperledger-caliper/caliper/blob/v0.6.0/packages/caliper-core/lib/common/core/connector-interface.js)</code>. Its <code>getType()</code> function returns the <code>fabric</code> string value.</p> <p>The <code>sendRequests</code> method of the connector API allows the workload module to submit requests to the SUT. It takes a single parameter: an object or array of objects containing the settings of the requests.</p> <p>The settings object has the following structure:</p> <ul> <li><code>contractId</code>: string. Required. The ID of the contract to call. This is either the unique contractID specified in the network configuration file or the chaincode ID used to deploy the chaincode and must match the id field in the contacts section of channels in the network configuration file.</li> <li><code>contractFunction</code>: string. Required. The name of the function to call in the contract.</li> <li><code>contractArguments</code>: string[]. Optional. The list of string arguments to pass to the contract.</li> <li><code>readOnly</code>: boolean. Optional. Indicates whether the request is a TX or a query. Defaults to <code>false</code>.</li> <li><code>transientMap</code>: Map. Optional. The transient map to pass to the contract. <li><code>invokerIdentity</code>: string. Optional. The name of the user who should invoke the contract. If not provided, a user will be selected from the organization defined by <code>invokerMspId</code> or the first organization in the network configuration file if that property is not provided.</li> <li><code>invokerMspId</code>: string. Optional. The mspid of the user organization who should invoke the contract. Defaults to the first organization in the network configuration file.</li> <li><code>targetPeers</code>: string[]. Optional. An array of endorsing peer names as the targets of the transaction proposal. If omitted, the target list will be chosen for you and if discovery is used then the node SDK uses discovery to determine the correct peers.</li> <li><code>targetOrganizations</code>: string[]. Optional. An array of endorsing organizations as the targets of the invoke. If both targetPeers and targetOrganizations are specified, then targetPeers will take precedence.</li> <li><code>channel</code>: string. Optional. The name of the channel on which the contract to call resides.</li> <li><code>timeout</code>: number. Optional. [Only applies to 1.4 binding when not enabling gateway use] The timeout in seconds to use for this request.</li> <li><code>orderer</code>: string. Optional. [Only applies to 1.4 binding when not enabling gateway use] The name of the target orderer for the transaction broadcast. If omitted, then an orderer node of the channel will be automatically selected.</li> <p>So invoking a contract looks like the following:</p> <pre><code>let requestSettings = {\n    contractId: 'marbles',\n    contractFunction: 'initMarble',\n    contractArguments: ['MARBLE#1', 'Red', '100', 'Attila'],\n    invokerIdentity: 'client0.org2.example.com',\n    timeout: 10\n};\n\nawait this.sutAdapter.sendRequests(requestSettings);\n</code></pre> <p>Note</p> <p><code>sendRequests</code> also accepts an array of request settings. However, Fabric does not support submitting an atomic batch of transactions like Sawtooth, so there is no guarantee that the order of these transactions will remain the same, or whether they will reside in the same block.</p>"},{"location":"connectors/fabric-config/#gathered-tx-data","title":"Gathered TX data","text":"<p>The previously discussed <code>sendRequests</code> function returns the result (or an array of results) for the submitted request(s) with the type of TxStatus. The class provides some standard and platform-specific information about its corresponding transaction.</p> <p>The standard data provided are the following: - <code>GetID():string</code> returns the transaction ID. - <code>GetStatus():string</code> returns the final status of the transaction, either <code>success</code> or <code>failed</code>. - <code>GetTimeCreate():number</code> returns the epoch when the transaction was submitted. - <code>GetTimeFinal():number</code> return the epoch when the transaction was finished. - <code>IsVerified():boolean</code> indicates whether we are sure about the final status of the transaction. Unverified (considered failed) transactions could occur, for example, if the adapter loses the connection with every Fabric event hub, missing the final status of the transaction. - <code>GetResult():Buffer</code> returns one of the endorsement results returned by the chaincode as a <code>Buffer</code>. It is the responsibility of the user callback to decode it accordingly to the chaincode-side encoding.</p> <p>The adapter also gathers the following platform-specific data (if observed) about each transaction, each exposed through a specific key name. The placeholders <code>&lt;P&gt;</code> and <code>&lt;O&gt;</code> in the key names are node names taking their values from the top-level peers and orderers sections from the network configuration file (e.g., <code>endorsement_result_peer0.org1.example.com</code>). The <code>Get(key:string):any</code> function returns the value of the observation corresponding to the given key. Alternatively, the <code>GetCustomData():Map&lt;string,any&gt;</code> returns the entire collection of gathered data as a <code>Map</code>.</p>"},{"location":"connectors/fabric-config/#available-data-keys-for-all-fabric-suts","title":"Available data keys for all Fabric SUTs","text":"<p>The adapter-specific data keys that are available when binding to any of the Fabric SUT versions are :</p> Key name Data type Description <code>request_type</code> string Either the <code>transaction</code> or <code>query</code> string value for traditional transactions or queries, respectively."},{"location":"connectors/fabric-config/#available-data-keys-for-the-fabric-14-sut-when-gateway-is-not-enabled","title":"Available data keys for the Fabric 1.4 SUT when gateway is not enabled","text":"<p>The adapter-specific data keys that only the v1.4 SUT when not enabling the gateway makes available are :</p> Key name Data type Description <code>time_endorse</code> number The Unix epoch when the adapter received the proposal responses from the endorsers. Saved even in the case of endorsement errors. <code>proposal_error</code> string The error message in case an error occurred during sending/waiting for the proposal responses from the endorsers. <code>proposal_response_error_&lt;P&gt;</code> string The error message in case the endorser peer <code>&lt;P&gt;</code> returned an error as endorsement result. <code>endorsement_result_&lt;P&gt;</code> Buffer The encoded contract invocation result returned by the endorser peer <code>&lt;P&gt;</code>. It is the user callback\u2019s responsibility to decode the result. <code>endorsement_verify_error_&lt;P&gt;</code> string Has the value of 'INVALID' if the signature and identity of the endorser peer <code>&lt;P&gt;</code> couldn\u2019t be verified. This verification step can be switched on/off through the runtime configuration options. <code>endorsement_result_error&lt;P&gt;</code> string If the transaction proposal or query execution at the endorser peer <code>&lt;P&gt;</code> results in an error, this field contains the error message. <code>read_write_set_error</code> string Has the value of 'MISMATCH' if the sent transaction proposals resulted in different read/write sets. <code>time_orderer_ack</code> number The Unix epoch when the adapter received the confirmation from the orderer that it successfully received the transaction. Note, that this isn\u2019t the actual ordering time of the transaction. <code>broadcast_error_&lt;O&gt;</code> string The warning message in case the adapter did not receive a successful confirmation from the orderer node <code>&lt;O&gt;</code>. <code>broadcast_response_error_&lt;O&gt;</code> string The error message in case the adapter received an explicit unsuccessful response from the orderer node <code>&lt;O&gt;</code>. <code>unexpected_error</code> string The error message in case some unexpected error occurred during the life-cycle of a transaction. <code>commit_timeout_&lt;P&gt;</code> string Has the value of <code>'TIMEOUT'</code> in case the event notification about the transaction did not arrive in time from the peer node <code>&lt;P&gt;</code>. <code>commit_error_&lt;P&gt;</code> string Contains the error code in case the transaction validation fails at the end of its life-cycle on peer node <code>&lt;P&gt;</code>. <code>commit_success_&lt;P&gt;</code> number The Unix epoch when the adapter received a successful commit event from the peer node <code>&lt;P&gt;</code>. Note, that transactions committed in the same block have nearly identical commit times, since the SDK receives them block-wise, i.e., at the same time. <code>event_hub_error_&lt;P&gt;</code> string The error message in case some event hub connection-related error occurs with peer node <code>&lt;P&gt;</code>. <p>You can access these data in your workload module after calling <code>sendRequests</code>:</p> <pre><code>let requestSettings = {\n    contractId: 'marbles',\n    contractVersion: '0.1.0',\n    contractFunction: 'initMarble',\n    contractArguments: ['MARBLE#1', 'Red', '100', 'Attila'],\n    invokerIdentity: 'client0.org2.example.com',\n    timeout: 10\n};\n\n// single argument, single return value\nconst result = await this.sutAdapter.sendRequests(requestSettings);\n\nlet shortID = result.GetID().substring(8);\nlet executionTime = result.GetTimeFinal() - result.GetTimeCreate();\nconsole.log(`TX [${shortID}] took ${executionTime}ms to execute. Result: ${result.GetStatus()}`);\n</code></pre>"},{"location":"connectors/fabric-config/#the-cleanupworkloadmodule-function","title":"The cleanupWorkloadModule function","text":"<p>The <code>cleanupWorkloadModule</code> function is called at the end of the round, and can be used to perform any resource cleanup required by your workload implementation.</p>"},{"location":"connectors/fabric-config/#network-configuration-file-reference","title":"Network configuration file reference","text":"<p>The YAML network configuration file of the adapter mainly describes the organizations and the identities associated with those organizations, It also provides explicit information about the channels in your Fabric network and the chaincode (containing 1 or more smart contracts) deployed to those channels. It can reference Common Connection Profiles for each organization (as common connection profiles are specific to a single organization). These are the same connection profiles that would be consumed by the node-sdk. Whoever creates the Fabric network and channels would be able to provide appropriate profiles for each organization.</p> <p>The following sections detail each part separately. For a complete example, please refer to the example section or one of the files in the Caliper repositor, such as the caliper-fabric test folder.</p> name Required. Non-empty string.     The name of the configuration file.    <pre><code>name: Fabric\n</code></pre> version Required. Non-empty string.      Specifies the YAML schema version that the Fabric SDK will use. Only the `'2.0.0'` string is allowed.    <pre><code>version: '2.0.0'\n</code></pre> caliper Required. Non-empty object.     Contains runtime information for Caliper. Can contain the following keys.    <ul> <li> blockchain Required. Non-empty string.           Only the <code>\"fabric\"</code> string is allowed for this adapter.          <pre><code>caliper:\n    blockchain: fabric\n</code></pre> </li> <li> sutOptions Required. Non-empty object.          These are sut specific options block, the following are specific to the Fabric implementation         <ul> <li> mutualTls Optional. Boolean.          Indicates whether to use client-side TLS in addition to server-side TLS. Cannot be set to <pre><code>true</code></pre> without using server-side TLS. Defaults to <pre><code>false</code></pre>.         <pre><code>caliper:\n    blockchain: fabric\n    sutOptions:\n      mutualTls: true\n</code></pre> </li> </ul> </li> <li> command Optional. Non-empty object.          Specifies the start and end scripts.          Note: <p>Must contain at least one of the following keys.</p> <ul> <li> start Optional. Non-empty string.                Contains the command to execute at startup time. The current working directory for the commands is set to the workspace.                <pre><code>caliper:\n  command:\n    start: my-startup-script.sh\n</code></pre> </li> <li> end Optional. Non-empty string.                Contains the command to execute at exit time. The current working directory for the commands is set to the workspace.                <pre><code>caliper:\n  command:\n    end: my-cleanup-script.sh\n</code></pre> </li> </ul> </li> </ul> info Optional. Object.      Specifies custom key-value pairs that will be included as-is in the generated report. The key-value pairs have no influence on the runtime behavior.     <pre><code> info:\n   Version: 1.1.0\n   Size: 2 Orgs with 2 Peers\n   Orderer: Solo\n   Distribution: Single Host\n   StateDB: CouchDB\n</code></pre> organizations Required. Non-empty object.    Contains information about 1 or more organizations that will be used when running a workload. Even in a multi-organization Fabric network, workloads would usually only be run from a single organization so it would be common to only see 1 organization defined. However it does support defining multiple organizations for which a workload can explicitly declare which organization to use. The first Organization in the network configuration will be the default organization if no explicit organization is requested.    <pre><code> organizations:\n- mspid: Org1MSP\n  identities:\n    wallet:\n      path: './org1wallet'\n      adminNames:\n      - admin\n    certificates:\n    - name: 'User1'\n      clientPrivateKey:\n        pem: |-\n          -----BEGIN PRIVATE KEY-----\n          ...\n          -----END PRIVATE KEY-----\n      clientSignedCert:\n        pem: |-\n          -----BEGIN CERTIFICATE-----\n          ...\n          -----END CERTIFICATE-----\n  connectionProfile:\n    path: './Org1ConnectionProfile.yaml'\n    discover: true\n- mspid: Org2MSP\n  connectionProfile:\n    path: './Org2ConnectionProfile.yaml'\n    discover: false\n  identities:\n    wallet:\n      path: './org2wallet'\n      adminNames:\n      - admin\n- mspid: Org3MSP\n  peers:\n    - endpoint: peer0.org3.example.com:7051\n      tlsCACerts:\n        pem: |-\n          -----BEGIN CERTIFICATE-----\n          ...\n          -----END CERTIFICATE-----\n      grpcOptions:\n        grpc.keepalive_timeout_ms: 20000\n        grpc.keepalive_time_ms: 120000\n        grpc.http2.min_time_between_pings_ms: 120000\n        grpc.http2.max_pings_without_data: 0\n        grpc.keepalive_permit_without_calls: 1\n</code></pre>    Each organization must have <code>mspid</code>, <code>identities</code> and either <code>connectionProfile</code> or <code>peers</code> provided and at least 1 certificate or wallet definition in the identities section so that at least 1 identity is defined   <ul> <li> mspid Required. Non-empty string.          The unique MSP ID of the organization.          <pre><code>organizations:\n  - mspid: Org1MSP\n</code></pre> </li> <li> connectionProfile Required if <code>peers</code> not provided. Non-empty object.          Reference to a Fabric network Common Connection Profile. These profiles are the same profiles that the Fabric SDKs would consume in order to interact with a Fabric network. A Common Connection Profile is organization specific so you need to ensure you point to a Common Connection Profile that is representative of the organization it is being included under. Connection Profiles also can be in 2 forms. A static connection profile will contain a complete description of the Fabric network, ie all the peers and orderers as well as all the channels that the organization is part of. A dynamic connection profile will contain a minimal amount of information usually just a list of 1 or more peers belonging to the organization (or is allowed to access) in order to discover the Fabric network nodes and channels.          <pre><code>organizations:\n  - mspid: Org1MSP\n    connectionProfile:\n      path: './test/sample-configs/Org1ConnectionProfile.yaml'\n      discover: true\n</code></pre> <li> path Required. Non-empty string.          The path to the connection profile file          <pre><code>organizations:\n  - mspid: Org1MSP\n    connectionProfile:\n      path: './test/sample-configs/Org1ConnectionProfile.yaml'\n</code></pre> </li> <li> discover Optional. Boolean.          This does not need to be provided when binding to the <pre><code>fabric-gateway</code> and will be ignored if provided and is relevant only for the 1.4 and 2.2 fabric bindings. A value of <pre><code>true</code> indicates that the connection profile is a dynamic connection profile and discovery should be used. If not specified then it defaults to <pre><code>false</code>. For a Fabric 1.4 binding you can only set this value to true if you plan to use the <pre><code>gateway</code> option.\n\n        <pre><code>organizations:\n  - mspid: Org1MSP\n    connectionProfile:\n      path: './test/sample-configs/Org1ConnectionProfile.yaml'\n      discover: true\n</code></pre>\n        \n        \n      \n    \n    <li>\n      \n        peers\n\n        Required if <code>connectionProfile</code> not provided. Non-empty object.\n        \n        Reference to one or more peers that are either\n        <ul>\n        <li>a peer to discover the network from when bound to Fabric 2.2 or Fabric 1.4 in conjunction with using the gateway enabled option\n        </li>\n        <li>a gateway peer when bound to Fabric gateway</li>\n        </ul>\n\n        This option removes the need for connection profiles but the Fabric network must be set up correctly to allow the network to be discovered. These entries are the equivalent of a dynamic connection profile but in a more compact and easier form.\n\n        <pre><code>organizations:\n  - mspid: Org3MSP\n    peers:\n      - endpoint: peer0.org3.example.com:7051\n        tlsCACerts:\n          pem: |-\n            -----BEGIN CERTIFICATE-----\n            ...\n            -----END CERTIFICATE-----\n        grpcOptions:\n          grpc.keepalive_timeout_ms: 20000\n          grpc.keepalive_time_ms: 120000\n          grpc.http2.min_time_between_pings_ms: 120000\n          grpc.http2.max_pings_without_data: 0\n          grpc.keepalive_permit_without_calls: 1\n</code></pre>\n        <li>\n        \n        endpoint\n\n        Required. Non-empty string.\n        \n        the end point of the peer in the form of <code>host:port</code> (note that you do not specify a schema such as grpc:// or grpcs://, in fact these schemas are not real and were invented purely for connection profiles). Whether the end point is secured by tls or not is determined by the presence of the <code>tlsCACerts</code> property\n\n        <pre><code>peers:\n  - endpoint: peer0.org3.example.com:7051\n</code></pre>\n        \n        </li>\n        <li>\n        \n        tlsCACerts\n        Optional. Non-empty object.\n        \n        Specifies the tls root certificate chain to verify a TLS connection with the peer by the client\n        \n          Note:\n          <p>Must contain at most one of the following keys.</p>\n        \n        <ul>\n        <li>\n        \n        path\n        Optional. Non-empty string.\n        \n        The path of the file containing the certificate chain.\n\n        <pre><code>tlsCACerts:\n  path: path/to/cert.pem\n</code></pre>\n\n        \n        </li>\n        <li>\n        \n        pem\n        Optional. Non-empty string.\n        \n        The content of the certificate file in exact PEM format (which must split into multiple lines for yaml or include escaped new lines for json).\n        <pre><code>tlsCACerts:\n   pem: |\n    -----BEGIN CERTIFICATE-----\n    ...\n    -----END CERTIFICATE-----\n</code></pre>\n        \n        </li>\n        </ul>\n        \n        </li>\n        <li>\n        \n        grpcOptions\n        Optional. Non-empty Object.\n        \n        A set of grpc specific options when creating a grpc connection to a peer.\n        <pre><code>peers:\n  - endpoint: peer0.org3.example.com:7051\n    grpcOptions:\n      grpc.keepalive_timeout_ms: 20000\n      grpc.keepalive_time_ms: 120000\n      grpc.http2.min_time_between_pings_ms: 120000\n      grpc.http2.max_pings_without_data: 0\n      grpc.keepalive_permit_without_calls: 1\n</code></pre>\n        \n        </li>\n\n      \n    </li>\n    <li>\n      \n        identities\n\n        Required. Non-empty object.\n        \n        Defines the location of 1 or more identities available for use. Currently only supports explicit identities by providing a certificate and private key as PEM or an SDK wallet that contains 1 or more identities on the file system. At least 1 identity must be provided via one of the child properties of identity.\n\n        <pre><code>identities:\n   wallet:\n     path: './wallets/org1wallet'\n     adminNames:\n     - admin\n   certificates:\n   - name: 'User1'\n     clientPrivateKey:\n       pem: |-\n         -----BEGIN PRIVATE KEY-----\n         ...\n         -----END PRIVATE KEY-----\n     clientSignedCert:\n       pem: |-\n         -----BEGIN CERTIFICATE-----\n         ...\n         -----END CERTIFICATE-----\n</code></pre>\n        <ul>\n        <li>\n        \n        certificates\n        Optional. A List of non-empty objects.\n        \n        Defines 1 or more identities by providing the PEM information for the client certificate and client private key as either an embedded PEM, a base64 encoded string of the PEM file contents or a path to individual PEM files\n\n        <pre><code>certificates:\n- name: 'User1'\n  clientPrivateKey:\n     path: path/to/privateKey.pem\n  clientSignedCert:\n     path: path/to/cert.pem\n- name: 'Admin'\n  admin: true\n  clientPrivateKey:\n   pem: |-\n    -----BEGIN PRIVATE KEY-----\n    MIGHAgEAMBMGByqGSM49AgEGCCqGSM49AwEHBG0wawIBAQQgIRZo3SAPXAJnGVOe\n    jRALBJ208m+ojeCYCkmJQV2aBqahRANCAARnoGOEw1k+MtjHH4y2rTxRjtOaKWXn\n    FGpsALLXfBkKZvxIhbr+mPOFZVZ8ztihIsZBaCuCIHjw1Tx65szJADcO\n    -----END PRIVATE KEY-----\n  clientSignedCert:\n   pem: |-\n     -----BEGIN CERTIFICATE-----\n    MIICSDCCAe+gAwIBAgIQfpGy5OOXBYpKZxg89x75hDAKBggqhkjOPQQDAjB2MQsw\n    CQYDVQQGEwJVUzETMBEGA1UECBMKQ2FsaWZvcm5pYTEWMBQGA1UEBxMNU2FuIEZy\n    YW5jaXNjbzEZMBcGA1UEChMQb3JnMS5leGFtcGxlLmNvbTEfMB0GA1UEAxMWdGxz\n    Y2Eub3JnMS5leGFtcGxlLmNvbTAeFw0xODA5MjExNzU3NTVaFw0yODA5MTgxNzU3\n    NTVaMHYxCzAJBgNVBAYTAlVTMRMwEQYDVQQIEwpDYWxpZm9ybmlhMRYwFAYDVQQH\n    Ew1TYW4gRnJhbmNpc2NvMRkwFwYDVQQKExBvcmcxLmV4YW1wbGUuY29tMR8wHQYD\n    VQQDExZ0bHNjYS5vcmcxLmV4YW1wbGUuY29tMFkwEwYHKoZIzj0CAQYIKoZIzj0D\n    AQcDQgAED4FM1+iq04cjveIDyn4uj90lJlO6rASeOIzm/Oc2KQOjpRRlB3H+mVnp\n    rXN6FacjOp0/6OKeEiW392dcdCMvRqNfMF0wDgYDVR0PAQH/BAQDAgGmMA8GA1Ud\n    JQQIMAYGBFUdJQAwDwYDVR0TAQH/BAUwAwEB/zApBgNVHQ4EIgQgPQRWjQR5EUJ7\n    xkV+zbfY618IzOYGIpfLaV8hdlZfWVIwCgYIKoZIzj0EAwIDRwAwRAIgYzk8553v\n    fWAOZLxiDuMN9RiHve1o5aAQad+uD+eLpxMCIBmv8CtXf1C60h/0zyG1D6tTTnrB\n    H8Zua3x+ZQn/kqVv\n    -----END CERTIFICATE-----\n- name: 'User3'\n  clientPrivateKey:\n   pem: LS0tLS1CRUdJTiBQUklWQVRFIEtFWS0tLS0tCk1JR0hBZ0VBTUJNR0J5cUdTTTQ5QWdFR0NDcUdTTTQ5QXdFSEJHMHdhd0lCQVFRZ0lSWm8zU0FQWEFKbkdWT2UKalJBTEJKMjA4bStvamVDWUNrbUpRVjJhQnFhaFJBTkNBQVJub0dPRXcxaytNdGpISDR5MnJUeFJqdE9hS1dYbgpGR3BzQUxMWGZCa0tadnhJaGJyK21QT0ZaVlo4enRpaElzWkJhQ3VDSUhqdzFUeDY1c3pKQURjTwotLS0tLUVORCBQUklWQVRFIEtFWS0tLS0tCg==\n  clientSignedCert:\n   pem: LS0tLS1CRUdJTiBDRVJUSUZJQ0FURS0tLS0tCk1JSUNXRENDQWY2Z0F3SUJBZ0lSQU1wU2dXRmpESE9vaFhhMFI2ZTlUSGd3Q2dZSUtvWkl6ajBFQXdJd2RqRUwKTUFrR0ExVUVCaE1DVlZNeEV6QVJCZ05WQkFnVENrTmhiR2xtYjNKdWFXRXhGakFVQmdOVkJBY1REVk5oYmlCRwpjbUZ1WTJselkyOHhHVEFYQmdOVkJBb1RFRzl5WnpFdVpYaGhiWEJzWlM1amIyMHhIekFkQmdOVkJBTVRGblJzCmMyTmhMbTl5WnpFdVpYaGhiWEJzWlM1amIyMHdIaGNOTWpBd09UQTNNVEUwTWpBd1doY05NekF3T1RBMU1URTAKTWpBd1dqQjJNUXN3Q1FZRFZRUUdFd0pWVXpFVE1CRUdBMVVFQ0JNS1EyRnNhV1p2Y201cFlURVdNQlFHQTFVRQpCeE1OVTJGdUlFWnlZVzVqYVhOamJ6RVpNQmNHQTFVRUNoTVFiM0puTVM1bGVHRnRjR3hsTG1OdmJURWZNQjBHCkExVUVBeE1XZEd4elkyRXViM0puTVM1bGVHRnRjR3hsTG1OdmJUQlpNQk1HQnlxR1NNNDlBZ0VHQ0NxR1NNNDkKQXdFSEEwSUFCTWRMdlNVRElqV1l1Qnc0WVZ2SkVXNmlmRkx5bU9BWDdHS1k2YnRWUERsa2RlSjh2WkVyWExNegpKV2ppdnIvTDVWMlluWnF2ME9XUE1NZlB2K3pIK1JHamJUQnJNQTRHQTFVZER3RUIvd1FFQXdJQnBqQWRCZ05WCiBIU1VFRmpBVUJnZ3JCZ0VGQlFjREFnWUlLd1lCQlFVSEF3RXdEd1lEVlIwVEFRSC9CQVV3QXdFQi96QXBCZ05WCkhRNEVJZ1FnNWZPaHl6d2FMS20zdDU0L0g0YjBhVGU3L25HUHlKWk5oOUlGUks2ZkRhQXdDZ1lJS29aSXpqMEUKQXdJRFNBQXdSUUloQUtFbnkvL0pZN0dYWi9USHNRSXZVVFltWHNqUC9iTFRJL1Z1TFg3VHpjZWZBaUJZb1N5WQp5OTByZHBySTZNcDZSUGlxalZmMDJQNVpDODZVa1AwVnc0cGZpUT09Ci0tLS0tRU5EIENFUlRJRklDQVRFLS0tLS0K\n</code></pre>\n        <ul>\n        <li>\n        \n        name\n        Required. Non-empty string.\n        \n        Specifies a name to associate with this identity. This name doesn\u2019t have to match anything within the certificate itself but must be unique\n\n        <pre><code>certificates:\n  - name: 'User1'\n</code></pre>\n        \n        <li>\n        \n        admin\n        Optional. Boolean.\n        \n        Indicates if this identity can be considered an admin identity for the organization. Defaults to false if not provided This only needs to be provided if you plan to create channels and/or install and instantiate contracts (chaincode)\n\n        <pre><code>certificates:\n  - name: 'User2'\n    admin: true\n</code></pre>\n        \n        <li>\n        \n        clientPrivateKey\n        Required. Non-empty object.\n        \n        Specifies the identity\u2019s private key for the organization.\n        \n          Note:\n          <p>Must contain at most one of the following keys.</p>\n        \n        <ul>\n        <li>\n        \n        path\n        Optional. Non-empty string.\n        \n        The path of the file containing the private key\n        <pre><code> clientPrivateKey:\n    path: path/to/cert.pem\n</code></pre>\n        \n        <li>\n        \n        pem\n        Optional. Non-empty string.\n        \n        The content of the private key file either in exact PEM format (which must split into multiple lines for yaml, or contain newline characters for JSON), or it could be a base 64 encoded version of the PEM (which will also encode the required newlines) as a single string. This single string format makes it much easier to embed into the network configuration file especially for a JSON based file\n        <pre><code>clientPrivateKey:\n   pem: |\n     -----BEGIN PRIVATE KEY-----\n      MIGHAgEAMBMGByqGSM49AgEGCCqGSM49AwEHBG0wawIBAQQgIRZo3SAPXAJnGVOe\n      jRALBJ208m+ojeCYCkmJQV2aBqahRANCAARnoGOEw1k+MtjHH4y2rTxRjtOaKWXn\n      FGpsALLXfBkKZvxIhbr+mPOFZVZ8ztihIsZBaCuCIHjw1Tx65szJADcO\n      -----END PRIVATE KEY-----\n</code></pre>\n        \n        \n        \n        <li>\n        \n        clientSignedCert\n        Required. Non-empty object.\n        \n        Specifies the identity\u2019s certificate for the organization.\n        \n          Note:\n          <p>Must contain at most one of the following keys.</p>\n        \n        <ul>\n        <li>\n        \n        path\n        Optional. Non-empty string.\n        \n        The path of the file containing the certificate\n        <pre><code> clientSignedCert:\n    path: path/to/cert.pem\n</code></pre>\n        \n        <li>\n        \n        pem\n        Optional. Non-empty string.\n        \n        The content of the certificate file either in exact PEM format (which must split into multiple lines for yaml, or contain newline characters for JSON), or it could be a base 64 encoded version of the PEM (which will also encode the required newlines) as a single string. This single string format makes it much easier to embed into the network configuration file especially for a JSON based file\n\n        <pre><code>clientSignedCert:\n   pem: |\n     -----BEGIN CERTIFICATE-----\n      MIICSDCCAe+gAwIBAgIQfpGy5OOXBYpKZxg89x75hDAKBggqhkjOPQQDAjB2MQsw\n      CQYDVQQGEwJVUzETMBEGA1UECBMKQ2FsaWZvcm5pYTEWMBQGA1UEBxMNU2FuIEZy\n      YW5jaXNjbzEZMBcGA1UEChMQb3JnMS5leGFtcGxlLmNvbTEfMB0GA1UEAxMWdGxz\n      Y2Eub3JnMS5leGFtcGxlLmNvbTAeFw0xODA5MjExNzU3NTVaFw0yODA5MTgxNzU3\n      NTVaMHYxCzAJBgNVBAYTAlVTMRMwEQYDVQQIEwpDYWxpZm9ybmlhMRYwFAYDVQQH\n      Ew1TYW4gRnJhbmNpc2NvMRkwFwYDVQQKExBvcmcxLmV4YW1wbGUuY29tMR8wHQYD\n      VQQDExZ0bHNjYS5vcmcxLmV4YW1wbGUuY29tMFkwEwYHKoZIzj0CAQYIKoZIzj0D\n      AQcDQgAED4FM1+iq04cjveIDyn4uj90lJlO6rASeOIzm/Oc2KQOjpRRlB3H+mVnp\n      rXN6FacjOp0/6OKeEiW392dcdCMvRqNfMF0wDgYDVR0PAQH/BAQDAgGmMA8GA1Ud\n      JQQIMAYGBFUdJQAwDwYDVR0TAQH/BAUwAwEB/zApBgNVHQ4EIgQgPQRWjQR5EUJ7\n      xkV+zbfY618IzOYGIpfLaV8hdlZfWVIwCgYIKoZIzj0EAwIDRwAwRAIgYzk8553v\n      fWAOZLxiDuMN9RiHve1o5aAQad+uD+eLpxMCIBmv8CtXf1C60h/0zyG1D6tTTnrB\n      H8Zua3x+ZQn/kqVv\n      -----END CERTIFICATE-----\n</code></pre>\n        \n        \n        \n        \n        \n        </li>\n        <li>\n        \n        wallet\n        Optional. Non-empty object.\n        \n        Provide the path to a file system wallet. Be aware that the persistence format used between v1.x and v2.x of the node sdks changed so make sure you provide a wallet created in the appropriate format for the version of SUT you bind to.\n        <ul>\n        <li>\n        \n        path\n        Required. Non-empty string.\n        \n        The path to the file system wallet\n        <pre><code>identities:\n  wallet:\n    path: './wallets/org1wallet'\n</code></pre>\n        \n        <li>\n        \n        adminNames\n        Optional. List of strings.\n        \n        1 or more names in the wallet that are identified as organization administrators. This only needs to be provided if you plan to create channels and/or install and instantiate contracts (chaincode)\n        <pre><code>identities:\n  wallet:\n    path: './wallets/org1wallet'\n    adminNames:\n    - admin\n    - another_admin\n</code></pre>\n        \n        \n        \n        </li>\n        \n      \n    </li>\n    </ul>\n\n\n\n  channels\n\n  Required. A list of objects.\n  \n  Contains one or more unique channels with associated information about the chaincode (contracts section) that will be available on the channel\n\n  <pre><code>channels:\n- channelName: mychannel\n  contracts:\n  - id: marbles\n    contractID: myMarbles\n\n- channelName: somechannel\n  contracts:\n  - id: basic\n</code></pre>\n  <ul>\n    <li>\n      \n        channelName\n\n        Required. Non-empty String.\n        \n        The name of the channel.\n\n        <pre><code>channels:\n  - channelName: mychannel\n</code></pre>\n      \n    </li>\n    <li>\n      \n        contracts\n        Required. Non-sparse array of objects.\n        \n        Each array element contains information about a chaincode deployed to the channel.\n        \n          Note:\n          <p>the <code>contractID</code> value of every contract in every channel must be unique on the configuration file level! If <code>contractID</code> is not specified for a contract then its default value is the <code>id</code> of the contract.</p>\n        \n\n        <pre><code>channels:\n  mychannel\n    contracts:\n    - id: simple\n    - id: smallbank\n</code></pre>\n        <li>\n        \n        id\n\n        Required. Non-empty string.\n        \n        The chaincode ID that was specified when the chaincode was deployed to the channel\n\n        <pre><code>channels:\n  mychannel\n    contracts:\n    - id: simple\n</code></pre>\n        \n        </li>\n        <li>\n        \n        contractID\n\n        Required. Non-empty string.\n        \n        The Caliper-level unique ID of the contract. This ID will be referenced from the user callback modules. Can be an arbitrary name, it won\u2019t effect the contract properties on the Fabric side.\n        \n        If omitted, it defaults to the <code>id</code> property value.\n\n        <pre><code>channels:\n  mychannel\n    contracts:\n    - id: simple\n    - contractID: simpleContract\n</code></pre>\n        \n        </li>\n      \n    </li>\n    </ul>"},{"location":"connectors/fabric-config/#network-configuration-example","title":"Network Configuration Example","text":"<p>The following example is a Fabric network configuration for the following network topology and artifacts:</p>\n<ul>\n<li>two organizations <code>Org1MSP</code> and <code>Org2MSP</code> (Note that having 2 organizations is not common in a network configuration file);</li>\n<li>one channel named <code>mychannel</code>;</li>\n<li><code>asset-transfer-basic</code> chaincode deployed to <code>mychannel</code> with a chaincode id of <code>basic</code>;</li>\n<li>the nodes of the network use TLS communication, but not mutual TLS;</li>\n<li>the Fabric samples test network is started and terminated automatically by Caliper;</li>\n</ul>\n<pre><code>name: Fabric\nversion: \"2.0.0\"\n\ncaliper:\n  blockchain: fabric\n  sutOptions:\n    mutualTls: false\n  command:\n    start: ../fabric-samples/test-network/network.sh up createChannel &amp;&amp; ../fabric-samples/test-network/network.sh deployCC -ccp ../fabric-samples/asset-transfer-basic/chaincode-javascript -ccn basic -ccl javascript\n    end: ../fabric-samples/test-network/network.sh down\n\ninfo:\n  Version: 1.1.0\n  Size: 2 Orgs\n  Orderer: Raft\n  Distribution: Single Host\n  StateDB: GoLevelDB\n\nchannels:\n  - channelName: mychannel\n    contracts:\n    - id: basic\n      contractID: BasicOnMyChannel\n\norganizations:\n  - mspid: Org1MSP\n    identities:\n      certificates:\n      - name: 'admin.org1.example.com'\n        admin: true\n        clientPrivateKey:\n          pem: |-\n            -----BEGIN PRIVATE KEY-----\n            ...\n            -----END PRIVATE KEY-----\n        clientSignedCert:\n          pem: |-\n            -----BEGIN CERTIFICATE-----\n            ...\n            -----END CERTIFICATE-----\n    connectionProfile:\n      path: './Org1ConnectionProfile.yaml'\n      discover: true\n  - mspid: Org2MSP\n    connectionProfile:\n    identities:\n      certificates:\n      - name: 'admin.org2.example.com'\n        admin: true\n        clientPrivateKey:\n          pem: |-\n            -----BEGIN PRIVATE KEY-----\n            ...\n            -----END PRIVATE KEY-----\n        clientSignedCert:\n          pem: |-\n            -----BEGIN CERTIFICATE-----\n            ...\n            -----END CERTIFICATE-----\n      path: './Org2ConnectionProfile.json'\n      discover: true\n</code></pre>\n<p>Another example with only a single organization but using the peers property so everything required is contained in a single network configuration file:</p>\n<pre><code>name: Fabric\nversion: \"2.0.0\"\n\ncaliper:\n  blockchain: fabric\n  sutOptions:\n    mutualTls: false\n\nchannels:\n  - channelName: mychannel\n    contracts:\n    - id: basic\n\norganizations:\n  - mspid: Org1MSP\n    identities:\n      certificates:\n      - name: 'admin.org1.example.com'\n        admin: true\n        clientPrivateKey:\n          pem: |-\n            -----BEGIN PRIVATE KEY-----\n            ...\n            -----END PRIVATE KEY-----\n        clientSignedCert:\n          pem: |-\n            -----BEGIN CERTIFICATE-----\n            ...\n            -----END CERTIFICATE-----\n    peers:\n      - endpoint: peer0.org1.example.com:7051\n        grpcOptions:\n          ssl-target-name-override: peer0.org1.example.com\n          grpc.keepalive_time_ms: 600000\n        tlsCACerts:\n          pem: |-\n            -----BEGIN CERTIFICATE-----\n            ...\n            -----END CERTIFICATE-----\n</code></pre>"},{"location":"connectors/fabric-config/#license","title":"License","text":"<p>The Caliper codebase is released under the Apache 2.0 license. Any documentation developed by the Caliper Project is licensed under the Creative Commons Attribution 4.0 International License. You may obtain a copy of the license, titled CC-BY-4.0, at http://creativecommons.org/licenses/by/4.0/.</p>"},{"location":"connectors/writing-connectors/","title":"Writing Connectors","text":""},{"location":"connectors/writing-connectors/#overview","title":"Overview","text":"<p>Connectors are probably the most important modules in Caliper. They provide an abstraction layer between the system under test (SUT) and the different Caliper components (e.g., the manager and workers processes, or the workload modules). A connector\u2019s job is to simplify interaction with the SUT as much as possible, hiding any peculiarities behind its API.</p> <p>Note</p> <p>To get a sense of how a connector fits into the Caliper architecture, see the corresponding architecture documentation sections about multi-platform support, the manager process and the worker processes.</p> <p>Caliper ships with some predefined/built-in connectors, but in general, connectors are treated as pluggable components (just like resource and TX monitors, workload modules, etc.). So nothing stops you from implementing and using your 3<sup>rd</sup> party connector! However, we strongly recommend that you absorb every part of this guide before implementing a new connector.</p>"},{"location":"connectors/writing-connectors/#requirements-for-quality-connectors","title":"Requirements for quality connectors","text":"<p>A connector\u2019s complexity is usually proportional to the complexity of the SUT (and/or its programming model). Accordingly, connectors are considered heavy-weight components compared to other extension points in Caliper.</p> <p>There are a few things to keep in mind when implementing a connector. Some are technical, some impact usability.</p> <p>Note</p> <p>Caliper does not constrain the types of SUT you can test. Accordingly, the following points are general guidelines for connectors targeting complex distributed systems. You are allowed to deviate from the advices, but you should probably document such choices to lower the surprise factor for end-users.</p> <ol> <li>Keep to the predefined interface.</li> <li>You must implement the given interface so Caliper modules can interact with the connector.</li> <li>If you expose additional capabilities outside of the interface, then you will disrupt the programming model of workload module developers. They will have to handle your extra API as a separate case, complicating the development of cross-platform benchmarks However, if you are implementing a workload module to performance test a specific SUT, then this is not a concern.</li> <li> <p>If your connector behaves similarly to other connectors following this guide, users will be quick to adapt and experiment with your connector/SUT.</p> </li> <li> <p>Consider the distributed nature of the SUT.</p> </li> <li>Distributed systems consist of multiple nodes, sometimes with different roles.</li> <li>You probably don\u2019t want the connector to be just a proxy for a single SUT node. The connector should be aware of as many SUT nodes as it makes sense to support features like load balancing or SUT-specific request execution policies.</li> <li>Hide the network topology as much as you can from other Caliper modules, especially from workload modules. Most of the time an emulated client does not care about the receiving end of a request as long as it\u2019s executed.</li> <li> <p>If you must expose certain nodes to the workload modules, then do that through simple (preferably text-based) handles. But do not expose implementation-specific classes representing the nodes!</p> </li> <li> <p>Consider the actors in the SUT.</p> </li> <li>Authentication and authorization are cornerstones for almost every remote system, thus handling digital identities (that can come in many forms) must be a first-class feature in connectors.</li> <li>Similarly to the nodes in the SUT, there will be many actors/clients with different privileges initiating different requests. A connector should be able to impersonate multiple clients to allow for diverse client behaviors in workload modules.</li> <li> <p>A connector should allow for easy switching between client identities for each request, thus the connector must expose the identities towards the workload modules somehow. The same advice applies as for the nodes: use simple (preferably text-based) handles, but do not expose implementation-specific classes representing the identities!</p> </li> <li> <p>Do not reinvent the wheel.</p> </li> <li>Each system exposes a standard remote API for communicating with clients. These APIs can take many forms (REST, gRPC, etc.). Regardless of the used API technology, there\u2019s probably a mature client library for it. Or even better, the target platform has its own SDK!</li> <li> <p>A connector shouldn\u2019t bother with network-level communication and such low-level details. Delegate such tasks to the SDKs or client libraries. This will allow your connector to be more robust and to attract additional contributors familiar with the used libraries.</p> </li> <li> <p>Do not be the bottleneck.</p> </li> <li>The purpose of Caliper is to performance test the SUT from the client\u2019s point-of-view.</li> <li>If assembling and sending a request takes time in the same order of magnitude as executing the request, then the results won\u2019t be representative. Sending requests is considered a hot path for connectors, and it should be as efficient as possible.</li> <li>Using SDKs and widely known client libraries is an exception. Real client-side applications will probably do the same, so the library overheads must be incorporated into the request latencies. Do not micro-optimize by writing your own special-purpose SDK, just to push down the latency numbers!</li> <li>Connector bottlenecks on the hot path will influence/limit the request output rate of Caliper worker processes. Caliper users won\u2019t be happy if they have to launch 10 worker processes just to send 100 requests per second to the SUT.</li> </ol> <p>Note</p> <p>A connector\u2019s job is to bridge the platform-agnostic Caliper-side API with the high-level SUT-specific client library, while adhering to the above points.</p>"},{"location":"connectors/writing-connectors/#implementing-the-connector","title":"Implementing the connector","text":"<p>You should treat a connector implementation process as a full-fledged Node.js project. Refer to the Caliper integration section for the suggested project structure. Putting the project structure aside, you have four implementation-related tasks:</p> <ol> <li>Implement the connector interface (optionally using the available utility base class).</li> <li>Implement a factory method for instantiating the connector.</li> <li>Define the schema of your network configuration file.</li> <li>Provide binding configurations for your connector.</li> </ol>"},{"location":"connectors/writing-connectors/#the-connector-interface","title":"The connector interface","text":"<p>Once you add the <code>@hyperledger/caliper-core</code> package (or one of its specific versions) as your project dependency, you will gain access to its exported <code>ConnectorInterface</code> class, which declares the following interface:</p> <pre><code>class ConnectorInterface extends EventEmitter {\n    getType() {}\n    getWorkerIndex() {}\n    async init(workerInit) {}\n    async installSmartContract() {}\n    async prepareWorkerArguments(number) {}\n    async getContext(roundIndex, args) {}\n    async releaseContext() {}\n    async sendRequests(requests) {}\n}\n\nmodule.exports = ConnectorInterface;\n</code></pre> <p>The interface is detailed in the next subsection, but for now, keep the following things in mind:</p> <ol> <li>The connector is used in two different environments: in the manager and worker processes. The corresponding environment of the methods will be discussed in the interface reference subsection.</li> <li>The connector must expose certain events about the requests, otherwise it\u2019s not observable by the Caliper workers, which breaks the scheduling mechanism of Caliper.</li> <li><code>sendRequests</code> is the hot path for the interface, implement it carefully and efficiently!</li> <li>The behavior of the connector (and the methods to really implement) largely depends on the capabilities of the network configuration schema. The more flexibility you allow on the Caliper-side of the network, the more features you will have to provide. A flexible connector makes it easier to setup benchmark scenarios, resulting in happy users.</li> </ol>"},{"location":"connectors/writing-connectors/#interface-reference","title":"Interface reference","text":"<p><code>getType</code></p> <ul> <li>Description Retrieves a short name for the connector type, usually denoting the SUT, e.g., <code>fast-ledger</code>. The name can be used by workload modules capable of targeting multiple types of SUT.</li> <li>Return type string</li> <li>Returns The name of the connector.</li> </ul> <p><code>getWorkerIndex</code></p> <ul> <li>Description Retrieves the zero-based worker process index that instantiated the connector.</li> <li>Return type number</li> <li>Returns The worker process index.</li> </ul> <p><code>init</code></p> <ul> <li>Description The method is called by both the manager and (optionally) the worker processes to initialize the connector instance, and potentially certain aspects of the SUT. The initialization tasks are connector-specific, but usually can be divided among the processes:<ul> <li>The manager process instance performs one-time initialization tasks that require interaction with the SUT. Such tasks can include, for example, the creation of digital identities, or other housekeeping actions regarding the SUT.</li> <li>The worker process instances usually just perform local housekeeping tasks, like creating the necessary data structures or caches needed later on when sending requests. This step is optional and can be performed by your factory method after creating the connector instance. If the worker processes need to access the SUT in this phase, then they should do so using only idempotent operations (like configuration queries) that guarantee correct execution for arbitrary number of parallel worker processes.</li> </ul> </li> <li>Parameters<ul> <li>workerInit (boolean) Denotes whether the method is called by a worker process, or by the manager process.</li> </ul> </li> <li>Return type Promise</li> <li>Returns The promise that will resolve upon method completion.</li> </ul> <p><code>installSmartContract</code></p> <ul> <li>Description The method is called by the manager process to perform contract deployment on the SUT, if allowed remotely.</li> <li>Return type Promise</li> <li>Returns The promise that will resolve upon method completion.</li> </ul> <p><code>prepareWorkerArguments</code></p> <ul> <li>Description This method is called by the manager process, and ensures that the connector instance in the manager process can distribute data to the connector instances in the worker processes. This method is the perfect place to return, for example, newly created digital identities to the manager process, which in turn will distribute them to the worker process instances for further use.</li> <li>Return type Promise&lt;object[]&gt;</li> <li>Returns The promise of connector-specific objects for each worker that will resolve upon method completion.</li> </ul> <p><code>getContext</code></p> <ul> <li>Description: The method is called by the worker processes before each round, and can be used to assemble a connector-specific object that will be shared with the workload module of the current round. The method is also the perfect place to claim resources necessary for the next round, like establishing connections to remote nodes.</li> <li>Parameters:</li> <li>roundIndex (number): The zero-based index of the imminent round.</li> <li>args (object): The object assembled for this worker instance in the <code>prepareWorkerArguments</code> method of the manager instance.</li> <li>Return type: Promise&lt;object&gt;</li> <li>Returns: The promise of a connector-specific object that will resolve upon method completion.</li> </ul> <p><code>releaseContext</code></p> <ul> <li>Description: The method is called by the worker processes after each round, and can be used to release resources claimed in the <code>getContext</code> method.</li> <li>Return type: Promise</li> <li>Returns: The promise that will resolve upon method completion.</li> </ul> <p><code>sendRequests</code></p> <ul> <li>Description: This method is the hot path of the connector, called in the worker processes by the workload modules of the rounds. The method must accept one or multiple settings objects pertaining to the request or requests that must be sent to the SUT. The connector doesn\u2019t have to preserve the order of execution for the requests, unless the target SUT type supports such request batches. The connector must gather at least the start time, finish time, and final status (successful or failed) of every request through TxStatus instances.</li> <li>Return type: Promise <li>Returns: The promise of one or more request execution results that will resolve upon method completion.</li>"},{"location":"connectors/writing-connectors/#exposed-events","title":"Exposed events","text":"<p>The connector must expose the following events with names matching the defined constants for them. Without these events the Caliper scheduling mechanism won\u2019t function correctly, and other components might also rely on them (like TX monitors).</p> <p><code>txsSubmitted</code></p> <ul> <li>Description The event must be raised when one or more requests are submitted for execution to the SUT. Typically the event should be raised for every individual request.</li> <li>Parameters<ul> <li>count (number) The number of requests submitted.</li> </ul> </li> </ul> <p><code>txsFinished</code></p> <ul> <li>Description The event must be raised when one or more requests are fully processed by the SUT (i.e., the connector received the results).</li> <li>Parameters<ul> <li>results (TxStatus|TxStatus[]) One or more request execution result gathered by the connector.   </li> </ul> </li> </ul>"},{"location":"connectors/writing-connectors/#optional-base-class","title":"Optional base class","text":"<p>The <code>@hyperledger/caliper-core</code> package also exports a <code>ConnectorBase</code> class that provides sensible default implementations for the following <code>ConnectorInterface</code> methods:</p> <ul> <li><code>prepareWorkerArguments</code>: An empty object is returned for each worker by default, i.e., nothing is shared with the worker process instances.</li> <li><code>sendRequests</code>: Handles the cases when a single or multiple requests are submitted by the workload modules. Also raises the necessary events before and after the requests. The method delegates the execution of a single request to the <code>_sendSingleRequest</code> method (see below).</li> <li><code>constructor</code>: Declares a constructor that requires the worker index and SUT/connector type as parameters.</li> <li><code>getType</code>: Provides a simple getter for the corresponding constructor argument.</li> <li><code>getWorkerIndex</code>: Provides a simple getter for the corresponding constructor argument.</li> </ul> <p>If you opt in to use this base class for your connector then you must implement the <code>_sendSingleRequest</code> method.</p> <p><code>_sendSingleRequest</code></p> <ul> <li>Description The method only has to handle the sending and processing of a single request.</li> <li>Parameters<ul> <li>request (object) A connector-specific settings object for the request.</li> </ul> </li> <li>Return type Promise <li>Returns The promise of a request execution result that will resolve upon method completion.</li>"},{"location":"connectors/writing-connectors/#the-factory-method","title":"The factory method","text":"<p>The entry point for your connector implementation will be a factory method. The manager and worker processes will call this exported factory method to instantiate your connector (be careful with the casing).</p> <p><code>ConnectorFactory</code> - Description Instantiates a connector and optionally initializes it. When called from the manager process (denoted with a worker index of <code>-1</code>), the manager will handle calling the <code>init</code> and <code>installSmartContracts</code> methods. This initialization is optional in the worker processes, so the factory method must handle it if required. - Parameters     - workerIndex (number) The zero-based index of the worker process, or <code>-1</code> for the manager process. - Return type Promise - Returns The promise of a <code>ConnectorInterface</code> instance that will resolve upon method completion. <p>The following is a possible implementation of a factory method for our <code>fast-ledger</code> connector:</p> <pre><code>    'use strict';\n\n    const FastLedgerConnector = require('./fast-ledger-connector');\n\n    async function ConnectorFactory(workerIndex) {\n        const connector = new FastLedgerConnector(workerIndex, 'fast-ledger');\n\n        // initialize the connector for the worker processes\n        if (workerIndex &gt;= 0) {\n            await connector.init(true);\n        }\n\n        return connector;\n    }\n\n    module.exports.ConnectorFactory = ConnectorFactory;\n</code></pre>"},{"location":"connectors/writing-connectors/#the-network-configuration-file","title":"The network configuration file","text":"<p>The network configuration file can contain whatever information your connector requires to communicate with the SUT and fulfill the connector quality requirements. The configuration file can be either a JSON or YAML file. YAML is preferred for its readability and comment support.</p> <p>The network configuration schema must contain a mandatory top-level field with the following structure:</p> <pre><code># mandatory\ncaliper:\n  # mandatory\n  blockchain: fast-ledger\n  # optional\n  commands:\n    start: startLedger.sh\n    end: stopLedger.sh\n</code></pre> <p>The <code>caliper.blockchain</code> attribute tells Caliper which connector to load for the test. The value of the attribute depends on how you want to integrate the connector with Caliper.</p>"},{"location":"connectors/writing-connectors/#binding-configuration","title":"Binding configuration","text":"<p>The binding command of Caliper allows you to specify major connector dependencies to be installed during runtime (instead of packaged with the connector during development time). SUT SDKs and other client libraries usually fall into this category (i.e., libraries that facilitate interactions with the SUT). If the APIs of such libraries are consistent across different versions, then your single connector implementation can possibly target multiple SUT versions.</p> <p>In that case, users should be able to select a specific SDK version that will target the corresponding SUT version. You can achieve this by providing a binding configuration file (JSON or YAML) for your connector.</p>"},{"location":"connectors/writing-connectors/#simple-configuration","title":"Simple configuration","text":"<p>The schema of a general binding configuration is usually simple:</p> <pre><code>sut:\n  fast-ledger:\n    1.0:\n      packages: ['fast-ledger-sdk@1.0.0']\n    1.4:\n      packages: ['fast-ledger-sdk@1.4.5']\n    2.0: &amp;fast-ledger-latest\n      packages: ['fast-ledger-sdk@2.0.0']\n    latest: *fast-ledger-latest\n</code></pre> <p>Several things to note about the above configuration:</p> <ol> <li>The <code>sut</code> top-level attribute denotes the configuration section that Caliper will process. You can write arbitrary YAML sections outside of this attribute, without any schema constraints. This means you can utilize, for example, YAML anchors and aliases to improve the readability of your complex binding specification. You will see an example soon.</li> <li>The <code>sut</code> attribute contains keys that identify the SUT types whose connector supports binding. We defined a single SUT type (<code>fast-ledger</code>) for our example connector.</li> <li>Under <code>fast-ledger</code> we can define several SUT versions our connector supports. It\u2019s recommended to use keys corresponding to the semantic version of the SUT. The users will specify the binding using the SUT type and SUT version, for example, by passing the <code>--caliper-bind-sut fast-ledger:1.4</code> command line argument to Caliper.</li> <li>Every SUT version needs to declare the required <code>packages</code> Caliper should install during runtime. The different SUT versions will usually declare different SDK version to install.</li> <li>Even though we declared <code>1.4</code> as SUT version, we asked Caliper to install the <code>1.4.5</code> SDK version. It\u2019s good practice to always bind to the latest available patch release, so users can enjoy the latest bug fixes for an SDK version.</li> <li>Many library management systems (like NPM and DockerHub) provide <code>latest</code> tags to denote the newest release. If you provide such a binding \u201cversion\u201d for your connector, then users can bind your connector by using the simplified <code>--caliper-bind-sut fast-ledger</code> notation. You can easily refer to the binding version you deem latest using YAML anchors and aliases. Doing so will make your configuration easier to read and maintain.</li> </ol>"},{"location":"connectors/writing-connectors/#advanced-configuration","title":"Advanced configuration","text":"<p>Even though your connector supports multiple SUT versions on the implementation level, that doesn\u2019t mean that all versions can be equally supported in the same environment. A typical example would be to support older SUT versions, whose corresponding SDK packages fail to build \u201cautomagically\u201d under newer Node.js version. The binding configuration provides some flexibility to tune the installation of these packages.</p> <p>Node modules can include native components which may have to be compiled on the system it will run on and against the specific version of node that is being used (some package owners make precompiled versions for specific platforms and versions of node available to download to avoid having to perform a local compilation). This means you will have to have appropriate compilers installed. Moreover, the used compiler is strict by default, resulting in multiple compilation errors.</p> <p>To circumvent such hardships, the binding configuration schema allows us to tinker with the install process by specifying command line arguments and environment variables (picked up by <code>npm install</code>). You can put such install logic under the <code>settings</code> attribute.</p> <pre><code>sut:\n  fast-ledger:\n    1.0:\n      packages: ['fast-ledger-sdk@1.0.0', 'comm-lib@1.0.0']\n      settings:\n      # compiling older comm-lib on newer Node.js version\n      - versionRegexp: '^((?!v8\\.).)*$'\n        env:\n          CXXFLAGS: '-Wno-error=class-memaccess'\n          CFLAGS: '-Wno-error=class-memaccess'\n        args: '--build-from-source'\n</code></pre> <p>The <code>settings</code> attribute is actually an array of potentially applicable settings. Caliper will process them in order, and picks the first settings object whose regular expression (<code>versionRegexp</code>) matches the used Node.js version. The example demonstrates a setting that should be applied if a newer Node.js version is used (i.e., the version is not <code>v8.X</code>). If that is the case, then pass the command line arguments (specified by <code>args</code>) to <code>npm install</code>, and also set the environment variables specified under <code>env</code> (which will also be picked up by <code>npm install</code> and any sub-command executed by it).</p> <p>Your connector can use such advanced specification to provide support for a wide range of SUT/SDK versions in multiple environments.</p>"},{"location":"connectors/writing-connectors/#documenting-the-connector","title":"Documenting the connector","text":"<p>Providing proper user manual for your connector is just as important as a quality implementation. Otherwise, users will have a hard time interacting with your connector. We will take the Fabric connector documentation as an example, section by section.</p>"},{"location":"connectors/writing-connectors/#overview_1","title":"Overview","text":"<p>You should provide a short summary of your connector. This should include the following:</p> <ul> <li>The supported SUT type and versions.</li> <li>The capabilities of your connector (supported SUT features and limitations).</li> </ul> <p>The overview will lay down the foundation of what users can expect from your connector.</p>"},{"location":"connectors/writing-connectors/#installing-dependencies","title":"Installing dependencies","text":"<p>If your connector supports multiple SUT versions through the binding process, then document the necessary steps to bind to a specific version. The binding process is universal for every connector, so a short example should suffice.</p> <p>However, it can happen that not every SUT feature is supported by every binding. Carefully document the limitations of the affected bindings, and provide some workaround if possible.</p>"},{"location":"connectors/writing-connectors/#runtime-settings","title":"Runtime settings","text":"<p>The network configuration file only describes the SUT topology and related artifacts. SUT-agnostic design choices can still arise during the development of a connector. Instead of deciding yourself, you should delegate such choices to the end users utilizing the runtime configuration mechanism of Caliper where possible/meaningful.</p> <p>Such settings typically affect the operating mode of the connector, but don\u2019t change the overall semantics of the SUT interactions. Be sure to document every available runtime setting for your connector! Also, don\u2019t forget to provide sensible defaults to these settings where possible.</p>"},{"location":"connectors/writing-connectors/#request-api","title":"Request API","text":"<p>The main users of your connector will be workload module developers. They will interact with your connector mainly through the <code>[sendRequests](#interface-reference)</code> method. The method accepts either a single, or multiple settings object relating to the requests the user wants to send. You have to precisely specify what kind of settings are available for a request. These will typically include:</p> <ul> <li>The operation to execute on the SUT.</li> <li>The arguments of the operation.</li> <li>The identity who should submit the request.</li> <li>The node(s) to send the request to.</li> <li>Differentiation between read-only/write requests.</li> </ul>"},{"location":"connectors/writing-connectors/#gathered-request-data","title":"Gathered request data","text":"<p>Your connector must report basic execution data towards Caliper to ensure correct reporting. But you are also free to collect any kind of client-side data you have access to. Who knows what data users will find useful. Make sure to document such collected data (both semantics and data types).</p>"},{"location":"connectors/writing-connectors/#network-configuration-file","title":"Network configuration file","text":"<p>The probably most important piece of your documentation is the schema of the network configuration file your connector can process. Try to provide an intuitive structure for defining the network topology, participants and any required artifacts. You should document the semantics and data types of different settings. Be sure to document any constraints that could arise between multiple attributes (mutual exclusion, valid values, etc.).</p>"},{"location":"connectors/writing-connectors/#example-network-configuration","title":"Example network configuration","text":"<p>Be sure to provide a fully specified and functioning network configuration example. For some, it is easier to absorb a concrete example than a reference-style documentation.</p>"},{"location":"connectors/writing-connectors/#integration-with-caliper","title":"Integration with Caliper","text":"<p>Once you\u2019ve implemented your connector, you have two choices to integrate it with Caliper:</p> <ol> <li>Use it as a 3<sup>rd</sup> party, pluggable component, which is part of your benchmark project.</li> <li>Contribute your connector to the official Caliper code-base, so it\u2019s always installed together with Caliper.</li> </ol>"},{"location":"connectors/writing-connectors/#3rd-party-connector","title":"3<sup>rd</sup> party connector","text":"<p>You can easily plug in your connector dynamically without it being part of the Caliper code-base. The process is the following:</p> <ol> <li>Create an <code>index.js</code> file in your project that will export your connector factory. The file provides a clean entry point for your connector:</li> </ol> <pre><code>'use strict';\nmodule.exports.ConnectorFactory = require('./lib/connectorFactory').ConnectorFactory;\n</code></pre> <ol> <li>Set the <code>./fast-ledger/index.js</code> path for the <code>caliper.blockchain</code> attribute in your network configuration file. The path should be relative to the Caliper workspace directory, or an absolute path (not recommended for portability reasons). Caliper will load the module and the factory method from this path.</li> <li>If you support different bindings, then prepare a binding configuration file for your connector.</li> <li>When you launch Caliper, your connector implementation will be picked up through your network configuration file.</li> <li>You can specify your custom binding configuration using, for example, the <code>--caliper-bind-file ./fast-ledger-binding.yaml</code> command line argument that points to your custom file. Don\u2019t forget to also specify the binding itself with <code>--caliper-bind-sut fast-ledger:1.0</code>.</li> </ol> <p>Alternatively, you can set your <code>caliper.blockchain</code> attribute to an NPM package name if you published your connector. In that case, you must ensure that the package is installed in the Caliper workspace directory prior to running the benchmark. The recommended naming convention for packages is <code>caliper-sut</code>. For our example, the caliper.blockchain attribute would be set to <code>caliper-fast-ledger</code>.</p> <p>Note</p> <p>Until Caliper reaches its first major version, it is recommended to version your connector package based on which <code>@hyperledger/caliper-core</code> version you depend on. </p>"},{"location":"connectors/writing-connectors/#built-in","title":"Built-in","text":"<p>Note</p> <p>By contributing a connector to the code-base, you also accept the responsibility of maintaining the connector when needed. Otherwise, it might become stale and deprecated in future releases. </p> <p>If you would like to expose you connector to a wider user-base, then you should contribute your code to the official Caliper repository, so your connector becomes a built-in module, immediately available when someone installs Caliper.</p> <p>Note</p> <p>Don\u2019t hesitate to reach out to the project maintainers on Rocket.Chat (<code>#caliper-contributors</code> channel) who will help you with the integration.</p> <p>The integration consists of the following steps (for an example, see the <code>[caliper-ethereum](https://github.com/hyperledger-caliper/caliper/tree/v0.6.0/packages/caliper-ethereum)</code> connector):</p> <ol> <li>Create a <code>caliper-fast-ledger</code> directory in the <code>packages</code> directory of the repository. This will contain your connector implementation.</li> <li>Update your metadata in your own <code>package.json</code> file accordingly. The package name should be scoped: <code>@hyperledger/caliper-fast-ledger</code>.</li> <li>If your connector supports binding, then you should list the dynamic packages in the <code>devDependencies</code> section, so they\u2019re not automatically installed with Caliper (since the users will rebind it anyway). Also, add your connector\u2019s binding specifications to the built-in binding configuration file.</li> <li>Add your new directory path to the root <code>lerna.json</code> file, under the <code>packages</code> section. This will ensure that your package is bootstrapped correctly for other developers (and for testing, publishing, etc.).</li> <li>Add your new package (by name) to the Caliper CLI dependencies.</li> <li>List your connector as a built-in connector in the <code>caliper-utils.js</code> module, under the <code>BuiltinConnectors</code> variable: <pre><code>const BuiltinConnectors = new Map([\n ['fast-ledger', '@hyperledger/caliper-fast-ledger'],\n // other connectors...\n]);\n</code></pre></li> <li>It is highly recommended to provide integration tests for your connector.</li> <li>Make sure that every code-related artifact (mostly <code>.js</code>, <code>.yaml</code> and <code>.md</code> files) contains the appropriate license header!</li> <li>And you\u2019re done! Now users can refer to the connector as <code>fast-ledger</code> in their network configuration files. The connector package will be published automatically upon every merged PR.</li> </ol>"},{"location":"connectors/writing-connectors/#license","title":"License","text":"<p>The Caliper codebase is released under the Apache 2.0 license. Any documentation developed by the Caliper Project is licensed under the Creative Commons Attribution 4.0 International License. You may obtain a copy of the license, titled CC-BY-4.0, at http://creativecommons.org/licenses/by/4.0/.</p>"},{"location":"getting-started/architecture/","title":"Architecture","text":""},{"location":"getting-started/architecture/#overview","title":"Overview","text":"<p>Caliper is a general framework for executing benchmarks against different blockchain platforms. Caliper was designed with scalability and extensibility in mind to easily integrate with today\u2019s popular monitoring and infrastructure solutions. Accordingly, the architecture of Caliper can seem a bit complicated at first.</p> <p>This page aims to gradually ease you into the intricacies of Caliper\u2019s architecture, taking one step at a time. By the end of this page, you should be familiar with the general concepts and API of Caliper. As you read along, you will find references to other, more technical documentation pages. Feel free to explore them once you are familiar with the basic building blocks of Caliper.</p>"},{"location":"getting-started/architecture/#birds-eye-view","title":"Bird\u2019s eye view","text":"<p>At its most simple form, Caliper is a service that generates a workload against a specific system under test (SUT) and continuously monitors its responses. Finally, Caliper generates a report based on the observed SUT responses. This simplistic view is depicted in the following figure.</p> <p></p> <p>Caliper requires several inputs to run a benchmark, independently of the used SUT. The following subsections give a brief overview of these inputs.</p>"},{"location":"getting-started/architecture/#benchmark-configuration-file","title":"Benchmark configuration file","text":"<p>The benchmark configuration file describes how the benchmark should be executed. It tells Caliper how many rounds it should execute, at what rate the TXs should be submitted, and which module will generate the TX content. It also includes settings about monitoring the SUT.</p> <p>You can consider this file as the \u201cflow orchestrator\u201d of the benchmark. For the most part, the settings are independent of the SUT, so you can easily reuse them when performing multiple benchmarks against different SUT types or versions.</p> <p>Note</p> <p>For a more technical introduction to the benchmark configuration file, see the corresponding page.</p>"},{"location":"getting-started/architecture/#network-configuration-file","title":"Network configuration file","text":"<p>The content of the network configuration file is SUT-specific. The file usually describes the topology of the SUT, where its nodes are (their endpoint addresses), what identities/clients are present in the network, and what smart contracts Caliper should deploy or interact with.</p> <p>For the exact structure of the network configuration files, refer to the corresponding SUT connector documentations (we will discuss connectors a bit later on this page):</p> <ul> <li>Hyperledger Besu &amp; Ethereum</li> <li>Hyperledger Fabric</li> </ul>"},{"location":"getting-started/architecture/#workload-modules","title":"Workload modules","text":"<p>Workload modules are the brain of a benchmark. Since Caliper is a general benchmark framework, it does not include any concrete benchmark implementation. When Caliper schedules TXs for a given round, it is the task of the round\u2019s workload module to generate the content of the TXs and submit it. Each round can have a different associated workload module, so separating your workload implementation based on phases/behavior should be easy.</p> <p>Workload modules are simply Node.JS modules that must export a given factory function. Other than that, the workload module logic can be arbitrary. Really, anything you can code in Node.JS.</p> <p>Note</p> <p>For a more technical introduction to the benchmark configuration file, see the corresponding page.</p>"},{"location":"getting-started/architecture/#benchmark-artifacts","title":"Benchmark artifacts","text":"<p>There might be additional artifacts necessary to run a benchmark that can vary between different benchmarks and runs. These usually include the followings:</p> <ul> <li>Crypto materials necessary to interact with the SUT.</li> <li>Smart contract source code for Caliper to deploy (if the SUT connector supports such operation).</li> <li>Runtime configuration files.</li> <li>Pre-installed third party packages for your workload modules.</li> </ul> <p>Refer to the SUT connector configuration pages for the additional necessary artifacts.</p> <p>Note</p> <p>From here on out, we will refer to the introduced Caliper inputs simply as benchmark artifacts and denote them with the database symbol seen in the first figure.</p>"},{"location":"getting-started/architecture/#multi-platform-support","title":"Multi-platform support","text":"<p>Before we further dive into the architecture of Caliper, let\u2019s see how Caliper can support multiple SUT types. Caliper uses connector modules to hide the peculiarities of different SUT types and provide a unified interface towards the Caliper (and external) modules.</p> <p>A SUT connector provides a simplified interface towards internal Caliper modules, as well as towards the workload modules. Accordingly, Caliper can request the execution of simple things, like \u201cinitialize the connector/SUT\u201d, and the connector implementation will take care of the rest. The exact tasks to perform during the initialization are often determined by the content of the network configuration file (and by the remote administrative actions the SUT supports).</p> <p>Note</p> <p>For the technical details of how to implement a connector, refer to the corresponding page.</p>"},{"location":"getting-started/architecture/#caliper-processes","title":"Caliper processes","text":"<p>Caliper considers scalability one of its most important goals (besides extensibility/flexibility). Workload generation from a single machine can quickly reach the resource limitations of the machine. If we want the workload rate to match the scalability and performance characteristics of the evaluated SUT then we need a distributed approach!</p> <p>Accordingly, Caliper (as a framework) comprises of two different services/processes: a manager process and numerous worker processes.</p> <ul> <li>The manager process initializes the SUT (if supported) and coordinates the run of the benchmark (i.e., schedules the configured rounds) and handles the performance report generation based on the observed TX statistics.</li> <li>The worker processes perform the actual workload generation, independently of each other. Even if a worker process reaches the limits of its host machine, using more worker processes (on multiple machines) can further increase the workload rate of Caliper. Thus worker processes are the backbone of Caliper\u2019s scalability.</li> </ul> <p>The described setup is illustrated in the next figure.</p> <p></p> <p>Note</p> <p>For the time being, we will ignore the technical details of the distributed architecture, like the messaging between the processes. We will come back to it in a later section.</p>"},{"location":"getting-started/architecture/#the-manager-process","title":"The manager process","text":"<p>The Caliper manager process is the orchestrator of the entire benchmark run. It goes through several predefined stages as depicted by the figure below.</p> <p></p> <ol> <li>In the first stage, Caliper executes the startup script (if present) from the network configuration file. This step is mainly useful for local Caliper and SUT deployments as it provides a convenient way to start the network and Caliper in one step.</li> </ol> <p>Note</p> <p>The deployment of the SUT is not the responsibility of Caliper. Technically, Caliper only connects to an already running SUT, even if it was started through the startup script.</p> <ol> <li>In the second stage, Caliper initializes the SUT. The tasks performed here are highly dependent on the capabilities of the SUT and the SUT connector. For example, the Hyperledger Fabric connector uses this stage to create/join channels and register/enroll new users.</li> <li>In the third stage, Caliper deploys the smart contracts to the SUT, if the SUT and the connector support such operation (like with the Hyperledger Fabric connector).</li> <li>In the fourth stage Caliper schedules and executes the configured rounds through the worker processes. This is the stage where the workload generation happens (through the workers!).</li> <li>In the last stage, after executing the rounds and generating the report, Caliper executes the cleanup script (if present) from the network configuration file. This step is mainly useful for local Caliper and SUT deployments as it provides a convenient way to tear down the network and any temporary artifacts.</li> </ol> <p>If your SUT is already deployed an initialized, then you only need Caliper to execute the rounds and nothing else. Luckily, you can configure every stage one-by-one whether it should be executed or not. See the flow control settings for details.</p> <p>The above figure only shows the high-level steps of executing a benchmark. Some components are omitted for the sake of simplicity, like the resource and transaction monitor components. To learn more about the purpose and configuration of these components, refer to the Resource and Transaction Monitors documentation page.</p>"},{"location":"getting-started/architecture/#the-worker-process","title":"The worker process","text":"<p>The interesting things (from a user perspective) happen inside the worker processes. A worker process starts its noteworthy tasks when the manager process sends a message to it about executing the next round (the 4<sup>th</sup> step in the previous section). The important components of a worker process are shown in the figure below.</p> <p></p> <p>The worker process spends most of its time in the workload generation loop. The loop consists of two important steps:</p> <ol> <li>Waiting for the rate controller to enable the next TX. Think of the rate controller as a delay circuit. Based on what kind of rate controller is used, it delays/halts the execution of the worker (in an asynchronous manner) before enabling the next TX. For example, if a fixed 50 TXs per second (TPS) rate is configured, the rate controller will halt for 20ms between each TX.</li> </ol> <p>Note</p> <p>The rate controllers of each round can be configured in the benchmark configuration file. For the available rate controllers, see the Rate Controllers page.</p> <ol> <li>Once the rate controller enables the next TX, the worker gives control to the workload module. The workload module assembles the parameters of the TX (specific to the SUT and smart contract API) and calls the simple API of the SUT connector that will, in turn, send the TX request to the SUT (probably using the SDK of the SUT).</li> </ol> <p>Note</p> <p>The workload modules of each round can be configured in the benchmark configuration file. For the technical details of workload modules, see the Workload Modules page.</p> <p>During the workload loop, the worker process sends progress updates to the manager process. Progress reporting on the manager side can be enabled and configured with the <code>caliper-progress-reporting-enabled and caliper-progress-reporting-interval</code> setting keys. For details, see the Basic Runtime Settings.</p>"},{"location":"getting-started/architecture/#process-distribution-models","title":"Process distribution models","text":"<p>The last part of the architecture discussion is demystifying the worker process management. Based on how worker processes are started and what messaging method is used between the manager and worker processes, we can distinguish the following distribution/deployment models:</p> <ol> <li>Automatically spawned worker processes on the same host, using interprocess communication (IPC) with the manager process.</li> <li>Automatically spawned worker processes on the same host, using a remote messaging mechanism with the manager process.</li> <li>Manually started worker processes on an arbitrary number of hosts, using a remote messaging mechanism with the manager process.</li> </ol> <p>Even though the third method is the way to go for more complex scenarios, the first two methods can help you get familiar with Caliper, and gradually aid you with the transition to the third method.</p>"},{"location":"getting-started/architecture/#modular-message-transport","title":"Modular message transport","text":"<p>The different deployment approaches are made possible by how Caliper handles messaging internally, as shown by the following figure.</p> <p></p> <p>The internal Caliper modules only deal with predefined messages whose content is independent of how the messages are sent. The module that sends the messages between the processes is swappable, thus enabling different communication methods.</p> <p>The deployment model is configurable with the following two setting keys:</p> <ul> <li><code>caliper-worker-remote</code>: if set to <code>false</code> (the default), then the manager process will spawn the required number of worker processes locally, resulting in the models 1 or 2.</li> <li><code>caliper-worker-communication-method</code>: can take the values <code>process</code> (the default) or <code>mqtt</code> and determines the message transport implementation to use. The process communication corresponds to the first model, while <code>mqtt</code> denotes models 2 and 3.</li> </ul> <p>The following table summarizes the different models and how to select them:</p> <code>remote</code> value <code>method</code> value Corresponding deployment model <code>false</code> <code>process</code> 1. Interprocess communication with local workers <code>false</code> <code>mqtt</code> 2. Remote messaging-based communication with local workers <code>true</code> <code>mqtt</code> 3. Remote messaging-based communication with remote workers <code>true</code> <code>process</code> Invalid, since IPC does not apply to remote communication <p>Note</p> <p>For the technical details on configuration the messaging transport, see the Messengers page.</p>"},{"location":"getting-started/architecture/#interprocess-communication","title":"Interprocess communication","text":"<p>The examples on the Install &amp; Usage page all use the IPC approach since it is the default behavior. The setup is illustrated in the figure below.</p> <p>The <code>caliper launch manager</code> CLI command starts the manager process, which in turn will automatically spawn the configured number of worker processes (using the <code>caliper launch worker</code> CLI command). The communication between the processes is IPC, utilizing the built-in Node.JS method available for the parent-children process relationships.</p> <p></p> <p>This is the simplest deployment model for Caliper, requiring no additional configuration and third party messaging components. Accordingly, it is ideal when you first start using Caliper, or when you are still assembling the benchmark artifacts for your project, and just quickly want to test them.</p> <p>Unfortunately, this model is constrained to a single host, thus suffers from scalability issues in the sense that only vertical scalability of the host is possible.</p>"},{"location":"getting-started/architecture/#local-message-broker-communication","title":"Local message broker communication","text":"<p>As a stepping stone towards the fully-distributed setup, the second deployment model replaces IPC with a third party messaging solution, while still hiding the worker process management from the user. The setup is illustrated in the figure below.</p> <p></p> <p>Like before, the <code>caliper launch manager</code> CLI command starts the manager process, which in turn will automatically spawn the configured number of worker processes (using the <code>caliper launch worker</code> CLI command). However, the messaging happens through a separate component, which could be deployed anywhere as long as its endpoint is reachable by the Caliper processes.</p> <p>Unfortunately, this model is also constrained to a single host from the aspect of the Caliper processes. However, it is a useful model for taking your deployment to the next level once your benchmark artifacts are in place. Once you successfully integrated the messaging component, you are ready to move to the fully distributed Caliper setup.</p>"},{"location":"getting-started/architecture/#distributed-message-broker-communication","title":"Distributed message broker communication","text":"<p>When you take the management of the worker processes into your own hands, that\u2019s when the full potential of Caliper is unlocked. At this point, you can start as many workers on as many hosts as you would like, using the <code>caliper launch worker</code> CLI command. The setup is illustrated in the figure below.</p> <p></p> <p>The fully distributed deployment enables the horizontal scaling of the worker processes, greatly increasing the achievable workload rate. To ease the management of the many Caliper processes, you will probably utilize some automatic deployment/management solution, like Docker Swarm or Kubernetes. Luckily, the flexibility of the Caliper Docker image makes such integration painless.</p> <p>However, there are some caveats you have to keep in mind:</p> <ol> <li>Distributing the necessary benchmark artifacts to the Caliper processes is your responsibility. Different infrastructure solutions provide different means for this, so check your favorite vendor\u2019s documentation.</li> <li>Setting up proper networking in distributed systems is always a challenge. Make sure that the Caliper processes can access the configured messaging component and the SUT components.</li> <li>A single host may run multiple Caliper worker processes. When planning the worker distribution (or setting resource requirements for container management solutions) make sure that enough resources are allocated for workers to keep the configured TX scheduling precision.</li> </ol>"},{"location":"getting-started/architecture/#license","title":"License","text":"<p>The Caliper codebase is released under the Apache 2.0 license. Any documentation developed by the Caliper Project is licensed under the Creative Commons Attribution 4.0 International License. You may obtain a copy of the license, titled CC-BY-4.0, at http://creativecommons.org/licenses/by/4.0/.</p>"},{"location":"getting-started/contributing/","title":"Contributing to Hyperledger Caliper","text":"<p>Welcome to Hyperledger Caliper project, we are excited about the prospect of you contributing.</p> <p>This guideline intends to make contribtuions to Caliper easier by:</p> <ul> <li>presenting a simple development workflow for contributors to follow;</li> <li>and providing a high-level description of the repository components.</li> </ul> <p>If you have further suggestions about improving the guideline, then you can follow the presented workflow to make your contribution.</p>"},{"location":"getting-started/contributing/#overview","title":"Overview","text":"<p>The project uses GitHub to manage issues (bug reports and feature requests) and contributions (in the form of pull requests).</p> <p>For general queries and discussion, please use the #caliper channel on the Hyperledger Discord Server (Discord Id required) or the Caliper mailing list (LFID recommended).</p> <p>The contribution process boils down to two major steps: opening an issue and submitting a pull request (PR). Opening issues before PRs serves the following purposes:</p> <ul> <li>Documenting bugs, related error logs, potential fixes, and/or workarounds that users can find using their favorite search engine.</li> <li>Providing a forum for discussions where both contributors and users can weigh in about new features and their potential design.</li> <li>Enabling easy traceability of contributions through the \"Commit \u2192 PR \u2192 Issue\" reference chain.</li> </ul> <p>Opening issues can be omitted only in the case of trivial and small fixes (e.g., typo fixes, simple documentation enhancements, etc.).</p>"},{"location":"getting-started/contributing/#opening-issues","title":"Opening Issues","text":"<p>Before opening an issue, make sure that:</p> <ol> <li>You read the documentation carefully, so the observed error does not stem from incorrect Caliper configuration or usage.</li> <li>You searched older issues (or other forums) for your question, maybe it is already answered/fixed.</li> <li>It is worth to ask around on Discord, maybe other users already encountered your issue/task, and managed to solve it.</li> </ol> <p>When opening an issue about a potential bug or feature request, make sure to properly fill and format the issue contents!</p> <p>Choose the issue template that suits your intent (bug report or feature request), then fill out the form as best as you can.</p> <p>If you find the available issue templates too constraining, then you can still use the \"blank\" issue template for now (it will be deprecated in the future), and also let us know how we can improve the issue templates.</p> <p>The details of the blank template should be filled according to the following guideline:</p> <ol> <li>Issue title: Should be a concise sentence summarising the details below, including which component or part of the benchmarking process is affected. For example: <code>Fabric contract deployment silently fails in generator CI test</code></li> <li>Context: A detailed description of the context of the issue. Should include information about, for example, how you encountered the issue, what were you trying to achieve, why you consider this a bug, and how it affected your work with Caliper?</li> <li>Expected Behavior: What was your expected outcome/behavior of the Caliper run?</li> <li>Actual Behavior: What was your actually observered outcome/behaviour instead of the expected one?</li> <li>Possible Fix: If you have already identified the source of the issue, you can also propose a possible fix for it. It does not necessarily have to be a working code, some general steps/ideas of a fix is also appreciated.</li> <li>Steps to Reproduce: This is perhaps the most important part of an issue. Since Caliper is highly configurable and can interact with multiple SUTs, it is crucial for the maintainers to know the exact steps to reproduce an issue. Always try to provide (or just describe) a minimal working example (MWE) that can reproduce the issue. Also, please attach the following information to the issues whenever possible (preferably using collapsable code blocks or GitHub gists):<ul> <li>The benchmark configuration file content.</li> <li>The network configuration file content.</li> <li>The workload module implementation.</li> <li>The exact error logs (and their surroundings).</li> <li>Any other information you deem neccessary.</li> </ul> </li> <li>Existing Issues: You can also provide links to similar (or the same) issues in other forums (GitHub issues, StackOverflow questions or Discord messages). Such cross-linking can help us ensure that we can broadcast the potential fixes to multiple instances of the question.</li> <li>Your Environment: Always include your execution environment information, including the used version/commit of Caliper, the operating system, Node.JS version, or any relevant information about your project that uses Caliper.</li> </ol>"},{"location":"getting-started/contributing/#submitting-pull-requests","title":"Submitting Pull Requests","text":""},{"location":"getting-started/contributing/#basic-workflow","title":"Basic workflow","text":"<p>The following workflow should make your contribution process clean and straighforward (some deviations might be neccessary in exceptional cases):</p> <p>The following list assumes that you use the <code>git</code> command line tool. IDEs and graphical git tools should also expose the same commands if you prefer those.</p> <ol> <li>Fork the Caliper repository. This needs to be done only once.</li> <li>Clone the fork repository to your local machine (ideally done once):<ul> <li>Using the <code>HTTPS</code> method: <code>git clone https://github.com/&lt;username&gt;/caliper.git</code></li> <li>or using the <code>SSH</code> method: <code>git clone git@github.com:&lt;username&gt;/caliper.git</code></li> </ul> </li> <li>Add the upstream/original Caliper repository as a remote, using the name <code>upstream</code> (ideally done once). This will allow you to easily sync your fork with the original repository.<ul> <li><code>git remote add upstream https://github.com/hyperledger-caliper/caliper.git</code></li> </ul> </li> </ol> <p>The following steps follow the \"feature branch\" development practice, and should be performed for each of your contribution:</p> <ol> <li>Checkout your <code>main</code> branch that will be the starting point/state of your contribution.<ul> <li><code>git checkout main</code></li> <li>or <code>git checkout -b main</code> if the branch does not exist locally (only during your first checkout)</li> </ul> </li> <li>Retrieve the new updates from the <code>upstream</code> Caliper repository<ul> <li><code>git fetch upstream</code> (downloads the updates locally)</li> <li>then <code>git rebase upstream/main</code> (\"adds\" the updates to your local <code>main</code> brach) <p>This step is crucial to ensure that you always contribute based on the latest Caliper version, minimizing the chance of version control conflicts!</p> </li> </ul> </li> <li>(Optional) Push your updated <code>main</code> branch to your remote repository just to keep things in sync<ul> <li><code>git push</code></li> </ul> </li> <li>Create a new feature branch (named <code>my-bug-fix</code>) from the updated <code>main</code> branch:<ul> <li><code>git checkout -b my-bug-fix</code></li> <li>then <code>git push --set-upstream origin my-bug-fix</code> to push the new branch to your remote repository</li> </ul> </li> <li>Implement and test your contribution<ul> <li>The <code>.build/checks-and-unit-tests.sh</code> script runs the basic tests for the repository</li> <li>The <code>BENCHMARK=&lt;test_name&gt; .build/benchmark-integration-test-direct.sh</code> script can run one of the CI integration tests, depending on the value of <code>&lt;test_name&gt;</code>:<ul> <li><code>BESU</code></li> <li><code>ETHEREUM</code></li> <li><code>FABRIC</code></li> <li><code>GENERATOR</code> <p>Make sure that the tests pass locally before pushing your changes and opening a PR!</p> </li> </ul> </li> </ul> </li> <li>Commit your changes to your local feature branch, adding the DCO sign-off:<ul> <li><code>git commit -s -m \"Commit message\"</code></li> <li>or <code>git commit -s</code> (without the <code>-m</code> parameter) to make git open up the configured text editor where you can write a detailed, multi-line commit message:<ul> <li>The first line is a concise description of the commit (its purpose, what does it fix, etc).</li> <li>After a blank line, you can go into details about the changes of the commit.</li> </ul> </li> </ul> </li> <li>Push your changes to your remote branch:<ul> <li><code>git push</code></li> </ul> </li> <li>Open a PR using the GitHub webpage.</li> </ol>"},{"location":"getting-started/contributing/#updating-prs","title":"Updating PRs","text":"<p>It is possible that the maintainers/reviewers request some changes before your PR can be merged. In that case, just add your changes to your feature branch using a new signed commit (based on the above workflow), then push it to your remote branch. The PR will automatically pick up the new commit.</p> <p>The maintainers can/will squash commits before merging to keep a simpler commit history for the project.</p>"},{"location":"getting-started/contributing/#how-to-contribute","title":"How to contribute","text":"<p>We are using GitHub issues for bug reports and feature requests.</p> <p>If you find any bug in the source code or have any trivial changes (such as typos fix, minor feature), you can raise an issue or delivery a fix via a pull request directly.</p> <p>If you have any enhancement suggestions or want to help extend caliper with more DLTs or have any other major changes, please start by opening an issue first. That way, relevant parties (e.g. maintainers or main contributors of the relevant subsystem) can have a chance to look at it before you do any work.</p> <p>All PRs must get at least one review, you can ask <code>hyperledger/caliper-committers</code> for review. Normally we will review your contribution in one week. If you haven\u2019t heard from anyone in one week, feel free to @ or mail a maintainer to review it.</p> <p>All PRs must be signed before be merged, be sure to use <code>git commit -s</code> to commit your changes.</p> <p>If a PR is reviewed and changes are requested then please do not force push the changes, push the changes into a new commit, this makes it easier to see the changes between the previously reviewed code and the new changes.</p> <p>We use Github Actions to test the build - please test on your local branch before raising a PR.</p> <p>There is also Discord with a Caliper channel for communication, anybody is welcome to join.</p>"},{"location":"getting-started/contributing/#caliper-components","title":"Caliper Components","text":"<p>The project is maintained as a Node.js monorepository. Accordingly, it can seem overwhelming at first to navigate its content. The following sections list and introduce the main components of the repository.</p>"},{"location":"getting-started/contributing/#installing-the-caliper-code-base","title":"Installing the Caliper code base","text":"<p>Note</p> <p>this section is intended only for developers who would like to modify the Caliper code-base and experiment with the changes locally before raising pull requests. You should perform the following steps every time you make a modification you want to test, to correctly propagate any changes.</p> <p>The workflow of modifying the Caliper code-base usually consists of the following steps:</p> <ol> <li>Bootstrapping the repository</li> <li>Modifying and testing the code</li> <li>Publishing package changes locally</li> <li>Building the Docker image</li> </ol>"},{"location":"getting-started/contributing/#bootstrapping-the-caliper-repository","title":"Bootstrapping the Caliper repository","text":"<p>To install the basic dependencies of the repository, and to resolve the cross-references between the different packages in the repository, you must execute the following commands from the root of the repository directory:</p> <ol> <li> <p><code>./.build/check-prerequisites.sh</code>: Checks the version of Node and NPM in the system and warns if the versions are not compatible.</p> </li> <li> <p><code>npm ci</code>: Installs the dependencies of the repository from the <code>package-lock.json</code> file.</p> </li> </ol> <p>Or as a one-liner:</p> <pre><code>user@ubuntu:~/caliper$ ./.build/check-prerequisites.sh &amp;&amp; npm ci\n</code></pre> <p>Note</p> <p>do not run any of the above commands with <code>sudo</code>, as it will cause the bootstrap process to fail.</p>"},{"location":"getting-started/contributing/#publicpublished-packages","title":"Public/published packages","text":"<p>The packages directory contains the following public/published packages:</p> <ul> <li>caliper-cli: The command line interface (CLI) of Caliper.</li> <li>caliper-core: The core and common codebase of Caliper, used by the other packages.</li> <li>caliper-ethereum: The Ethereum and Hyperledger Besu connector implementation.</li> <li>caliper-fabric: The Hyperledger Fabric connector implementation.</li> <li>generator-caliper: The Yeaoman generator for Caliper configuration files.</li> </ul>"},{"location":"getting-started/contributing/#internal-packages","title":"Internal packages","text":"<p>The packages directory contains the following internal packages:</p> <ul> <li>caliper-publish: Utility CLI for publishing Caliper to NPM and DockerHub.</li> <li>caliper-tests-integration: Collection of CI integration tests.</li> </ul>"},{"location":"getting-started/contributing/#testing-methodologies","title":"Testing Methodologies","text":"<p>This section outlines the testing methodologies that this project follows, including both unit-level and integration-level testing.</p>"},{"location":"getting-started/contributing/#unit-level-testing","title":"Unit Level Testing","text":"<p>Unit testing focuses on testing individual packages in isolation. The tests are typically located within a test folder at the same level as the corresponding lib folder, mirroring the structure of the lib folder for easy navigation. This setup ensures that each component of the code is verified independently, confirming that it behaves as expected without interference from other parts of the system.</p>"},{"location":"getting-started/contributing/#unit-testing-dependencies-and-their-use","title":"Unit Testing Dependencies and Their Use","text":"<p>The following are the recommended testing modules for this project. While these tools are commonly used in the current codebase, other appropriate tools may be used as long as they facilitate effective testing.</p> <ul> <li> <p>mockery: Mockery is a simple module for mocking Node.js modules during testing. It allows you to replace real modules with mocks or stubs.</p> </li> <li> <p>mocha: Mocha is a feature-rich JavaScript test framework that runs on Node.js and in the browser. It facilitates asynchronous testing, making it easy to write simple and flexible tests.</p> </li> <li> <p>chai: Chai is a BDD/TDD assertion library for Node.js and the browser. It can be paired with any JavaScript testing framework. We use it to create readable and expressive assertions.</p> </li> <li> <p>sinon: Sinon is a standalone test spies, stubs, and mocks for JavaScript. It works with any test framework and integrates well with Mocha and Chai. We utilize Sinon for checking how functions are called during testing.</p> </li> <li> <p>sinon-chai: This library provides a set of custom assertions for using Sinon with Chai. It allows you to write more readable assertions for Sinon spies, stubs, and mocks.</p> </li> <li> <p>nyc: NYC is a command-line utility for generating code coverage reports. It is often used with Mocha to ensure that tests cover as much code as possible.</p> </li> </ul>"},{"location":"getting-started/contributing/#mandatory-tools-in-the-testing-pipeline","title":"Mandatory Tools in the Testing Pipeline","text":"<p>In addition to the testing frameworks, the following tools are mandatory for all testing pipelines:</p> <ul> <li>eslint: ESLint is a static code analysis tool for identifying problematic patterns in JavaScript code. It is essential for maintaining code quality.</li> <li>license-check-and-add: This tool ensures that all files in the codebase contain the required license headers. It is mandatory for all code submissions.</li> </ul>"},{"location":"getting-started/contributing/#points-to-note-for-adding-a-conforming-unit-test","title":"Points to Note for Adding a Conforming Unit Test","text":"<p>When writing unit tests, the following structure and practices are mandatory:</p> <ol> <li>License Header: All test files must include the project's license header.</li> <li>'use strict' Directive: Ensure strict mode is enabled in all test files.</li> <li>Test Organization:<ul> <li>Use <code>describe</code> blocks to group related test cases.</li> <li>Use <code>it</code> statements for individual test cases.</li> <li>Nested <code>describe</code> blocks are encouraged for organizing complex test scenarios.</li> </ul> </li> <li>Consistent Test Naming: Test descriptions should flow naturally, making it clear what behavior is being tested (e.g., 'should return the correct value when input is valid').</li> <li>Mocking Guidance: Be cautious with mocks that persist across tests. Always clean up after each test to avoid unexpected behavior.</li> <li>Test Patterns: Refer to the Fabric Unit tests for examples of recommended patterns and best practices.</li> <li>Final Checks: Always run all unit tests before submitting a PR and ensure no <code>.only</code> is left in the code, which would skip other tests.</li> </ol>"},{"location":"getting-started/contributing/#integration-level-testing","title":"Integration Level Testing","text":"<p>Integration testing ensures that Caliper integrates correctly with various packages, effectively testing the functionality of the package itself. These tests are organized within the caliper-tests-integration folder, with each test suite dedicated to a specific package or module.</p>"},{"location":"getting-started/contributing/#testing-the-code","title":"Testing the code","text":"<p>Caliper has both unit tests and integration tests.</p> <p>Unit tests can be run using <code>npm test</code> either in the root of the caliper source tree (to run them all) or within the specific package (eg caliper-fabric) to run just the tests within that package.</p> <p>To run the integration tests for a specific SUT, use the following script from the root directory of the repository, setting the <code>BENCHMARK</code> environment variable to the platform name:</p> <pre><code>user@ubuntu:~/caliper$ BENCHMARK=fabric ./.build/benchmark-integration-test-direct.sh\n</code></pre> <p>The following platform tests (i.e., valid BENCHMARK values) are available: besu, ethereum, fabric.</p> <p>A PR must pass all unit and integration tests.</p> <p>If you would like to run other examples, then you can directly access the CLI in the <code>packages/caliper-cli</code> directory, without publishing anything locally.</p> <pre><code>user@ubuntu:~/caliper$ node ./packages/caliper-cli/caliper.js launch manager \\\n    --caliper-workspace ~/caliper-benchmarks \\\n    --caliper-benchconfig benchmarks/scenario/simple/config.yaml \\\n    --caliper-networkconfig networks/fabric/test-network.yaml\n</code></pre>"},{"location":"getting-started/contributing/#creating-new-sut-connectors","title":"Creating New SUT Connectors","text":"<p>Connectors are relatively heavy components in Caliper. Before you attempt to create a new connector for a new SUT type, consult with the Caliper maintainers (on Discord, or in the form of a feature request).</p> <p>More importantly, make sure that you are overly familiar with the documentation page about implementing new connectors.</p>"},{"location":"getting-started/contributing/#publishing-to-local-npm-repository","title":"Publishing to local NPM repository","text":"<p>The NPM publishing and installing steps for the modified code-base can be tested through a local NPM proxy server, Verdaccio. The steps to perform are the following:</p> <ol> <li>Start a local Verdaccio server to publish to</li> <li>Publish the packages from the Caliper repository to the Verdaccio server</li> <li>Install and bind the CLI from the Verdaccio server</li> <li>Run the integration tests or any sample benchmark</li> </ol> <p>The <code>packages/caliper-publish</code> directory contains an internal CLI for easily managing the following steps. So the commands of the following sections must be executed from the <code>packages/caliper-publish</code> directory:</p> <pre><code>user@ubuntu:~/caliper$ cd ./packages/caliper-publish\n</code></pre> <p>Note</p> <p>use the <code>--help</code> flag for the following CLI commands and sub-commands to find out more details.</p>"},{"location":"getting-started/contributing/#starting-verdaccio","title":"Starting Verdaccio","text":"<p>To setup and start a local Verdaccio server, run the following npm command:</p> <pre><code>user@ubuntu:~/caliper/packages/caliper-tests-integration$ npm run start_verdaccio\n...\n[PM2] Spawning PM2 daemon with pm2_home=.pm2\n[PM2] PM2 Successfully daemonized\n[PM2] Starting /home/user/projects/caliper/packages/caliper-tests-integration/node_modules/.bin/verdaccio in fork_mode (1 instance)\n[PM2] Done.\n| App name  | id | mode | pid    | status | restart | uptime | cpu | mem       | user   | watching |\n|-----------|----|------|--------|--------|---------|--------|-----|-----------|--------|----------|\n| verdaccio | 0  | fork | 115203 | online | 0       | 0s     | 3%  | 25.8 MB   | user   | disabled |\n\nUse `pm2 show &lt;id|name&gt;` to get more details about an app\n</code></pre> <p>The Verdaccio server is now listening on the following address: <code>http://localhost:4873</code></p>"},{"location":"getting-started/contributing/#publishing-the-packages","title":"Publishing the packages","text":"<p>Once Verdaccio is running, you can run the following command to publish every Caliper package locally:</p> <pre><code>user@ubuntu:~/caliper/packages/caliper-publish$ ./publish.js npm --registry \"http://localhost:4873\"\n...\n+ @hyperledger/caliper-core@0.6.1-unstable-20240422122901\n[PUBLISH] Published package @hyperledger/caliper-core@0.6.1-unstable-20240422122901\n...\n+ @hyperledger/caliper-fabric@0.6.1-unstable-20240422122901\n[PUBLISH] Published package @hyperledger/caliper-fabric@0.6.1-unstable-20240422122901\n...\n+ @hyperledger/caliper-cli@0.6.1-unstable-20240422122901\n[PUBLISH] Published package @hyperledger/caliper-cli@0.6.1-unstable-20240422122901\n</code></pre> <p>Take note of the dynamic version number you see in the logs, you will need it to install you modified Caliper version from Verdaccio (the unstable tag is also present on NPM, so Verdaccio would probably pull that version instead of your local one).</p> <p>Since the published packages include a second-precision timestamp in their versions, you can republish any changes immediately without restarting the Verdaccio server and without worrying about conflicting packages.</p>"},{"location":"getting-started/contributing/#running-package-based-tests","title":"Running package-based tests","text":"<p>Once the packages are published to the local Verdaccio server, we can use the usual NPM install approach. The only difference is that now we specify the local Verdaccio registry as the install source instead of the default, public NPM registry:</p> <pre><code>user@ubuntu:~/caliper-benchmarks$ npm install --registry=http://localhost:4873 --only=prod \\\n    @hyperledger/caliper-cli@0.6.1-unstable-20240422122901\nuser@ubuntu:~/caliper-benchmarks$ npx caliper bind --caliper-bind-sut fabric:fabric-gateway\nuser@ubuntu:~/caliper-benchmarks$ npx caliper launch manager \\\n    --caliper-workspace . \\\n    --caliper-benchconfig benchmarks/scenario/simple/config.yaml \\\n    --caliper-networkconfig networks/fabric/test-network.yaml\n</code></pre> <p>Note</p> <p>we used the local registry only for the Caliper packages. The binding happens through the public NPM registry. Additionally, we performed the commands through npx and the newly installed CLI binary (i.e., not directly calling the CLI code file).</p>"},{"location":"getting-started/contributing/#building-the-docker-image","title":"Building the Docker image","text":"<p>Once the modified packages are published to the local Verdaccio server, you can rebuild the Docker image. The Dockerfile is located in the <code>packages/caliper-publish</code> directory.</p> <p>To rebuild the Docker image, execute the following:</p> <pre><code>user@ubuntu:~/caliper/packages/caliper-publish$ ./publish.js docker\n...\nSuccessfully tagged hyperledger/caliper:manager-unstable-20220206065953\n[BUILD] Built Docker image \"hyperledger/caliper:manager-unstable-20220206065953\"\n</code></pre> <p>Now you can proceed with the Docker-based benchmarking as described in the previous sections.</p> <p>Note</p> <p>once you are done with the locally published packages, you can clean them up the following way:</p> <pre><code>user@ubuntu:~/caliper/packages/caliper-publish$ ./publish.js verdaccio stop\n</code></pre>"},{"location":"getting-started/contributing/#caliper-structure","title":"Caliper Structure","text":"<p>Caliper is modularised under <code>packages</code> into the following components:</p> <p>caliper-cli This is the Caliper CLI that enables the running of a benchmark</p> <p>caliper-core Contains all the Caliper core code.</p> <p>caliper- Each <code>caliper-&lt;adapter&gt;</code> is a separate package that contains a distinct adaptor implementation to interact with different blockchain technologies. Current adaptors include:</p> <ul> <li>caliper-ethereum</li> <li>caliper-fabric</li> </ul> <p>Each adapter extends the <code>ConnectorBase</code> from the core package, as well as exports a <code>ConnectorFactory</code> function.</p> <p>caliper-tests-integration This is the integration test suite used for caliper; it runs in the Azure pipelines build and can (should) be run locally when checking code changes. Please see the readme within the package for more details.</p>"},{"location":"getting-started/contributing/#dependency-management-in-the-monorepo","title":"Dependency management in the monorepo","text":""},{"location":"getting-started/contributing/#npm-version","title":"npm version","text":"<p>For developing Caliper, the minimum required version of npm is <code>7.24.2</code>. This is because npm 7 introduced the npm workspaces feature, which is used to manage the Caliper monorepo.</p> <p>In case the npm version is not sufficient, the following error may be thrown when trying to install the dependencies:</p> <pre><code>user@ubuntu:~/caliper$ npm install\nnpm ERR! code ENOTSUP\nnpm ERR! notsup Unsupported engine for caliper@0.6.1-unstable: wanted: {\"node\":\"&gt;=18.19.0\",\"npm\":\"&gt;=7.24.2\"} (current: {\"node\":\"14.21.3\",\"npm\":\"6.14.18\"})\nnpm ERR! notsup Not compatible with your version of node/npm: caliper@0.6.1-unstable\nnpm ERR! notsup Not compatible with your version of node/npm: caliper@0.6.1-unstable\nnpm ERR! notsup Required: {\"node\":\"&gt;=18.19.0\",\"npm\":\"&gt;=7.24.2\"}\nnpm ERR! notsup Actual:   {\"npm\":\"6.14.18\",\"node\":\"14.21.3\"}\n</code></pre> <p>If the npm version is lower than <code>7.24.2</code>, you can update it to latest by running the following command:</p> <pre><code>npm install -g npm@latest\n</code></pre>"},{"location":"getting-started/contributing/#adding-new-dependencies","title":"Adding new dependencies","text":"<p>The monorepo is managed using npm workspaces. So to add a dependency to a package, the following command should be executed:</p> <pre><code>user@ubuntu:~/caliper$ npm install &lt;dependency&gt; --workspace=&lt;package&gt;\n</code></pre>"},{"location":"getting-started/contributing/#removing-unused-dependencies","title":"Removing unused dependencies","text":"<p>To remove a dependency from a package, the following command should be executed:</p> <pre><code>user@ubuntu:~/caliper$ npm uninstall &lt;dependency&gt; --workspace=&lt;package&gt;\n</code></pre>"},{"location":"getting-started/contributing/#managing-the-package-lockjson-file","title":"Managing the package-lock.json file","text":"<p>The <code>package-lock.json</code> file is generated by npm and it is used to lock the dependency versions. It is generated automatically when installing dependencies, and it should be committed to the repository. Please make sure that the right version of npm is used when installing dependencies, otherwise the <code>package-lock.json</code> file may be updated unnecessarily.</p>"},{"location":"getting-started/contributing/#how-dependency-conflicts-are-resolved-in-workspaces","title":"How dependency conflicts are resolved in workspaces","text":"<p>When installing dependencies to a workspace, if the dependency is already installed as a direct or indirect dependency of another workspace, npm will try to reuse the existing version. If the version is not compatible with the one specified in the workspace, npm will try to resolve the conflict by installing the requested version of the dependency in the <code>node_modules</code> directory of the workspace.</p>"},{"location":"getting-started/contributing/#add-an-adaptor-for-a-new-dlt","title":"Add an Adaptor for a New DLT","text":"<p>New adapters must be added within a new package, under <code>packages</code>, with the naming convention <code>caliper-&lt;adapter_name&gt;</code>. Each adapter must implement a new class extended from <code>ConnectorBase</code> as the adapter for the DLT, as well export a <code>ConnectorFactory</code> function. Please refer to the existing Connectors for examples and requirements for implementation.</p>"},{"location":"getting-started/contributing/#inclusive-language-guidelines","title":"Inclusive language guidelines","text":"<p>Please adhere to the inclusive language guidelines that the project has adopted as you make documentation updates.</p> <ul> <li>Consider that users who will read the docs are from different backgrounds and cultures and that they have different preferences.</li> <li>Avoid potential offensive terms and, for instance, prefer \u201callow list and deny list\u201d to \u201cwhite list and black list\u201d.</li> <li>We believe that we all have a role to play to improve our world, and even if writing inclusive documentation might not look like a huge improvement, it\u2019s a first step in the right direction.</li> <li>We suggest to refer to Microsoft bias free writing guidelines and Google inclusive doc writing guide as starting points.</li> </ul>"},{"location":"getting-started/contributing/#building-the-documentation","title":"Building the documentation","text":""},{"location":"getting-started/contributing/#requirements","title":"Requirements","text":"<ul> <li>Python</li> <li>Pip (Python package installer)</li> </ul>"},{"location":"getting-started/contributing/#installation","title":"Installation","text":"<ol> <li> <p>Clone the Repository:    <pre><code>git clone https://github.com/hyperledger-caliper/caliper.git\ncd caliper\n</code></pre></p> </li> <li> <p>Go to the documentation folder:     <pre><code>cd docs\n</code></pre></p> </li> <li> <p>Install Dependencies:     <pre><code>pip install -r pip-requirements.txt\n</code></pre></p> </li> <li> <p>Building the Documentation:     To build the documentation, run:     <pre><code>mkdocs build\n</code></pre></p> <p>This command generates static files in the site directory.</p> </li> <li> <p>Previewing Locally:     To preview your documentation locally, use:     <pre><code>mkdocs serve\n</code></pre></p> <p>This starts a local development server at http://127.0.0.1:8000/ where you can view your changes in real-time.</p> </li> </ol>"},{"location":"getting-started/contributing/#license","title":"License","text":"<p>The Caliper codebase is released under the Apache 2.0 license. Any documentation developed by the Caliper Project is licensed under the Creative Commons Attribution 4.0 International License. You may obtain a copy of the license, titled CC-BY-4.0, at http://creativecommons.org/licenses/by/4.0/.</p>"},{"location":"getting-started/faq/","title":"Caliper FAQ","text":""},{"location":"getting-started/faq/#i-environment-platform-version","title":"I. Environment, Platform &amp; Version","text":"<p>Q: How do I run Caliper to test a blockchain system? A: Details for setting up Caliper to run benchmark tests on a blockchain system are provided in the Getting Started page of the site. When you run Caliper to test a blockchain network, you may encounter some errors. If so, first you should check the version of tools, SDKs and modules to make sure it is right.</p>"},{"location":"getting-started/faq/#ii-configuration-files-of-caliper","title":"II. Configuration Files of Caliper","text":"<p>Q: What kind of configuration files are needed to run Caliper? A: There are two kinds of configuration files in Caliper: the benchmark configuration file, which defines the arguments of the benchmark, like workload and monitoring settings; the blockchain configuration file, which specifies the information needed to interact with the backend blockchain system. For examples of these files please refer to here</p> <p>There is another configuration file, namely <code>./config/default.yaml</code>, containing runtime setting for Caliper and the blockchain adapters. These settings can also be specified as command line arguments or environment variables.</p>"},{"location":"getting-started/faq/#iii-testing-a-blockchain-network","title":"III. Testing a Blockchain Network","text":"<p>Q: What kind of networks does Caliper support currently? A: Now you can use Caliper to test Besu, Ethereum and Fabric.</p> <p>Q: How can I test a blockchain system that Caliper does not support currently\uff1f A: If you want to test the blockchain system that Caliper does not support now, you must write your own blockchain adapter that Caliper can use to inferface with the backend network. For details, you can refer to the Writing Adapters page. The Caliper-specific configurations remain unchanged. Take a look at the provided adapter implementations and example networks to gather some best-practices.</p>"},{"location":"getting-started/faq/#iv-other-questions-related-to-caliper","title":"IV. Other Questions Related to Caliper","text":"<p>Q: How can I calculate the throughput (TPS)? A: Caliper will record the submitting time and committing time (the time when the Tx is committed on the ledger or when the failure occurred) for each Tx. So the send rate and the throughput are calculated by <code>(Succ+Fail) / (last submitting time - first submitting time)</code>.  This means both successful and failed transactions are included in the throughput and send rate calculations.</p>"},{"location":"getting-started/faq/#v-other-questions-related-to-the-backend-blockchain-system","title":"V. Other Questions Related to the Backend Blockchain System","text":"<p>Q: How can I test my own Fabric chaincode? A: You first need to deploy that chaincode to your Fabric network, then create your benchmark and workload files see the Caliper Fabric tutorial for further guidance.</p> <p>Q: How can I use TLS communication? A: Fabric supports secure communication between nodes and clients using TLS. TLS communication can use both one-way (server only) and two-way (server and client) authentication. You can refer to the Fabric TLS configuration page for server side settings. For Caliper-side settings, check the adapter documentation that details how to set the necessary credentials.</p>"},{"location":"getting-started/faq/#q-how-can-i-monitor-remote-docker-containers","title":"Q: How can I monitor remote Docker containers?","text":"<p>A: If you need to access the Docker daemon remotely, you need to explicitly enable remote access. Beware that the default setup provides unencrypted and unauthenticated direct access to the Docker daemon. For details, refer to the official Docker documentation.</p>"},{"location":"getting-started/faq/#license","title":"License","text":"<p>The Caliper codebase is released under the Apache 2.0 license. Any documentation developed by the Caliper Project is licensed under the Creative Commons Attribution 4.0 International License. You may obtain a copy of the license, titled CC-BY-4.0, at http://creativecommons.org/licenses/by/4.0/.</p>"},{"location":"getting-started/installing-caliper/","title":"Installing Caliper","text":""},{"location":"getting-started/installing-caliper/#overview","title":"Overview","text":"<p>Caliper is published as the @hyperledger/caliper-cli NPM package and the hyperledger/caliper Docker image, both containing the CLI binary. Refer to the Installing from NPM and Using the Docker image sections for the available versions and their intricacies.</p> <p>Installing and running Caliper consists of the following steps, thoroughly detailed by the remaining sections:</p> <ol> <li>Acquire the Caliper CLI either from NPM or from DockerHub.</li> <li>Execute a bind command through the CLI. This step pulls the specified version of SDK packages for the selected platform.</li> <li>Start the benchmark through the CLI or by starting the Docker container.</li> </ol> <p>The examples in the rest of the documentation use the caliper-benchmarks repository as the Caliper workspace since it contains many sample artifacts for benchmarking.</p> <p>Important</p> <p>make sure you check out the appropriate tag/commit of the repository, matching the version of Caliper you use.</p> <p>To clone the <code>caliper-benchmarks</code> repository, run:</p> <pre><code>git clone https://github.com/hyperledger-caliper/caliper-benchmarks.git\ncd caliper-benchmarks\ngit checkout &lt;your Caliper version&gt;\n</code></pre> <p>Note</p> <p>If you are running your custom benchmark, then change this directory path (and other related configurations) accordingly in the examples.</p>"},{"location":"getting-started/installing-caliper/#the-caliper-cli","title":"The Caliper CLI","text":"<p>Unless you are embedding the Caliper packages in your own application, you will probably use Caliper through its command line interface (CLI). The other sections will introduce the different ways of acquiring and calling the Caliper CLI. This section simply focuses on the API it provides.</p> <p>Note</p> <p>The following examples assume a locally installed CLI in the <code>~/caliper-benchmarks</code> directory, hence the <code>npx</code> call before the <code>caliper</code> binary. Refer to the Local NPM install section for the specifics.</p> <p>The entry point of the CLI is the <code>caliper</code> binary. You can confirm whether the CLI is installed correctly by checking its version:</p> <pre><code>user@ubuntu:~/caliper-benchmarks$ npx caliper --version\nv0.6.0\n</code></pre> <p>The CLI provides multiple commands to perform different tasks. To check the available commands and their descriptions, execute:</p> <p><pre><code>user@ubuntu:~/caliper-benchmarks$ npx caliper --help\ncaliper &lt;command&gt;\n\nCommands:\n  caliper.js bind [options]       Bind Caliper to a specific SUT and its SDK version\n  caliper.js launch &lt;subcommand&gt;  Launch a Caliper process either in a manager or worker role.\n  caliper.js unbind [options]     Unbind Caliper from a previously bound SUT and its SDK version\n  caliper.js completion           generate completion script\n\nOptions:\n  --help, -h  Show usage information  [boolean]\n  --version   Show version information  [boolean]\n\nExamples:\n  caliper bind\n  caliper unbind\n  caliper launch manager\n  caliper launch worker\n</code></pre> You can also request the help page of a specific command, as demonstrated by the next subsections.</p> <p>Note</p> <p>the command options can be set either through the command line, or from various other sources supported by the configuration mechanism of Caliper. This flexibility makes it easy to embed the CLI in different environments.</p>"},{"location":"getting-started/installing-caliper/#the-bind-command","title":"The bind command","text":"<p>Acquiring Caliper is as easy as installing a single NPM package, or pulling a single Docker image. However, this single point of install necessitates an additional step of telling Caliper which platform to target and which platform SDK version to use. This step is called binding, provided by the <code>bind</code> CLI command.</p> <p>To have a look at the help page of the command, execute: <pre><code>user@ubuntu:~/caliper-benchmarks$ npx caliper bind --help\nUsage:\n  caliper bind --caliper-bind-sut fabric:fabric-gateway --caliper-bind-cwd ./ --caliper-bind-args=\"-g\"\n\nOptions:\n  --help, -h           Show usage information  [boolean]\n  --version            Show version information  [boolean]\n  --caliper-bind-sut   The name and version of the platform and its SDK to bind to  [string]\n  --caliper-bind-cwd   The working directory for performing the SDK install  [string]\n  --caliper-bind-args  Additional arguments to pass to \"npm install\". Use the \"=\" notation when setting this parameter  [string]\n  --caliper-bind-file  Yaml file to override default (supported) package versions when binding an SDK  [string]\n</code></pre> The binding step technically consists of an extra <code>npm install</code> call with the appropriate packages and install settings, fully managed by the CLI. The following parameters can be set for the command:</p> <ul> <li>SUT/platform name and SDK version: specifies the name of the target platform and the SDK version to install, e.g., <code>fAbric:2.2</code></li> <li>Working directory: the directory from which the <code>npm install</code> command must be performed. Defaults to the current working directory</li> <li>User arguments: additional arguments to pass to <code>npm install</code>, e.g., <code>--save</code></li> </ul> <p>The following SUT name and SDK version combinations are supported:</p> <ul> <li>besu: <code>1.3.2</code>, <code>1.3</code>, <code>1.4</code></li> <li>ethereum: <code>1.2.1</code>, <code>1.3</code></li> <li>fabric: <code>1.4</code>, <code>2.2</code>, <code>fabric-gateway</code></li> </ul> <p>Note</p> <p>Ensure that the SDK you are binding is compatible with the the SUT version that you intend to target.</p> <p>The <code>bind</code> command is useful when you plan to run multiple benchmarks against the same SUT version. Bind once, then run different benchmarks without the need to bind again. As you will see in the next sections, the launcher commands for the manager and worker processes can also perform the binding step if the required parameter is present.</p>"},{"location":"getting-started/installing-caliper/#custom-bindings","title":"Custom bindings","text":"<p>The built-in bindings can be overridden by setting the <code>caliper-bind-file</code> parameter to a YAML file path. The file must match the structure of the default binding file, documented here. This way you can use experimental SDK versions that are not (yet) officially supported by Caliper. This also means that we cannot provide help for such SDK versions!</p>"},{"location":"getting-started/installing-caliper/#the-unbind-command","title":"The unbind command","text":"<p>It might happen that you would like to switch between different SUT SDK versions/bindings during your measurements or project development. Depending on the SUT SDK, simply rebinding to a different version might leave behind unwanted packages, resulting in obscure errors.</p> <p>To avoid this, the CLI provides an <code>unbind</code>command, that behaves exactly like the <code>bind</code> command (even uses the same arguments), but instead of installing the packages present in the binding specification, it removes them, leaving no trace of the previous binding.</p> <p>To have a look at the help page of the command, execute: <pre><code>user@ubuntu:~/caliper-benchmarks$ npx caliper unbind --help\nUsage:\n  caliper unbind --caliper-bind-sut fabric:2.2 --caliper-bind-cwd ./ --caliper-bind-args=\"-g\"\n\nOptions:\n  --help, -h           Show usage information  [boolean]\n  --version            Show version information  [boolean]\n  --caliper-bind-sut   The name and version of the platform and its SDK to unbind  [string]\n  --caliper-bind-cwd   The working directory for performing the SDK removal  [string]\n  --caliper-bind-args  Additional arguments to pass to \"npm remove\". Use the \"=\" notation when setting this parameter  [string]\n  --caliper-bind-file  Yaml file to override default (supported) package versions when unbinding an SDK  [string]\n</code></pre></p> <p>Note</p> <p>It is recommended to either bind/unbind globally (as done by the Caliper Docker image), or use the <code>--caliper-bind-args=\"--save-dev\"</code> argument when performing the binding/unbinding. This ensures that <code>npm</code> will correctly remove the packages.</p>"},{"location":"getting-started/installing-caliper/#the-launch-command","title":"The launch command","text":"<p>Caliper runs a benchmark by using worker processes to generate the workload, and by using a manager process to coordinate the different benchmark rounds among the worker processes. Accordingly, the CLI provides commands for launching both manager and worker processes.</p> <p>To have a look at the help page of the command, execute:</p> <pre><code>user@ubuntu:~/caliper-benchmarks$ npx caliper launch --help\ncaliper launch &lt;subcommand&gt;\n\nLaunch a Caliper process either in a manager or worker role.\n\nCommands:\n  caliper launch manager [options]  Launch a Caliper manager process to coordinate the benchmark run\n  caliper launch worker [options]  Launch a Caliper worker process to generate the benchmark workload\n\nOptions:\n  --help, -h  Show usage information  [boolean]\n  --version   Show version information  [boolean]\n</code></pre>"},{"location":"getting-started/installing-caliper/#the-launch-manager-command","title":"The launch manager command","text":"<p>The Caliper manager process can be considered as the entry point of a distributed benchmark run. It coordinates (and optionally spawns) the worker processes throughout the benchmark run.</p> <p>To have a look at the help page of the command, execute:</p> <pre><code>user@ubuntu:~/caliper-benchmarks$ npx caliper launch manager --help\nUsage:\n caliper launch manager --caliper-bind-sut fabric:2.2 [other options]\n\nOptions:\n  --help, -h           Show usage information  [boolean]\n  --version            Show version information  [boolean]\n  --caliper-bind-sut   The name and version of the platform to bind to  [string]\n  --caliper-bind-cwd   The working directory for performing the SDK install  [string]\n  --caliper-bind-args  Additional arguments to pass to \"npm install\". Use the \"=\" notation when setting this parameter  [string]\n  --caliper-bind-file  Yaml file to override default (supported) package versions when binding an SDK  [string]\n</code></pre> <p>As you can see, the <code>launch manager</code> command can also process the parameters of the <code>bind</code> command, just in case you would like to perform the binding and the benchmark run in one step.</p> <p>However, the command requires the following parameters to be set:</p> <ul> <li>caliper-workspace: the directory serving as the root of your project. Every relative path in other configuration files or settings will be resolved from this directory. The workspace concept was introduced to make Caliper projects portable across different machines.</li> <li>caliper-benchconfig: the path of the file containing the configuration of the test rounds, as detailed in the Architecture page. Should be relative to the workspace path.</li> <li>caliper-networkconfig: the path of the file containing the network configuration/description for the selected SUT, detailed in the configuration pages of the respective adapters. Should be relative to the workspace path.</li> </ul>"},{"location":"getting-started/installing-caliper/#the-launch-worker-command","title":"The launch worker command","text":"<p>The Caliper worker processes are responsible for generating the workload during the benchmark run. Usually more than one worker process is running, coordinated by the single manager process.</p> <p>To have a look at the help page of the command, execute:</p> <p><pre><code>user@ubuntu:~/caliper-benchmarks$ npx caliper launch worker --help\nUsage:\n caliper launch manager --caliper-bind-sut fabric:2.2 [other options]\n\nOptions:\n  --help, -h           Show usage information  [boolean]\n  --version            Show version information  [boolean]\n  --caliper-bind-sut   The name and version of the platform to bind to  [string]\n  --caliper-bind-cwd   The working directory for performing the SDK install  [string]\n  --caliper-bind-args  Additional arguments to pass to \"npm install\". Use the \"=\" notation when setting this parameter  [string]\n  --caliper-bind-file  Yaml file to override default (supported) package versions when binding an SDK  [string]\n</code></pre> As you can see, you can configure the worker processes the same way as the manager process. Including the optional binding step, but also the three mandatory parameters mentioned in the previous section.</p>"},{"location":"getting-started/installing-caliper/#caliper-test-phase-control","title":"Caliper test phase control","text":"<p>Caliper commands are capable of passing all runtime configuration settings. A subset of these commands are for flow control that provide direct control over the following Caliper phases:</p> <ul> <li>start</li> <li>init</li> <li>install</li> <li>test</li> <li>end</li> </ul> <p>It is possible to skip, or perform only one of the above phases through use of the correct flag. For instance, it is common to have an existing network that may be targeted by Caliper through the provision of a <code>--caliper-flow-only-test</code> flag.</p>"},{"location":"getting-started/installing-caliper/#installing-from-npm","title":"Installing from NPM","text":"<p>Caliper is published as the @hyperledger/caliper-cli NPM package, providing a single point of install for every supported adapter.</p>"},{"location":"getting-started/installing-caliper/#versioning-semantics","title":"Versioning semantics","text":"<p>Before explaining the steps for installing Caliper, let\u2019s take a look at the <code>Versions</code> page of the CLI package. You will see a list of tags and versions. If you are new to NPM, think of versions as immutable pointers to a specific version (duh) of the source code, while tags are mutable pointers to a specific version. So tags can change where they point to. Easy, right?</p> <p>But why is all this important to you? Because Caliper is still in its pre-release life-cycle (&lt; v1.0.0), meaning that even minor version bumps are allowed to introduce breaking changes. And if you use Caliper in your project, you might run into some surprises depending on how you install Caliper from time to time.</p> <p>Note</p> <p>Until Caliper reaches v1.0.0, always use the explicit version numbers when installing from NPM. So let\u2019s forget about the <code>latest</code> tag, as of now they are just a mandatory hindrance of NPM. We deliberately do not provide such tags for the Docker images.</p> <p>Let\u2019s see the three types of version numbers you will encounter:</p> <ul> <li><code>0.6.0</code>: Version numbers of this form denote releases deemed stable by the maintainers. Such versions have a corresponding GitHub tag, both in the <code>caliper</code> and <code>caliper-benchmarks</code> repositories. Moreover, the latest stable version is documented by the matching version of the documentation page. So make sure to align the different versions if you run into some issue.</li> <li><code>0.6.1-unstable-20240422122901</code>: Such version \u201cnumbers\u201d denote unstable releases that are published upon every merged pull request (hence the timestamp at the end), and eventually will become a stable version, e.g., <code>0.6.1</code>. This way you always have access to the NPM (and Docker) artifacts pertaining to the <code>main</code> branch of the repository. Let\u2019s find and fix the bugs of new features before they make it to the stable release!</li> <li><code>unstable</code>: This is the very latest unstable release that has been published and would correspond to a version also published as <code>0.6.1-unstable-&lt;some date&gt;</code>. This lets you quickly work with the very latest code from the <code>main</code> branch.</li> </ul> <p>Note</p> <p>The newest unstable release always corresponds to the up-to-date version of the related repositories, and the <code>vNext</code> version of the documentation page!</p>"},{"location":"getting-started/installing-caliper/#pre-requisites","title":"Pre-requisites","text":"<ul> <li>Node.js v18 LTS, v20 LTS or v22 LTS version is required to install the Caliper CLI from NPM:</li> <li>Docker version 20.10.11 or later is required for use with the Caliper docker image</li> </ul> <p>The following tools may be required depending on which SUT and version you bind to</p> <ul> <li>python3, make, g++ and git (for fetching and compiling some packages during bind)</li> </ul>"},{"location":"getting-started/installing-caliper/#local-npm-install","title":"Local NPM install","text":"<p>Note</p> <p>this is the highly recommended way to install Caliper for your project. Keeping the project dependencies local makes it easier to setup multiple Caliper projects. Global dependencies would require re-binding every time before a new benchmark run (to ensure the correct global dependencies).</p> <ol> <li>Install the Caliper CLI as you would any other NPM package. It is highly recommended to explicitly specify the version number, e.g., <code>@hyperledger/caliper-cli@0.6.0</code></li> <li>Bind the CLI to the required platform SDK (e.g., <code>fabric</code> with the <code>fabric-gateway</code> SDK).</li> <li>Invoke the local CLI binary (using npx) with the appropriate parameters. You can repeat this step for as many benchmarks as you would like.</li> </ol> <p>Putting it all together:</p> <pre><code>user@ubuntu:~/caliper-benchmarks$ npm install --only=prod @hyperledger/caliper-cli@0.6.0\nuser@ubuntu:~/caliper-benchmarks$ npx caliper bind --caliper-bind-sut fabric:fabric-gateway\nuser@ubuntu:~/caliper-benchmarks$ npx caliper launch manager \\\n    --caliper-workspace . \\\n    --caliper-benchconfig benchmarks/scenario/simple/config.yaml \\\n    --caliper-networkconfig networks/fabric/test-network.yaml\n</code></pre> <p>We could also perform the binding automatically when launching the manager process (note the extra parameter for <code>caliper launch manager</code>):</p> <pre><code>user@ubuntu:~/caliper-benchmarks$ npm install --only=prod @hyperledger/caliper-cli@0.6.0\nuser@ubuntu:~/caliper-benchmarks$ npx caliper launch manager \\\n    --caliper-bind-sut fabric:fabric-gateway \\\n    --caliper-workspace . \\\n    --caliper-benchconfig benchmarks/scenario/simple/config.yaml \\\n    --caliper-networkconfig networks/fabric/test-network.yaml\n</code></pre> <p>Note</p> <p>specifying the <code>--only=prod</code> parameter in step 2 will ensure that the default latest SDK dependencies for every platform will not be installed. Since we perform an explicit binding anyway (and only for a single platform), this is the desired approach, while also saving some storage and time.</p> <p>Note</p> <p>always make sure that the versions of the SUT, the bound SDK and the used artifacts match!</p>"},{"location":"getting-started/installing-caliper/#global-npm-install","title":"Global NPM install","text":"<p>Note</p> <p>make sure that you have a really good reason for installing the Caliper CLI globally. The recommended approach is the local install. That way your project is self-contained and you can easily setup multiple projects (in multiple directories) that each target a different SUT (or just different SUT versions). Installing or re-binding dependencies globally can get tricky.</p> <p>There are some minor differences compared to the local install:</p> <ol> <li>You can perform the install, bind and run steps from anywhere (just specify the workspace accordingly).</li> <li>You need to install the CLI globally (<code>-g</code> flag).</li> <li>You need to tell the binding step to install the packages also globally (<code>--caliper-bind-args</code> parameter).</li> <li>You can omit the <code>npx</code> command, since <code>caliper</code> will be in your <code>PATH</code>.</li> </ol> <pre><code>user@ubuntu:~$ npm install -g --only=prod @hyperledger/caliper-cli@0.6.0\nuser@ubuntu:~$ caliper bind --caliper-bind-sut fabric:2.2 --caliper-bind-args=-g\nuser@ubuntu:~$ caliper launch manager \\\n    --caliper-workspace ~/caliper-benchmarks \\\n    --caliper-benchconfig benchmarks/scenario/simple/config.yaml \\\n    --caliper-networkconfig networks/fabric/test-network.yaml\n</code></pre> <p>Note</p> <p>for global install you don\u2019t need to change the directory to your workspace, you can simply specify <code>--caliper-workspace ~/caliper-benchmarks</code>. But this way you can\u2019t utilize the auto complete feature of your commandline for the relative paths of the artifacts.</p> <p>Depending on your NPM settings, your user might need write access to directories outside of its home directory. This usually results in \u201cAccess denied\u201d errors. The following pointers here can guide you to circumvent the problem.</p>"},{"location":"getting-started/installing-caliper/#using-the-docker-image","title":"Using the Docker image","text":"<p>Caliper is published as the hyperledger/caliper Docker image, providing a single point of usage for every supported adapter.</p> <p>The important properties of the image are the following:</p> <ul> <li>Working directory: <code>/hyperledger/caliper/workspace</code></li> <li>The commands are executed by the <code>node</code> user (created in the base image)</li> <li>The environment variable <code>CALIPER_WORKSPACE</code> is set to the <code>/hyperledger/caliper/workspace</code> directory</li> <li>The entry point is the globally installed <code>caliper</code> binary</li> <li>The environment variable <code>CALIPER_BIND_ARGS</code> is set to <code>-g</code>, so the binding step also occurs globally.</li> <li>The default command is set to <code>--version</code>. This must be overridden when using the image.</li> </ul> <p>This has the following implications:</p> <ol> <li>It is recommended to mount your local workspace to the <code>/hyperledger/caliper/workspace</code> container directory. The default <code>CALIPER_WORKSPACE</code> environment variable value points to this location, so you don\u2019t need to specify it explicitly, one less setting to modify.</li> <li>You need to choose a command to execute, either <code>launch manager</code> or <code>launch worker</code>. Check the Docker and Docker-Compose examples for the exact syntax.</li> <li>The binding step is still necessary, similarly to the NPM install approach. Whether you use the <code>launch manager</code> or <code>launch worker</code> command, you only need to set the required binding parameter. The easiest way to do this is through the <code>CALIPER_BIND_SUT</code> and <code>CALIPER_BIND_SDK</code> environment variables.</li> <li>You need to set the required parameters for the launched manager or worker. The easiest way to do this is through the <code>CALIPER_BENCHCONFIG</code> and <code>CALIPER_NETWORKCONFIG</code> environment variables.</li> </ol>"},{"location":"getting-started/installing-caliper/#starting-a-container","title":"Starting a container","text":"<p>Parts of starting a Caliper container (following the recommendations above):</p> <ol> <li>Pick the required image version</li> <li>Mount your local working directory to a container directory</li> <li>Set the required binding and run parameters</li> </ol> <p>Note</p> <p>the latest tag is not supported, i.e, you explicitly have to specify the image version you want: hyperledger/caliper:0.6.0, similar to the recommended approach for the NPM packages.</p> <p>Putting it all together, split into multiple lines for clarity, and naming the container <code>caliper</code>:</p> <pre><code>user@ubuntu:~/caliper-benchmarks$ docker run \\\n    -v $PWD:/hyperledger/caliper/workspace \\\n    -e CALIPER_BIND_SUT=fabric:fabric-gateway \\\n    -e CALIPER_BENCHCONFIG=benchmarks/scenario/simple/config.yaml \\\n    -e CALIPER_NETWORKCONFIG=networks/fabric/test-network.yaml \\\n    --name caliper hyperledger/caliper:0.6.0 launch manager\n</code></pre> <p>Note</p> <p>The above network configuration file contains a start script to spin up a local Docker-based Fabric network, which will not work in this form. So make sure to remove the start (and end) script, and change the node endpoints to remote addresses.</p>"},{"location":"getting-started/installing-caliper/#using-docker-compose","title":"Using docker-compose","text":"<p>The above command is more readable when converted to a <code>docker-compose.yaml</code> file:</p> <pre><code>version: '2'\n\nservices:\n    caliper:\n        container_name: caliper\n        image: hyperledger/caliper:0.6.0\n        command: launch manager\n        environment:\n        - CALIPER_BIND_SUT=fabric:fabric-gateway\n        - CALIPER_BENCHCONFIG=benchmarks/scenario/simple/config.yaml\n        - CALIPER_NETWORKCONFIG=networks/fabric/test-network.yaml\n        volumes:\n        - ~/caliper-benchmarks:/hyperledger/caliper/workspace\n</code></pre> <p>Once you navigate to the directory containing the <code>docker-compose.yaml</code> file, just execute:</p> <pre><code>docker-compose up\n</code></pre>"},{"location":"getting-started/installing-caliper/#license","title":"License","text":"<p>The Caliper codebase is released under the Apache 2.0 license. Any documentation developed by the Caliper Project is licensed under the Creative Commons Attribution 4.0 International License. You may obtain a copy of the license, titled CC-BY-4.0, at http://creativecommons.org/licenses/by/4.0/.</p>"},{"location":"getting-started/license/","title":"License","text":"<pre><code>                             Apache License\n                       Version 2.0, January 2004\n                    http://www.apache.org/licenses/\n</code></pre> <p>TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION</p> <ol> <li>Definitions.</li> </ol> <p>\u201cLicense\u201d shall mean the terms and conditions for use, reproduction, and distribution as defined by Sections 1 through 9 of this document.</p> <p>\u201cLicensor\u201d shall mean the copyright owner or entity authorized by the copyright owner that is granting the License.</p> <p>\u201cLegal Entity\u201d shall mean the union of the acting entity and all other entities that control, are controlled by, or are under common control with that entity. For the purposes of this definition, \u201ccontrol\u201d means (i) the power, direct or indirect, to cause the direction or management of such entity, whether by contract or otherwise, or (ii) ownership of fifty percent (50%) or more of the outstanding shares, or (iii) beneficial ownership of such entity.</p> <p>\u201cYou\u201d (or \u201cYour\u201d) shall mean an individual or Legal Entity exercising permissions granted by this License.</p> <p>\u201cSource\u201d form shall mean the preferred form for making modifications, including but not limited to software source code, documentation source, and configuration files.</p> <p>\u201cObject\u201d form shall mean any form resulting from mechanical transformation or translation of a Source form, including but not limited to compiled object code, generated documentation, and conversions to other media types.</p> <p>\u201cWork\u201d shall mean the work of authorship, whether in Source or Object form, made available under the License, as indicated by a copyright notice that is included in or attached to the work (an example is provided in the Appendix below).</p> <p>\u201cDerivative Works\u201d shall mean any work, whether in Source or Object form, that is based on (or derived from) the Work and for which the editorial revisions, annotations, elaborations, or other modifications represent, as a whole, an original work of authorship. For the purposes of this License, Derivative Works shall not include works that remain separable from, or merely link (or bind by name) to the interfaces of, the Work and Derivative Works thereof.</p> <p>\u201cContribution\u201d shall mean any work of authorship, including the original version of the Work and any modifications or additions to that Work or Derivative Works thereof, that is intentionally submitted to Licensor for inclusion in the Work by the copyright owner or by an individual or Legal Entity authorized to submit on behalf of the copyright owner. For the purposes of this definition, \u201csubmitted\u201d means any form of electronic, verbal, or written communication sent to the Licensor or its representatives, including but not limited to communication on electronic mailing lists, source code control systems, and issue tracking systems that are managed by, or on behalf of, the Licensor for the purpose of discussing and improving the Work, but excluding communication that is conspicuously marked or otherwise designated in writing by the copyright owner as \u201cNot a Contribution.\u201d</p> <p>\u201cContributor\u201d shall mean Licensor and any individual or Legal Entity on behalf of whom a Contribution has been received by Licensor and subsequently incorporated within the Work.</p> <ol> <li> <p>Grant of Copyright License. Subject to the terms and conditions of this License, each Contributor hereby grants to You a perpetual, worldwide, non-exclusive, no-charge, royalty-free, irrevocable copyright license to reproduce, prepare Derivative Works of, publicly display, publicly perform, sublicense, and distribute the Work and such Derivative Works in Source or Object form.</p> </li> <li> <p>Grant of Patent License. Subject to the terms and conditions of this License, each Contributor hereby grants to You a perpetual, worldwide, non-exclusive, no-charge, royalty-free, irrevocable (except as stated in this section) patent license to make, have made, use, offer to sell, sell, import, and otherwise transfer the Work, where such license applies only to those patent claims licensable by such Contributor that are necessarily infringed by their Contribution(s) alone or by combination of their Contribution(s) with the Work to which such Contribution(s) was submitted. If You institute patent litigation against any entity (including a cross-claim or counterclaim in a lawsuit) alleging that the Work or a Contribution incorporated within the Work constitutes direct or contributory patent infringement, then any patent licenses granted to You under this License for that Work shall terminate as of the date such litigation is filed.</p> </li> <li> <p>Redistribution. You may reproduce and distribute copies of the Work or Derivative Works thereof in any medium, with or without modifications, and in Source or Object form, provided that You meet the following conditions:</p> </li> </ol> <p>(a) You must give any other recipients of the Work or Derivative Works a copy of this License; and</p> <p>(b) You must cause any modified files to carry prominent notices stating that You changed the files; and</p> <p>\u00a9 You must retain, in the Source form of any Derivative Works that You distribute, all copyright, patent, trademark, and attribution notices from the Source form of the Work, excluding those notices that do not pertain to any part of the Derivative Works; and</p> <p>(d) If the Work includes a \u201cNOTICE\u201d text file as part of its distribution, then any Derivative Works that You distribute must include a readable copy of the attribution notices contained within such NOTICE file, excluding those notices that do not pertain to any part of the Derivative Works, in at least one of the following places: within a NOTICE text file distributed as part of the Derivative Works; within the Source form or documentation, if provided along with the Derivative Works; or, within a display generated by the Derivative Works, if and wherever such third-party notices normally appear. The contents of the NOTICE file are for informational purposes only and do not modify the License. You may add Your own attribution notices within Derivative Works that You distribute, alongside or as an addendum to the NOTICE text from the Work, provided that such additional attribution notices cannot be construed as modifying the License.</p> <p>You may add Your own copyright statement to Your modifications and may provide additional or different license terms and conditions for use, reproduction, or distribution of Your modifications, or for any such Derivative Works as a whole, provided Your use, reproduction, and distribution of the Work otherwise complies with the conditions stated in this License.</p> <ol> <li> <p>Submission of Contributions. Unless You explicitly state otherwise, any Contribution intentionally submitted for inclusion in the Work by You to the Licensor shall be under the terms and conditions of this License, without any additional terms or conditions. Notwithstanding the above, nothing herein shall supersede or modify the terms of any separate license agreement you may have executed with Licensor regarding such Contributions.</p> </li> <li> <p>Trademarks. This License does not grant permission to use the trade names, trademarks, service marks, or product names of the Licensor, except as required for reasonable and customary use in describing the origin of the Work and reproducing the content of the NOTICE file.</p> </li> <li> <p>Disclaimer of Warranty. Unless required by applicable law or agreed to in writing, Licensor provides the Work (and each Contributor provides its Contributions) on an \u201cAS IS\u201d BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied, including, without limitation, any warranties or conditions of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A PARTICULAR PURPOSE. You are solely responsible for determining the appropriateness of using or redistributing the Work and assume any risks associated with Your exercise of permissions under this License.</p> </li> <li> <p>Limitation of Liability. In no event and under no legal theory, whether in tort (including negligence), contract, or otherwise, unless required by applicable law (such as deliberate and grossly negligent acts) or agreed to in writing, shall any Contributor be liable to You for damages, including any direct, indirect, special, incidental, or consequential damages of any character arising as a result of this License or out of the use or inability to use the Work (including but not limited to damages for loss of goodwill, work stoppage, computer failure or malfunction, or any and all other commercial damages or losses), even if such Contributor has been advised of the possibility of such damages.</p> </li> <li> <p>Accepting Warranty or Additional Liability. While redistributing the Work or Derivative Works thereof, You may choose to offer, and charge a fee for, acceptance of support, warranty, indemnity, or other liability obligations and/or rights consistent with this License. However, in accepting such obligations, You may act only on Your own behalf and on Your sole responsibility, not on behalf of any other Contributor, and only if You agree to indemnify, defend, and hold each Contributor harmless for any liability incurred by, or claims asserted against, such Contributor by reason of your accepting any such warranty or additional liability.</p> </li> </ol> <p>END OF TERMS AND CONDITIONS</p> <p>APPENDIX: How to apply the Apache License to your work.</p> <pre><code>  To apply the Apache License to your work, attach the following\n  boilerplate notice, with the fields enclosed by brackets \"{}\"\n  replaced with your own identifying information. (Don't include\n  the brackets!)  The text should be enclosed in the appropriate\n  comment syntax for the file format. We also recommend that a\n  file or class name and description of purpose be included on the\n  same \"printed page\" as the copyright notice for easier\n  identification within third-party archives.\n</code></pre> <p>Copyright {yyyy} {name of copyright owner}</p> <p>Licensed under the Apache License, Version 2.0 (the \u201cLicense\u201d); you may not use this file except in compliance with the License. You may obtain a copy of the License at</p> <pre><code>   http://www.apache.org/licenses/LICENSE-2.0\n</code></pre> <p>Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \u201cAS IS\u201d BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.</p>"},{"location":"tutorial/","title":"Tutorials","text":"<p>These tutorials are specifically aimed at using Caliper to performance test different blockchain networks.</p> <p>Please select a tutorial from the navigation section on the left which takes you through performance testing a smart contract using Caliper.</p>"},{"location":"tutorial/fabric/","title":"Basic Fabric Tutorial","text":""},{"location":"tutorial/fabric/#overview","title":"Overview","text":"<p>This tutorial takes you through performance testing a smart contract on a pre-existing Fabric network using Caliper.</p> <p>To complete this tutorial you will need to have installed NodeJS. To do this, we recommend using nvm.</p> <p>This tutorial is based on resources available from the official Hyperledger Fabric documentation. A network comprised of two organizations and a solo orderer, with the javascript <code>asset-transfer-basic</code> smart contract, is assumed to be built and ready to performance test.</p> <p>Note</p> <p>The following command list is a minimalist quick step guide to get the required Fabric network up and running. We use available Hyperledger Fabric resources at explicit levels. To understand and troubleshoot what occurs during the creation of the test network, please refer to the Fabric documentation linked above!</p> <p>Ensure you have the following pre-reqs installed</p> <ul> <li>docker engine or docker desktop</li> <li>curl</li> <li>jq</li> <li>a supported node LTS version. a list current supported LTS versions can be found on the node.js website (to install node easily you can use the nvm tool found here) </li> </ul> <pre><code># Pull down the 2.5.7 hyperledger fabric and 1.5.10 hyperledger fabric ca images/binaries\ncurl -sSL https://raw.githubusercontent.com/hyperledger/fabric/main/scripts/bootstrap.sh | bash -s -- 2.5.7 1.5.10\ncd fabric-samples\n# As fabric-samples for hyperledger 2.5 is via the main branch, fix to a specific commit which we know works\n# to protect against potential breaking changes in main\ngit checkout c691cf94a99372e0225927d7927b1bc367018029\n# Start up the test-network\ncd test-network/\n./network.sh up createChannel\n./network.sh deployCC -ccn basic -ccp ../asset-transfer-basic/chaincode-javascript -ccl javascript\n</code></pre>"},{"location":"tutorial/fabric/#step-1-create-a-caliper-workspace","title":"Step 1 - Create a Caliper Workspace","text":"<p>Create a folder named caliper-workspace at the same level as the fabric-samples directory, and then within the caliper-workspace folder, create three folders named networks, benchmarks, and workload respectively</p> <p>Caliper installation and use will be based on a local npm installation. Within the caliper-workspace directory, install caliper CLI using the following terminal command:</p> <pre><code>npm install --only=prod @hyperledger/caliper-cli@0.6.0\n</code></pre> <p>Bind the SDK using the following terminal command:</p> <pre><code>npx caliper bind --caliper-bind-sut fabric:fabric-gateway\n</code></pre> <p>Further information relating to the installation and binding of Caliper may be found within the relevant documentation pages.</p> <p>Caliper requires two configuration files:</p> <ul> <li>The network configuration file, which describes the network under test and provides the test identities to use.</li> <li>The benchmark file, which defines the performance test to be completed via a sequenced set of test rounds, each specifying a workload module and a series of options to drive the workload over a time interval.</li> </ul> <p>We will now populate these folders with the assets required by Caliper.</p>"},{"location":"tutorial/fabric/#step-2-build-a-network-configuration-file","title":"Step 2 - Build a Network Configuration File","text":"<p>The network configuration file is the file required by Caliper workers to be able to submit and evaluate transactions on a Hyperledger Fabric network. The file can be in YAML or JSON format, this tutorial shows the YAML format.</p>"},{"location":"tutorial/fabric/#create-a-template-network-configuration-file","title":"Create a Template Network Configuration File","text":"<p>Under the networks folder create a template file called networkConfig.yaml with the following content:</p> <pre><code>name: Caliper test\nversion: \"2.0.0\"\n\ncaliper:\n  blockchain: fabric\n\nchannels:\n\norganizations:\n</code></pre> <p>name: The name for the configuration, in this instance \u201cCaliper test\u201d.</p> <p>version: The version of the configuration file being used. \u201c2.0.0\u201d ensures the new fabric connectors are used</p> <p>caliper: Indicates to Caliper the SUT that is being targeted, and may contain additional start/end commands or sut specific options that are not required within this tutorial. For the purposes of this tutorial, we are targeting a fabric network.</p> <p>channels: Describes the Hyperledger Fabric channels and the smart contracts deployed on these channels to be benchmarked.</p> <p>organizations: A list of the Hyperledger Fabric organizations with identities and connection profiles associated with each organization</p>"},{"location":"tutorial/fabric/#a-brief-introduction-to-common-connection-profiles-ccp","title":"A brief introduction to Common Connection Profiles (CCP)","text":"<p>Common Connection Profiles are a file format by which all the Hyperledger Fabric SDKs can use to connect to a Hyperledger Fabric Network. As Caliper utilizes the fabric node sdk to connect to the network, caliper makes use of these connection profiles. Whoever is responsible for building a Hyperledger Fabric network should create these files.</p> <p>A Common Connection Profile will be organization specific. So each organization will have their own unique file. Again the network provider should provide a file for each organization.</p> <p>These profiles can come in 2 forms termed <code>static</code> or <code>dynamic</code> in the Hyperledger Fabric documentation. In summary static connection profiles contain all the information up front about the fabric network. It contains, amongst other things, all the peers, orderers and channels that exist. A <code>dynamic</code> connection profile is minimal usually containing just 1 or 2 peers of your organization for which the SDK will need to use discovery with in order to determine all the required information to be able to interact with the fabric network.</p> <p>You will see that the <code>test-network</code> in fabric samples provides common connection profiles for each organization, and that they are dynamic connection profiles.</p>"},{"location":"tutorial/fabric/#populating-the-template-file","title":"Populating The Template File","text":"<p>Following the test-network tutorial, a Common Connection Profile is generated as well as a set of identities for each organization.</p> <p>We will be using Org1 whose MSP id is <code>Org1MSP</code>to connect in this example, so there is no need to provide details about Org2 which is part of the test-network. Only having to provide a single organization is a very common pattern.</p>"},{"location":"tutorial/fabric/#organizations","title":"Organizations","text":"<p>Here we need to add information about the organization whose MSP id is <code>Org1MSP</code>. We need to provide a name, it\u2019s associated connection profile and at least 1 identity.</p> <p>The connection profile can be found in fabric-samples -&gt; test-network -&gt; organizations -&gt; peerOrganizations -&gt; org1.example.com. There are both json and yaml versions of this file, we will make use of connection-org1.yaml. These connection profiles are what Hyperledger Fabric refer to as dynamic so they are expected to be used in conjunction with discovery, therefore we need to declare that this connection profile requires the use of discovery.</p> <p>The identity we will use will be <code>User1@org1.example.com</code>.</p> <p>The private key can be found in fabric-samples -&gt; test-network -&gt; organizations -&gt; peerOrganizations -&gt; org1.example.com -&gt; users -&gt; User1 -&gt; msp -&gt; keystore -&gt; priv_sk</p> <p>The public certificate can be found in fabric-samples -&gt; test-network -&gt; organizations -&gt; peerOrganizations -&gt; org1.example.com -&gt; users -&gt; User1 -&gt; msp -&gt; signedcerts -&gt; User1@org1.example.com-cert.pem</p> <p>The identity will need to be given a unique name within the organization. It doesn\u2019t have to match the name that the <code>test-network</code> has used, ie <code>User1@org1.example.com</code> so to keep it simple let\u2019s just give it a name of <code>User1</code>. For the purposes of this tutorial we will just point to the certificate and private key files, but it\u2019s also possible to embed the information directly into the network configuration file.</p> <p>Below is the required organizations section that provides the above detail</p> <pre><code>organizations:\n  - mspid: Org1MSP\n    identities:\n      certificates:\n      - name: 'User1'\n        clientPrivateKey:\n          path: '../fabric-samples/test-network/organizations/peerOrganizations/org1.example.com/users/User1@org1.example.com/msp/keystore/priv_sk'\n        clientSignedCert:\n          path: '../fabric-samples/test-network/organizations/peerOrganizations/org1.example.com/users/User1@org1.example.com/msp/signcerts/User1@org1.example.com-cert.pem'\n    connectionProfile:\n      path: '../fabric-samples/test-network/organizations/peerOrganizations/org1.example.com/connection-org1.yaml'\n# Uncomment the next line only if you want to try this network configuration file binding to fabric:2.2, it's not required for fabric-gateway binding\n#      discover: true\n</code></pre> <p>Note the <code>-</code> sign in front of <code>mspid</code> and <code>name</code> in the above example. These are important as organizations could contain more than 1 organization. certificates can also contain a list defining more than 1 identity.</p> <p>One other important point to note; The first organization defined in the file is known as the default organization. In workload modules if you don\u2019t specify an invoking organization, then the default organization is used. As there is only 1 organization defined anyway you will not see any reference to the invoking organization in the workload implementation.</p>"},{"location":"tutorial/fabric/#channels","title":"Channels","text":"<p>The Fabric connector for Caliper requires assistance when creating connections to a Fabric network. A list of <code>channels</code> must be provided that lists the smart contracts that may be interacted with.</p> <p>As part of the <code>test-network</code> tutorial, a channel of <code>mychannel</code> will have been created and a contract (chaincode) with the id of basic will have been instantiated on that channel. We declare this as follows</p> <pre><code>channels:\n  - channelName: mychannel\n    contracts:\n    - id: basic\n</code></pre> <p>note the <code>-</code> sign in front of <code>channelName</code> and <code>id</code> in the above example. This is required because there can be more than 1 channel so channels specify a list of channels and contracts can have more than 1 contract (chaincode) ids that are of interest.</p>"},{"location":"tutorial/fabric/#the-complete-network-configuration-file","title":"The Complete Network Configuration File","text":"<p>The Caliper network configuration file should now be fully populated. It can be useful to take time to look over and ensure that the paths to the certificates, private keys and connection profile are correct.</p> <pre><code>name: Calier test\nversion: \"2.0.0\"\n\ncaliper:\n  blockchain: fabric\n\nchannels:\n  - channelName: mychannel\n    contracts:\n    - id: basic\n\norganizations:\n  - mspid: Org1MSP\n    identities:\n      certificates:\n      - name: 'User1'\n        clientPrivateKey:\n          path: '../fabric-samples/test-network/organizations/peerOrganizations/org1.example.com/users/User1@org1.example.com/msp/keystore/priv_sk'\n        clientSignedCert:\n          path: '../fabric-samples/test-network/organizations/peerOrganizations/org1.example.com/users/User1@org1.example.com/msp/signcerts/User1@org1.example.com-cert.pem'\n    connectionProfile:\n      path: '../fabric-samples/test-network/organizations/peerOrganizations/org1.example.com/connection-org1.yaml'\n# Uncomment the next line only if you want to try this network configuration file binding to fabric:2.2, it's not required for fabric-gateway binding\n#      discover: true\n</code></pre>"},{"location":"tutorial/fabric/#step-3-build-a-test-workload-module","title":"Step 3 - Build a Test Workload Module","text":"<p>The workload module interacts with the deployed smart contract during the benchmark round. The workload module extends the Caliper class <code>WorkloadModuleBase</code> from <code>caliper-core</code>. The workload module provides three overrides:</p> <ul> <li><code>initializeWorkloadModule</code> - used to initialize any required items for the benchmark</li> <li><code>submitTransaction</code> - used to interact with the smart contract method during the monitored phase of the benchmark</li> <li><code>cleanupWorkloadModule</code> - used to clean up after the completion of the benchmark</li> </ul> <p>For more information, please see the specific documentation on <code>Workload Configuration</code> accessible on the left hand menu.</p> <p>The workload we will be driving aims to benchmark the querying of existing assets within the world state database. Consequently we will use all three phases available in the workload module:</p> <ul> <li><code>initializeWorkloadModule</code> - to create assets that may be queried in the <code>submitTransaction</code> phase</li> <li><code>submitTransaction</code> - to query assets created in the <code>initializeWorkloadModule</code> phase</li> <li><code>cleanupWorkloadModule</code> - used to remove assets created in the <code>initializeWorkloadModule</code> phase so that the benchmark may be repeated</li> </ul>"},{"location":"tutorial/fabric/#create-a-template-workload-module","title":"Create A Template Workload Module","text":"<p>Within the workload folder create a file called readAsset.js with the following content:</p> <pre><code>'use strict';\n\nconst { WorkloadModuleBase } = require('@hyperledger/caliper-core');\n\nclass MyWorkload extends WorkloadModuleBase {\n    constructor() {\n        super();\n    }\n\n    async initializeWorkloadModule(workerIndex, totalWorkers, roundIndex, roundArguments, sutAdapter, sutContext) {\n        await super.initializeWorkloadModule(workerIndex, totalWorkers, roundIndex, roundArguments, sutAdapter, sutContext);\n    }\n\n    async submitTransaction() {\n        // NOOP\n    }\n\n    async cleanupWorkloadModule() {\n        // NOOP\n    }\n}\n\nfunction createWorkloadModule() {\n    return new MyWorkload();\n}\n\nmodule.exports.createWorkloadModule = createWorkloadModule;\n</code></pre>"},{"location":"tutorial/fabric/#populating-the-template-file_1","title":"Populating the Template File","text":"<p>When we populate this file we make reference to the available methods within the deployed smart contract assetTransfer.js file that can be found in: fabric-samples -&gt; asset-transfer-basic -&gt; chaincode-javascript -&gt; lib -&gt; assetTransfer.js</p>"},{"location":"tutorial/fabric/#populate-initializeworkloadmodule","title":"Populate initializeWorkloadModule","text":"<p>This method is used to prepare any items required by the primary <code>submitTransaction</code> method as the benchmark completes.</p> <p>The number of assets to be created will be given as <code>roundArguments.assets</code>. We create assets using the smart contract by populating an arguments object, which defines the transaction body, and using the Caliper API <code>sendRequests</code>, which requires knowledge of:</p> <ul> <li>contractId, the name of smart contract that is to be used and is present within the Caliper network configuration file</li> <li>contractFunction, the specific function within the smart contract to invoke</li> <li>contractArguments, the arguments to pass to the smart contract function</li> <li>invokerIdentity, the identity to use that is present within the Caliper network configuration file. This can be optional and caliper will select an identity for you (from the appropriate invoking organization or default organization) and in this tutorial there would only ever be 1 identity to pick but for completeness the examples explicitly define the identity.</li> <li>readOnly, if performing a query operation or not</li> </ul> <p>The method should look like this:</p> <pre><code>    async initializeWorkloadModule(workerIndex, totalWorkers, roundIndex, roundArguments, sutAdapter, sutContext) {\n        await super.initializeWorkloadModule(workerIndex, totalWorkers, roundIndex, roundArguments, sutAdapter, sutContext);\n\n        for (let i=0; i&lt;this.roundArguments.assets; i++) {\n            const assetID = `${this.workerIndex}_${i}`;\n            console.log(`Worker ${this.workerIndex}: Creating asset ${assetID}`);\n            const request = {\n                contractId: this.roundArguments.contractId,\n                contractFunction: 'CreateAsset',\n                invokerIdentity: 'User1',\n                contractArguments: [assetID,'blue','20','penguin','500'],\n                readOnly: false\n            };\n\n            await this.sutAdapter.sendRequests(request);\n        }\n    }\n</code></pre> <p>In the above example, different assets will be created that have the same parameters (blue, 20, penguin, 500). Comparing the above to the smart contract method itself, it should be evident that there is a 1:1 mapping of contract arguments to the method parameters.</p>"},{"location":"tutorial/fabric/#populate-submittransaction","title":"Populate submitTransaction","text":"<p>This method runs repeatedly in the benchmark test phase. We will be evaluating the <code>ReadAsset</code> smart contract method by querying the assets we created in the <code>initializeWorkloadModule</code> method.</p> <p>First, create a string identity for the asset to query, formed by the concatenation of the worker index and a random integer between 0 and the number of created assets.</p> <p>Then await the call on <code>sendRequests</code>, passing an object containing: <code>contractId</code> set as that passed in from the round arguments; <code>contractFunction</code> set as <code>ReadAsset</code>; <code>invokerIdentity</code> set as <code>User1</code>; and <code>chaincodeArguments</code> set as an array that contains the asset to query in this run.</p> <p>The method should look like this:</p> <pre><code>    async submitTransaction() {\n        const randomId = Math.floor(Math.random()*this.roundArguments.assets);\n        const myArgs = {\n            contractId: this.roundArguments.contractId,\n            contractFunction: 'ReadAsset',\n            invokerIdentity: 'User1',\n            contractArguments: [`${this.workerIndex}_${randomId}`],\n            readOnly: true\n        };\n\n        await this.sutAdapter.sendRequests(myArgs);\n    }\n</code></pre>"},{"location":"tutorial/fabric/#populate-cleanupworkloadmodule","title":"Populate cleanupWorkloadModule","text":"<p>This function is used to clean up after a test as it deletes the assets created in the <code>initializeWorkloadModule</code> function though use of the smart contract function <code>DeleteAsset</code>. The implementation is similar to that within <code>initializeWorkloadModule</code>. Note it is possible to refactor both <code>initializeWorkloadModule</code> and <code>cleanupWorkloadModule</code> to utilize a common method that performs the create/delete action, this is left to the interested reader.</p> <pre><code>   async cleanupWorkloadModule() {\n        for (let i=0; i&lt;this.roundArguments.assets; i++) {\n            const assetID = `${this.workerIndex}_${i}`;\n            console.log(`Worker ${this.workerIndex}: Deleting asset ${assetID}`);\n            const request = {\n                contractId: this.roundArguments.contractId,\n                contractFunction: 'DeleteAsset',\n                invokerIdentity: 'User1',\n                contractArguments: [assetID],\n                readOnly: false\n            };\n\n            await this.sutAdapter.sendRequests(request);\n        }\n    }\n</code></pre>"},{"location":"tutorial/fabric/#the-complete-workload-module","title":"The Complete Workload Module","text":"<p>The test callback file should now be fully populated:</p> <pre><code>'use strict';\n\nconst { WorkloadModuleBase } = require('@hyperledger/caliper-core');\n\nclass MyWorkload extends WorkloadModuleBase {\n    constructor() {\n        super();\n    }\n\n    async initializeWorkloadModule(workerIndex, totalWorkers, roundIndex, roundArguments, sutAdapter, sutContext) {\n        await super.initializeWorkloadModule(workerIndex, totalWorkers, roundIndex, roundArguments, sutAdapter, sutContext);\n\n        for (let i=0; i&lt;this.roundArguments.assets; i++) {\n            const assetID = `${this.workerIndex}_${i}`;\n            console.log(`Worker ${this.workerIndex}: Creating asset ${assetID}`);\n            const request = {\n                contractId: this.roundArguments.contractId,\n                contractFunction: 'CreateAsset',\n                invokerIdentity: 'User1',\n                contractArguments: [assetID,'blue','20','penguin','500'],\n                readOnly: false\n            };\n\n            await this.sutAdapter.sendRequests(request);\n        }\n    }\n\n    async submitTransaction() {\n        const randomId = Math.floor(Math.random()*this.roundArguments.assets);\n        const myArgs = {\n            contractId: this.roundArguments.contractId,\n            contractFunction: 'ReadAsset',\n            invokerIdentity: 'User1',\n            contractArguments: [`${this.workerIndex}_${randomId}`],\n            readOnly: true\n        };\n\n        await this.sutAdapter.sendRequests(myArgs);\n    }\n\n    async cleanupWorkloadModule() {\n        for (let i=0; i&lt;this.roundArguments.assets; i++) {\n            const assetID = `${this.workerIndex}_${i}`;\n            console.log(`Worker ${this.workerIndex}: Deleting asset ${assetID}`);\n            const request = {\n                contractId: this.roundArguments.contractId,\n                contractFunction: 'DeleteAsset',\n                invokerIdentity: 'User1',\n                contractArguments: [assetID],\n                readOnly: false\n            };\n\n            await this.sutAdapter.sendRequests(request);\n        }\n    }\n}\n\nfunction createWorkloadModule() {\n    return new MyWorkload();\n}\n\nmodule.exports.createWorkloadModule = createWorkloadModule;\n</code></pre>"},{"location":"tutorial/fabric/#step-4-build-a-benchmark-configuration-file","title":"Step 4 - Build a Benchmark Configuration File","text":"<p>The benchmark configuration file defines the benchmark rounds and references the defined workload module(s). It will specify the number of test workers to use when generating the load, the number of test rounds, the duration of each round, the rate control applied to the transaction load during each round, and options relating to monitors. This particular tutorial will not make use of any of the available resource and transaction monitors; for these details please refer to the documentation.</p> <p>The benchmark configuration file may be provided in a yaml or json format: here we will use a yaml format. Please note that yaml files are case sensitive and all labels are in lowercase.</p> <p>The benchmark configuration file has a single required stanza:</p> <pre><code>test:\n</code></pre>"},{"location":"tutorial/fabric/#create-a-template-benchmark-configuration-file","title":"Create A Template Benchmark Configuration File","text":"<p>Under the benchmarks folder create a file called myAssetBenchmark.yaml with the following content:</p> <pre><code>test:\n    name: basic-contract-benchmark\n    description: A test benchmark\n    workers:\n    rounds:\n</code></pre> <p>test: The root level block that contains the benchmark test information.</p> <p>name: The name of the test, in this case \u201cbasic-contract-benchmark\u201d.</p> <p>description: A description for the benchmark, in this case \u201cA test benchmark\u201d.</p> <p>workers: A set of keys used to define the number of workers (separate worker client instances) used in the subsequent benchmark.</p> <p>rounds: An array of distinct test rounds that will be progressed sequentially. Rounds may be used to benchmark different smart contract methods, or the same method in a different manner.</p>"},{"location":"tutorial/fabric/#populating-the-template-file_2","title":"Populating the Template File","text":"<p>We will now populate the template file to specify the number of workers and the test round that uses the workload module we have created.</p>"},{"location":"tutorial/fabric/#populate-workers","title":"Populate Workers","text":"<p>We will be using two separate workers, this is accomplished through the workers specification:</p> <pre><code>  number: 2\n</code></pre>"},{"location":"tutorial/fabric/#populate-rounds","title":"Populate Rounds","text":"<p>Each <code>round</code> block contains the following:</p> <ul> <li><code>label</code> - the unique header label to use for the round.</li> <li><code>description</code> - a description of the round being run.</li> <li><code>txDuration</code> - the specification of the test duration, in seconds</li> <li><code>rateControl</code> - a rate control type, with options.</li> <li><code>workload</code>s - the workload module to use, with arguments to pass to the module. All arguments passed are available as roundArguments within the workload module.</li> </ul> <p>We will specify a benchmark round labeled <code>readAsset</code>, with the description <code>Query asset benchmark</code>, to run for a 30s duration, using a <code>fixed-load</code> rate controller aiming to maintain a constant transaction pressure of 2. Additionally we will be providing a workload through specification of our <code>readAsset.js</code> workload file, which we will pass the arguments <code>{assets: 10, contractId: asset-transfer-basic}</code>.</p> <p>The above is accomplished through the round specification:</p> <pre><code>    - label: readAsset\n      description: Read asset benchmark\n      txDuration: 30\n      rateControl:\n        type: fixed-load\n        opts:\n          transactionLoad: 2\n      workload:\n        module: workload/readAsset.js\n        arguments:\n          assets: 10\n          contractId: basic\n</code></pre>"},{"location":"tutorial/fabric/#the-complete-benchmark-configuration-file","title":"The Complete Benchmark Configuration File","text":"<p>The benchmark configuration file should now be fully populated:</p> <pre><code>test:\n    name: basic-contract-benchmark\n    description: test benchmark\n    workers:\n      number: 2\n    rounds:\n      - label: readAsset\n        description: Read asset benchmark\n        txDuration: 30\n        rateControl:\n          type: fixed-load\n          opts:\n            transactionLoad: 2\n        workload:\n          module: workload/readAsset.js\n          arguments:\n            assets: 10\n            contractId: basic\n</code></pre>"},{"location":"tutorial/fabric/#step-5-run-the-caliper-benchmark","title":"Step 5 - Run the Caliper Benchmark","text":"<p>We are now ready to run the performance benchmark using the above configuration files and test module. The performance benchmark will be run using the Caliper CLI, which will need to be supplied a path to the workspace and workspace relative paths to the network configuration file and the benchmark configuration file. This information is provided with the flags <code>--caliper-workspace</code>, <code>--caliper-networkconfig</code>, and <code>--caliper-benchconfig</code> respectively.</p> <p>Since the smart contract has already been installed and instantiated, Caliper only needs to perform the test phase. This is specified by using the flag <code>--caliper-flow-only-test</code>.</p>"},{"location":"tutorial/fabric/#run-the-command","title":"Run the command","text":"<p>Ensure that you are in the caliper-workspace directory.</p> <p>In the terminal run the following Caliper CLI command:</p> <p><code>npx caliper launch manager --caliper-workspace ./ --caliper-networkconfig networks/networkConfig.yaml --caliper-benchconfig benchmarks/myAssetBenchmark.yaml --caliper-flow-only-test</code></p>"},{"location":"tutorial/fabric/#benchmark-results","title":"Benchmark Results","text":"<p>The resulting report will detail the following items for each benchmark round:</p> <ul> <li>Name - the round name from the benchmark configuration file</li> <li>Succ/Fail - the number of successful/failing transactions</li> <li>Send Rate - the rate at which caliper issued the transactions</li> <li>Latency (max/min/avg) - statistics relating to the time taken in seconds between issuing a transaction and receiving a response</li> <li>Throughput - the average number of transactions processed per second</li> </ul> <p>You have successfully benchmarked a smart contract. You can repeat the test varying the benchmark parameters, as well as adding resource monitors. For the full set of options, please refer to the Caliper Documentation</p>"},{"location":"tutorial/fabric/#license","title":"License","text":"<p>The Caliper codebase is released under the Apache 2.0 license. Any documentation developed by the Caliper Project is licensed under the Creative Commons Attribution 4.0 International License. You may obtain a copy of the license, titled CC-BY-4.0, at http://creativecommons.org/licenses/by/4.0/.</p>"}]}